# Copyright (c) 2001, Stanford University
# All rights reserved.
#
# See the file LICENSE.txt for information on redistributing this software.

import sys, os

sys.path.append( "../../glapi_parser" )
import apiutil

# "mode" is source, header, or table
mode = sys.argv[1]

keys = apiutil.GetDispatchedFunctions("../../glapi_parser/APIspec.txt")
num_funcs = len(keys)

apiutil.CopyrightC()

print '/* DO NOT EDIT.  This code is generated by %s. */' % os.path.basename(sys.argv[0])
print

# Print the appropriate header.
if mode == 'source':
	print """
#include <stdio.h>
#include "cr_server.h"
#include "cr_packfunctions.h"
#include "tilesortspu.h"
#include "cr_dlm.h"
#include "tilesortspu_gen.h"
"""
	lastWasComment = 0
elif mode == 'table':
	print """
#include <stdio.h>
#include "cr_string.h"
#include "cr_spu.h"
#include "cr_packfunctions.h"
#include "cr_glstate.h"
#include "tilesortspu.h"
#include "tilesortspu_gen.h"

SPUNamedFunctionTable _cr_tilesort_table[%d];

static void __fillin( int offset, char *name, SPUGenericFunction func)
{
	_cr_tilesort_table[offset].name = crStrdup( name );
	_cr_tilesort_table[offset].fn = func;
}

void tilesortspuCreateFunctions( void )
{""" % (num_funcs + 1)
	table_index = 0
elif mode == 'header':
	pass
else:
	raise "unknown generation mode '%s'" % mode

for func_name in keys:
	return_type = apiutil.ReturnType(func_name)
	chromiumProps = apiutil.ChromiumProps(func_name)
	params = apiutil.Parameters(func_name)
	declarationString = apiutil.MakeDeclarationString(params)

	# If we have a non-generated (i.e. real) implementation of this
	# function, we don't need a source implementation, but we still
	# need a declaration.
	if apiutil.FindSpecial("tilesort", func_name):
		if mode == 'source': 
			print '/* %s not generated: special implementation exists */' % func_name
			lastWasComment = 1
		elif mode == 'table':
			print '\t__fillin( %3d, "%s", (SPUGenericFunction) tilesortspu_%s );' % (table_index, func_name, func_name)
			table_index += 1
		elif mode == 'header':
			print 'extern %s TILESORTSPU_APIENTRY tilesortspu_%s( %s );' % (return_type, func_name, declarationString)
		continue

	# We may need to generate a function, or we may be able to
	# just use crPack or crState calls; we have to examine the
	# properties of the function to tell for sure.
	needPack = apiutil.CanPack(func_name)
	needDL = 0
	needState = 0
	needUnimplemented = 0
	needWriteback = 0
	packSuffix = ""
	basicCallString = apiutil.MakeCallString(params)
	packCallString = basicCallString
	dlmCallString = basicCallString

	needThreadDeclaration = 0
	needClientStateDeclaration = 0

	# Only the main source needs to handle display lists
	if apiutil.CanCompile(func_name):
		needDL = 1
		needThreadDeclaration = 1
	if apiutil.SetsTrackedState(func_name):
		needState = 1
		needPack = 0
	if apiutil.UsesClientState(func_name) and not apiutil.IsQuery(func_name):
		dlmCallString = basicCallString + ", clientState"
		needThreadDeclaration = 1
		needClientStateDeclaration = 1
		packCallString = packCallString + ", &(clientState->unpack)"
	if apiutil.FindSpecial("tilesort_bbox", func_name):
		packSuffix = "BBOX_COUNT"
	if "serverdependent" in chromiumProps:
		needThreadDeclaration = 1
		needWriteback = 1
		needState = 0
		needPack = 0
		if return_type != 'void':
			packCallString += ", &return_value"
		packCallString += ", &writeback"
	if apiutil.FindSpecial("tilesort_unimplemented", func_name):
		needUnimplemented = 1
		needThreadDeclaration = 0
		needClientDeclaration = 0
		needDL = 0
		needState = 0
		needPack = 0
		needWriteback = 0

	# Trivial implementations can be resolved with a simple external call.
	# Check: query functions that can be trivialized with a crState call
	if apiutil.IsQuery(func_name) and not needUnimplemented and not needWriteback:
		if mode == 'source':
			print '/* %s not generated: crState query suffices */' % func_name
			lastWasComment = 1
		elif mode == 'table':
			print '\t__fillin( %3d, "%s", (SPUGenericFunction) crState%s );' % (table_index, func_name, func_name)
			table_index += 1
		elif mode == 'header':
			pass
		continue

	# Check: functions that can be trivialized with a crPack call.
	if needPack and not needDL and not needState and not needUnimplemented and not needWriteback:
		if mode == 'source':
			print '/* %s not generated: crPack implementation suffices */' % func_name
			lastWasComment = 1
		elif mode == 'table':
			print '\t__fillin( %3d, "%s", (SPUGenericFunction) (tilesort_spu.swap ? crPack%s%sSWAP : crPack%s%s) );' % (table_index, func_name, func_name, packSuffix, func_name, packSuffix)
			table_index += 1
		elif mode == 'header':
			pass
		continue

	# Check: functions that can be trivialized with a crState call.
	if not needPack and not needDL and needState and not needUnimplemented and not needWriteback:
		if mode == 'source':
			print '/* %s not generated: crState implementation suffices */' % func_name
			lastWasComment = 1
		elif mode == 'table':
			print '\t__fillin( %3d, "%s", (SPUGenericFunction) crState%s );' % (table_index, func_name, func_name)
			table_index += 1
		elif mode == 'header':
			pass
		continue

	# All done with the easy functions.  Here, start generation of a custom function.
	if mode == 'source':
		pass
	elif mode == 'table':
		print '\t__fillin( %3d, "%s", (SPUGenericFunction) tilesortspu_%s );' % (table_index, func_name, func_name)
		table_index += 1
		continue
	elif mode == 'header':
		print 'extern %s TILESORTSPU_APIENTRY tilesortspu_%s( %s );' % (return_type, func_name, declarationString)
		continue

	# Everything remaining in this block is only executed when generating
	# the source file, so we no longer have to worry about whether we might
	# be generating headers or tables.

	# This makes comments prettier.
	if lastWasComment: 
		print ''
		lastWasComment = 0

	print '%s TILESORTSPU_APIENTRY tilesortspu_%s( %s )' % ( return_type, func_name, declarationString )
	print '{'
	if needThreadDeclaration:
		print '\tGET_THREAD(thread);'
	if needClientStateDeclaration:
		print '\tCRClientState *clientState = &(thread->currentContext->State->client);'
	if needWriteback:
		print '\tGLuint i;'
		if return_type != "void":
			print '\t%s return_value = 0;' % return_type

	# This function may be intentionally unimplemented.
	if needUnimplemented:
		for (name, type, vecSize) in params:
			print '\t(void) %s;' % name
		print '\tcrWarning("Unimplemented tilesort function %s\\n");' % func_name
		if return_type != 'void':
			print '\t return 0;'

	# If this element can be compiled into a display list, we have
	# to check to see if it should be compiled first.  It should
	# be compiled if:
	#   - it's a state function, and either lazy DL distribution or
	#	 DL state tracking is enabled, and a DL is open; or
	#   - it's not a state function, and lazy DL distribution is enabled,
	#	 and a DL is open.
	# (If we're only doing DL state tracking, we don't need to compile
	# the non-state primitives.)
	#
	# Note that in all cases, GL_COMPILE_AND_EXECUTE mode is implemented
	# as a compile (without execution) followed by a call.  This 
	# allows lazy DL distribution to work.
	if needDL:
		# XXX The current crserver code can create a situation where SPU functions
		# may be called before the SPU's MakeCurrent() routine is called.  (This
		# occurs whena buffer comes in for a new context, and the crserver tries
		# to do a state difference operation to bring its master context to the
		# appropriate state; it does the difference by calling the head SPU's
		# dispatch table through the state differencing API.)
		#
		# This is bad for SPUs that rely on state set in the MakeCurrent() call.
		# (But the only known failure at this point is a segmentation fault in the
		# multitilesort.conf configuration.)
		#
		# For now, don't do anything drastic (i.e. anything outside a crState*()
		# function call) if there is no real thread information or no real 
		# current context.
		# 
		# This should eventually be fixed.  Here's the old conditional:
		# conditional = "thread->currentContext->displayListMode != GL_FALSE"
		conditional = "thread && thread->currentContext && thread->currentContext->displayListMode != GL_FALSE"
		if "checklist" in chromiumProps:
			# "checklist" means that this is an unusual function that
			# sometimes can be compiled, and sometimes cannot, based
			# on parameters.  We have to include a "checklist"
			# call to be certain.
			conditional += " && crDLMCheckList%s(%s)" % (func_name, basicCallString)

		print '\tif (%s) {' % conditional

		# If the code gets to here, it's trying to either compile a display list
		# locally, create a display list on the servers, or both.  First check
		# to see whether we have to compile the display list locally.  If we're
		# doing a lazy send, we have to compile all compilable functions; if
		# we're just tracking state, we only have to compile state functions.
		conditional = "tilesort_spu.lazySendDLists";
		if needState:
			conditional += " || tilesort_spu.listTrack"
		print '\t\tif (%s) {' % conditional
		print '\t\t\tcrDLMCompile%s(%s);' % (func_name, dlmCallString)

		# If this is a state function, it may be being compiled either because
		# lazy display lists are enabled, or because display list state tracking
		# is enabled.  
		#
		# In the former case, after compiling, we return immediately; otherwise,
		# we're trying to create display lists on servers, and we have to pack
		# ourselves up for transmission.
		if needState:
			print '\t\t\tif (tilesort_spu.lazySendDLists) return;'
			print '\t\t}'
			print '\t\tif (tilesort_spu.swap) {'
			print '\t\t\tcrPack%s%sSWAP(%s);' % (func_name, packSuffix, packCallString)
			print '\t\t}'
			print '\t\telse {'
			print '\t\t\tcrPack%s%s(%s);' % (func_name, packSuffix, packCallString)
			print '\t\t}'
			print '\t\treturn;'
		else:
			# If this is not a state function, the only reason we're in this block
			# is because lazy display lists are enabled.  In that case, we always
			# return after compilation.  (In the case where we're creating display
			# lists to be sent to servers, we'll fall through and do the pack below.)
			print '\t\t\treturn;'
			print '\t\t}'

		# Whew - we no longer have to worry about display lists.
		print '\t}'

	# See if we need to generate writeback code for this function.
	# We use writebacks for any state that has to be sent to the
	# server; we trust that all servers will respond with the same
	# values, because only the values from the last server are
	# actually returned to the caller.
	if needWriteback:
		print '\ttilesortspuFlush(thread);'
		print '\tcrPackReleaseBuffer(thread->packer);'
		print '\tfor (i=0; i<(unsigned int)tilesort_spu.num_servers; i++) {'
		print '\t\tint writeback = 1;'
		print '\t\tcrPackSetBuffer(thread->packer, &(thread->buffer[i]));'
		print '\t\tif (tilesort_spu.swap) {'
		print '\t\t\tcrPack%s%sSWAP(%s);' % (func_name, packSuffix, packCallString)
		print '\t\t}'
		print '\t\telse {'
		print '\t\t\tcrPack%s%s(%s);' % (func_name, packSuffix, packCallString)
		print '\t\t}'
		print '\t\tcrPackReleaseBuffer(thread->packer);'
		print '\t\ttilesortspuSendServerBuffer(i);'
		print '\t\twhile (writeback) crNetRecv();'
		if return_type != 'void':
			print '\t\tif (tilesort_spu.swap)'
			print '\t\t\treturn_value = (%s) SWAP32(return_value);' % return_type
		print '\t}'
		# Back to the default packer buffer
		print '\tcrPackSetBuffer(thread->packer, &(thread->geometry_buffer));'
		if return_type != 'void':
			print '\treturn return_value;'

	# If we get this far, we're executing normally.  State functions have
	# their state recorded locally; non-state functions are packed to be
	# sent to appropriate servers.
	if needState:
		if return_type == 'void':
			print '\tcrState%s( %s );' % ( func_name, basicCallString)
		else:
			print '\treturn crState%s( %s );' % ( func_name, basicCallString)
	elif needPack:
		print '\tif (tilesort_spu.swap)'
		print '\t{'
		print '\t\tcrPack%s%sSWAP(%s);' % (func_name, packSuffix, packCallString)
		print '\t}'
		print '\telse'
		print '\t{'
		print '\t\tcrPack%s%s(%s);' % (func_name, packSuffix, packCallString)
		print '\t}'

	# All done with this function.
	print '}'
	print ''

# Done with the whole file.  Print out any ending necessary.
if mode == 'source':
	pass
elif mode == 'table':
	print '\t__fillin( %3d, NULL, NULL );' % num_funcs
	print '}'
elif mode == 'header':
	pass
