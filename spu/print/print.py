# Copyright (c) 2001, Stanford University
# All rights reserved.
#
# See the file LICENSE.txt for information on redistributing this software.

import sys

sys.path.append( "../../glapi_parser" )
import apiutil


apiutil.CopyrightC()

print """
/* DO NOT EDIT - THIS FILE AUTOMATICALLY GENERATED BY print.py SCRIPT */
#include <stdio.h>
#include "cr_error.h"
#include "cr_spu.h"
#include "printspu.h"

#define PRINT_UNUSED(x) ((void)x)"""

printf_mapping = {
	'GLint':      ('%d','int'),
	'GLshort':    ('%hd','short'),
	'GLbyte':     ('%d','int'),
	'GLubyte':    ('%u','unsigned'),
	'GLuint':     ('%u','unsigned'),
	'GLushort':   ('%hu','unsigned short'),
	'GLenum':     ('%s','' ),
	'GLfloat':    ('%f','float'),
	'GLclampf':   ('%f','float'),
	'GLdouble':   ('%f','float'),
	'GLclampd':   ('%f','float'),
	'GLbitfield': ('0x%x','int'),
	'GLboolean':  ('%s',''),
	'GLsizei':    ('%u','unsigned')
}

returnvalue_mapping = {
	'GLint':      ('%d','int'),
	'GLuint':     ('%u','unsigned'),
	'GLboolean':  ('%hhd','char'),
}

keys = apiutil.GetDispatchedFunctions("../../glapi_parser/APIspec.txt")

for func_name in keys:
	if (apiutil.FindSpecial( 'printspu_unimplemented', func_name ) or
		apiutil.FindSpecial( 'printspu', func_name )):
		continue

	return_type = apiutil.ReturnType(func_name)
	params = apiutil.Parameters(func_name)

	print '\nstatic %s PRINT_APIENTRY print%s( %s )' % (return_type, func_name, apiutil.MakeDeclarationString(params))
	print '{'
	print '\tfprintf( print_spu.fp, "%s(' % func_name,

	printfstr = ""
	if len(params) == 0:
		argstr = ""
	else:
		argstr = ", "

	i = 0
	for (name, type, vecSize) in params:

		if vecSize > 0:
			# The parameter is a vector of known size, show it as a list
			# of values between brackets.
			printfstr += '['
			for index in range(vecSize):
				type = apiutil.PointerType(type)
				assert printf_mapping.has_key(type)
				if printf_mapping.has_key(type):
					(format, cast) = printf_mapping[type]
					printfstr += format
					cast_str = ''
					if cast != '':
						cast_str = '(%s)' % cast
					arg = '%s %s[%d]' % (cast_str, name, index)
					if type == 'GLboolean':
						argstr += '%s ? "GL_TRUE" : "GL_FALSE"' % arg
					else:
						argstr += arg
				if index != vecSize - 1:
					printfstr += ", "
					argstr += ", "
			printfstr += ']'
		else:
			# ordinary typed parameter, or vector of unknown size
			if printf_mapping.has_key( type ):
				(format_str, cast) = printf_mapping[type]
				printfstr += format_str
				cast_str = ''
				if cast != '':
					cast_str = '(%s)' % cast
				if type == 'GLenum':
					argstr += 'printspuEnumToStr( %s )' % name
				elif type == 'GLboolean':
					argstr += '%s ? "GL_TRUE" : "GL_FALSE"' % name
				else:
					argstr += '%s %s' % (cast_str,name)
			elif type.find( "*" ):
				printfstr += "%p"
				argstr += "(void *)"
				argstr += name
			else:
				argstr = ""
				printfstr = "???"
				break;
		#endif
		
		if i != len(params) - 1:
			printfstr += ", "
			argstr += ", "

		i += 1


	print '%s )\\n"%s );' % ( printfstr, argstr )
	print '\tfflush( print_spu.fp );'

	if returnvalue_mapping.has_key( return_type ):
		(format, type) = returnvalue_mapping[return_type]
		print '\t{'
		print '\t\t%s res = print_spu.passthrough.%s( %s );' % (type, func_name, apiutil.MakeCallString(params))
		print '\t\tfprintf( print_spu.fp, "= %s\\n", res);' % format
		print '\t\tfflush( print_spu.fp );'
		print '\t\treturn res;'
		print '\t}'
	elif return_type != "void":
		print '\treturn print_spu.passthrough.%s( %s );' % (func_name, apiutil.MakeCallString(params))
	else:
		print '\tprint_spu.passthrough.%s( %s );' % (func_name, apiutil.MakeCallString(params))

	print '}'

print 'SPUNamedFunctionTable _cr_print_table[] = {'
for index in range(len(keys)):
	func_name = keys[index]
	if apiutil.FindSpecial( 'printspu_unimplemented', func_name ):
		continue
	print '\t{ "%s", (SPUGenericFunction) print%s },' % (func_name, func_name )
print '\t{ NULL, NULL }'
print '};'
