# Generate the GL enum -> string lookup table code


import sys, re, string
sys.path.append( "../../glapi_parser" )
import apiutil


def ScanFile(filename):
	"""Open the named file and look for #define GL_* lines.
	Return a list of extracted (name, value) tuples.
	"""
	file = open(filename, "r")
	if not file:
		print "Error: couldn't open %s file!" % filename
		sys.exit()

	results = []
	pattern = re.compile("^\#define (GL_[A-Z\d_]+)[ \t]+(0x[A-Fa-f\d]+)")
	for line in file.readlines():
		m = re.match(pattern, line)
		if m:
			name = m.group(1)
			val = string.atol(m.group(2), 16)
			if name[-4:] == "_BIT":
				pass
			elif string.find(name, "_BIT_") != -1:
				pass
			elif val >= 0xffff:
				pass
			else:
				results.append( (name, val) )

	file.close()
	return results


def Comparator(p1, p2):
	"""Used to sort lists of (name, value) tuples."""
	if p1[1] == p2[1]:
		if p1[0] == p2[0]:
			return 0
		elif p1[0] < p2[0]:
			return -1
		else:
			return 1
	elif p1[1] < p2[1]:
		return -1
	else:
		return 1;


def RemoveDuplicates(list):
	"""Scan list, remove elements whose value is same as the preceding element.
	Return the new list."""
	results = []
	results.append(list[0])
	for (name, value) in list[1:]:
		if value != results[-1][1]:
			results.append((name, value))
	return results


def MatchMSB(list, msb):
	"""Search list of (name, value) pairs, returning new list in which
	values / 256 == msb."""
	results = []
	for (name, value) in list:
		if value / 256 == msb:
			results.append( (name, value) )
	return results


def GenerateBlock(group):
	"""group is a list of (name, value) pairs in which all values have the
	same Most Significant Byte.
	Prefix the list with, and insert dummy (name, value) pairs so that
	value % 256 = position in the list for all values.
	Example input:
	  [
		("GL_FOO", 0xcc02),
		("GL_BAR", 0xcc03),
		("GL_BAZ", 0xcc05)
	  ]
	And the result:
	  [ ("", 0xcc00),
		("", 0xcc01),
		("GL_FOO", 0xcc02),
		("GL_BAR", 0xcc03),
		("", 0xcc004),
		("GL_BAZ", 0xcc05)
	  ]
	"""
	i = 0
	block = []
	for (name, value) in group:
		while i < value % 256:
			block.append(("", value))
			i += 1
		assert i == value % 256
		block.append((name, value))
		i += 1
	return block


def GenerateTables(list):
	"""Given the list of all (name, value) pairs for all GL tokens, return a
	two-tupple (indexTable, stringTable) to emit as C code.
	The stringTable is a list of strings with dummy entries for padding.
	The indexTable is an array of (start,count) pairs.  The table is indexed
	by MSB to get a start value.  The start is an index into the string table.
	"""
	indexTable = []   # list of (offset,count) pairs
	stringTable = []  # list of strings
	for msb in range(256):
		group = MatchMSB(list, msb)
		block = GenerateBlock(group)
		blockLen = len(block)
		if blockLen > 0:
			count = len(stringTable)
			i = 0
			for (name, value) in block:
				s = '  /* %4d 0x%04x */  "%s",' % (count+i, value, name)
				stringTable.append(s)
				i += 1
			indexTable.append( (count, blockLen) )
		else:
			indexTable.append( (-1, -1) )
	return (indexTable, stringTable)



## Execution starts here

apiutil.CopyrightC()

print """
/* DO NOT EDIT - THIS FILE AUTOMATICALLY GENERATED BY enums.py SCRIPT */
#include <stdio.h>
#include "printspu.h"
"""

pairs = []
for arg in sys.argv:
	pairs += ScanFile(arg)
pairs.sort(Comparator)
pairs = RemoveDuplicates(pairs)
(indexes, strings) = GenerateTables(pairs)

print """
static const char *Strings[] = {"""
for s in strings:
	print s

print """
 ""
};


typedef struct {
  short start;
  short count;
} StartCountPair;

static const StartCountPair EnumIndex[257] = {
  /* MSB    start, count */"""

i = 0
for (offset, count) in indexes:
	print "{ /* %3d */  %3d, %3d }," % (i, offset, count)
	i += 1

print """
{ /* dummy */ -1,  -1 }
};


const char * printspuEnumToStr(GLenum value)
{
	static char buf[16];
	if (value < 0x10000) {
		/* must be a 2-byte value, so these calculations work */
		const int msb = value >> 8;
		const int lsb = value & 0xff;
		const StartCountPair *ent = &EnumIndex[msb];
		if (lsb < ent->count) {
			const char *str = Strings[ent->start + lsb];
			if (str)
				return str;
		}
	}
	sprintf(buf, "0x%x", (unsigned int) value);
	return buf;
}
"""
