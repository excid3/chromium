/* Copyright (c) 2001, Stanford University
	All rights reserved.

	See the file LICENSE.txt for information on redistributing this software. */
	

#include <stdio.h>
#include "cr_server.h"
#include "cr_packfunctions.h"
#include "replicatespu.h"
#include "cr_dlm.h"
#include "replicatespu_proto.h"

/* DO NOT EDIT.  This code is generated by replicatespu_generate.py. */

void REPLICATESPU_APIENTRY replicatespu_Accum( GLenum op, GLfloat value )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileAccum(op, value);
	}
	if (replicate_spu.swap)
	{
		crPackAccumSWAP(op, value);
	}
	else
	{
		crPackAccum(op, value);
	}
}

void REPLICATESPU_APIENTRY replicatespu_ActiveTextureARB( GLenum texture )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileActiveTextureARB(texture);
	}
	if (replicate_spu.swap)
	{
		crPackActiveTextureARBSWAP(texture);
	}
	else
	{
		crPackActiveTextureARB(texture);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateActiveTextureARB( texture );
	}
}

void REPLICATESPU_APIENTRY replicatespu_AlphaFunc( GLenum func, GLclampf ref )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileAlphaFunc(func, ref);
	}
	if (replicate_spu.swap)
	{
		crPackAlphaFuncSWAP(func, ref);
	}
	else
	{
		crPackAlphaFunc(func, ref);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateAlphaFunc( func, ref );
	}
}

GLboolean REPLICATESPU_APIENTRY replicatespu_AreProgramsResidentNV( GLsizei n, const GLuint * ids, GLboolean * residences )
{
	GET_THREAD(thread);
	int writeback = 1;
	GLboolean return_val = (GLboolean) 0;
	replicatespuFlushAll( (void *) thread );
	if (replicate_spu.swap)
	{
		crPackAreProgramsResidentNVSWAP(n, ids, residences, &return_val, &writeback);
	}
	else
	{
		crPackAreProgramsResidentNV(n, ids, residences, &return_val, &writeback);
	}
	replicatespuFlushOne(thread, 0);
	while (writeback)
		crNetRecv();
	if (replicate_spu.swap)
	{
		return_val = (GLboolean) SWAP32(return_val);
	}
	return return_val;
}

GLboolean REPLICATESPU_APIENTRY replicatespu_AreTexturesResident( GLsizei n, const GLuint * textures, GLboolean * residences )
{
	GET_THREAD(thread);
	int writeback = 1;
	GLboolean return_val = (GLboolean) 0;
	replicatespuFlushAll( (void *) thread );
	if (replicate_spu.swap)
	{
		crPackAreTexturesResidentSWAP(n, textures, residences, &return_val, &writeback);
	}
	else
	{
		crPackAreTexturesResident(n, textures, residences, &return_val, &writeback);
	}
	replicatespuFlushOne(thread, 0);
	while (writeback)
		crNetRecv();
	if (replicate_spu.swap)
	{
		return_val = (GLboolean) SWAP32(return_val);
	}
	return return_val;
}

/* ArrayElement not generated: special implementation exists */

void REPLICATESPU_APIENTRY replicatespu_BarrierCreateCR( GLuint name, GLuint count )
{
	GET_THREAD(thread);
	if (replicate_spu.swap)
	{
		crPackBarrierCreateCRSWAP(name, count);
	}
	else
	{
		crPackBarrierCreateCR(name, count);
	}
	replicatespuFlushOne(thread, 0);
}

/* BarrierDestroyCR not generated: crPack implementation suffices */

void REPLICATESPU_APIENTRY replicatespu_BarrierExecCR( GLuint name )
{
	GET_THREAD(thread);
	if (replicate_spu.swap)
	{
		crPackBarrierExecCRSWAP(name);
	}
	else
	{
		crPackBarrierExecCR(name);
	}
	replicatespuFlushOne(thread, 0);
}

/* Begin not generated: special implementation exists */

void REPLICATESPU_APIENTRY replicatespu_BeginQueryARB( GLenum target, GLuint id )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileBeginQueryARB(target, id);
	}
	if (replicate_spu.swap)
	{
		crPackBeginQueryARBSWAP(target, id);
	}
	else
	{
		crPackBeginQueryARB(target, id);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateBeginQueryARB( target, id );
	}
}

/* BindBufferARB not generated: special implementation exists */

void REPLICATESPU_APIENTRY replicatespu_BindProgramARB( GLenum target, GLuint program )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileBindProgramARB(target, program);
	}
	if (replicate_spu.swap)
	{
		crPackBindProgramARBSWAP(target, program);
	}
	else
	{
		crPackBindProgramARB(target, program);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateBindProgramARB( target, program );
	}
}

void REPLICATESPU_APIENTRY replicatespu_BindProgramNV( GLenum target, GLuint id )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileBindProgramNV(target, id);
	}
	if (replicate_spu.swap)
	{
		crPackBindProgramNVSWAP(target, id);
	}
	else
	{
		crPackBindProgramNV(target, id);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateBindProgramNV( target, id );
	}
}

void REPLICATESPU_APIENTRY replicatespu_BindTexture( GLenum target, GLuint texture )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileBindTexture(target, texture);
	}
	if (replicate_spu.swap)
	{
		crPackBindTextureSWAP(target, texture);
	}
	else
	{
		crPackBindTexture(target, texture);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateBindTexture( target, texture );
	}
}

void REPLICATESPU_APIENTRY replicatespu_Bitmap( GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte * bitmap )
{
	GET_THREAD(thread);
	ContextInfo *ctx = thread->currentContext;
	CRClientState *clientState = &(ctx->State->client);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileBitmap(width, height, xorig, yorig, xmove, ymove, bitmap, clientState);
	}
	if (replicate_spu.swap)
	{
		crPackBitmapSWAP(width, height, xorig, yorig, xmove, ymove, bitmap, &(clientState->unpack));
	}
	else
	{
		crPackBitmap(width, height, xorig, yorig, xmove, ymove, bitmap, &(clientState->unpack));
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateBitmap( width, height, xorig, yorig, xmove, ymove, bitmap );
	}
}

void REPLICATESPU_APIENTRY replicatespu_BlendColorEXT( GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileBlendColorEXT(red, green, blue, alpha);
	}
	if (replicate_spu.swap)
	{
		crPackBlendColorEXTSWAP(red, green, blue, alpha);
	}
	else
	{
		crPackBlendColorEXT(red, green, blue, alpha);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateBlendColorEXT( red, green, blue, alpha );
	}
}

void REPLICATESPU_APIENTRY replicatespu_BlendEquationEXT( GLenum mode )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileBlendEquationEXT(mode);
	}
	if (replicate_spu.swap)
	{
		crPackBlendEquationEXTSWAP(mode);
	}
	else
	{
		crPackBlendEquationEXT(mode);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateBlendEquationEXT( mode );
	}
}

void REPLICATESPU_APIENTRY replicatespu_BlendFunc( GLenum sfactor, GLenum dfactor )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileBlendFunc(sfactor, dfactor);
	}
	if (replicate_spu.swap)
	{
		crPackBlendFuncSWAP(sfactor, dfactor);
	}
	else
	{
		crPackBlendFunc(sfactor, dfactor);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateBlendFunc( sfactor, dfactor );
	}
}

void REPLICATESPU_APIENTRY replicatespu_BlendFuncSeparateEXT( GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorA, GLenum dfactorA )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileBlendFuncSeparateEXT(sfactorRGB, dfactorRGB, sfactorA, dfactorA);
	}
	if (replicate_spu.swap)
	{
		crPackBlendFuncSeparateEXTSWAP(sfactorRGB, dfactorRGB, sfactorA, dfactorA);
	}
	else
	{
		crPackBlendFuncSeparateEXT(sfactorRGB, dfactorRGB, sfactorA, dfactorA);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateBlendFuncSeparateEXT( sfactorRGB, dfactorRGB, sfactorA, dfactorA );
	}
}

/* BoundsInfoCR not generated: crPack implementation suffices */
/* BufferDataARB not generated: special implementation exists */
/* BufferSubDataARB not generated: crPack implementation suffices */
/* CallList not generated: special implementation exists */
/* CallLists not generated: special implementation exists */
/* ChromiumParameterfCR not generated: crPack implementation suffices */
/* ChromiumParameteriCR not generated: crPack implementation suffices */
/* ChromiumParametervCR not generated: special implementation exists */
/* Clear not generated: special implementation exists */

void REPLICATESPU_APIENTRY replicatespu_ClearAccum( GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileClearAccum(red, green, blue, alpha);
	}
	if (replicate_spu.swap)
	{
		crPackClearAccumSWAP(red, green, blue, alpha);
	}
	else
	{
		crPackClearAccum(red, green, blue, alpha);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateClearAccum( red, green, blue, alpha );
	}
}

void REPLICATESPU_APIENTRY replicatespu_ClearColor( GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileClearColor(red, green, blue, alpha);
	}
	if (replicate_spu.swap)
	{
		crPackClearColorSWAP(red, green, blue, alpha);
	}
	else
	{
		crPackClearColor(red, green, blue, alpha);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateClearColor( red, green, blue, alpha );
	}
}

void REPLICATESPU_APIENTRY replicatespu_ClearDepth( GLclampd depth )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileClearDepth(depth);
	}
	if (replicate_spu.swap)
	{
		crPackClearDepthSWAP(depth);
	}
	else
	{
		crPackClearDepth(depth);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateClearDepth( depth );
	}
}

void REPLICATESPU_APIENTRY replicatespu_ClearIndex( GLfloat c )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileClearIndex(c);
	}
	if (replicate_spu.swap)
	{
		crPackClearIndexSWAP(c);
	}
	else
	{
		crPackClearIndex(c);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateClearIndex( c );
	}
}

void REPLICATESPU_APIENTRY replicatespu_ClearStencil( GLint s )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileClearStencil(s);
	}
	if (replicate_spu.swap)
	{
		crPackClearStencilSWAP(s);
	}
	else
	{
		crPackClearStencil(s);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateClearStencil( s );
	}
}

void REPLICATESPU_APIENTRY replicatespu_ClientActiveTextureARB( GLenum texture )
{
	crStateClientActiveTextureARB( texture );
}

void REPLICATESPU_APIENTRY replicatespu_ClipPlane( GLenum plane, const GLdouble * equation )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileClipPlane(plane, equation);
	}
	if (replicate_spu.swap)
	{
		crPackClipPlaneSWAP(plane, equation);
	}
	else
	{
		crPackClipPlane(plane, equation);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateClipPlane( plane, equation );
	}
}

void REPLICATESPU_APIENTRY replicatespu_Color3b( GLbyte red, GLbyte green, GLbyte blue )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileColor3b(red, green, blue);
	}
	if (replicate_spu.swap)
	{
		crPackColor3bSWAP(red, green, blue);
	}
	else
	{
		crPackColor3b(red, green, blue);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Color3bv( const GLbyte * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileColor3bv(v);
	}
	if (replicate_spu.swap)
	{
		crPackColor3bvSWAP(v);
	}
	else
	{
		crPackColor3bv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Color3d( GLdouble red, GLdouble green, GLdouble blue )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileColor3d(red, green, blue);
	}
	if (replicate_spu.swap)
	{
		crPackColor3dSWAP(red, green, blue);
	}
	else
	{
		crPackColor3d(red, green, blue);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Color3dv( const GLdouble * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileColor3dv(v);
	}
	if (replicate_spu.swap)
	{
		crPackColor3dvSWAP(v);
	}
	else
	{
		crPackColor3dv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Color3f( GLfloat red, GLfloat green, GLfloat blue )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileColor3f(red, green, blue);
	}
	if (replicate_spu.swap)
	{
		crPackColor3fSWAP(red, green, blue);
	}
	else
	{
		crPackColor3f(red, green, blue);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Color3fv( const GLfloat * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileColor3fv(v);
	}
	if (replicate_spu.swap)
	{
		crPackColor3fvSWAP(v);
	}
	else
	{
		crPackColor3fv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Color3i( GLint red, GLint green, GLint blue )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileColor3i(red, green, blue);
	}
	if (replicate_spu.swap)
	{
		crPackColor3iSWAP(red, green, blue);
	}
	else
	{
		crPackColor3i(red, green, blue);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Color3iv( const GLint * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileColor3iv(v);
	}
	if (replicate_spu.swap)
	{
		crPackColor3ivSWAP(v);
	}
	else
	{
		crPackColor3iv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Color3s( GLshort red, GLshort green, GLshort blue )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileColor3s(red, green, blue);
	}
	if (replicate_spu.swap)
	{
		crPackColor3sSWAP(red, green, blue);
	}
	else
	{
		crPackColor3s(red, green, blue);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Color3sv( const GLshort * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileColor3sv(v);
	}
	if (replicate_spu.swap)
	{
		crPackColor3svSWAP(v);
	}
	else
	{
		crPackColor3sv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Color3ub( GLubyte red, GLubyte green, GLubyte blue )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileColor3ub(red, green, blue);
	}
	if (replicate_spu.swap)
	{
		crPackColor3ubSWAP(red, green, blue);
	}
	else
	{
		crPackColor3ub(red, green, blue);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Color3ubv( const GLubyte * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileColor3ubv(v);
	}
	if (replicate_spu.swap)
	{
		crPackColor3ubvSWAP(v);
	}
	else
	{
		crPackColor3ubv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Color3ui( GLuint red, GLuint green, GLuint blue )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileColor3ui(red, green, blue);
	}
	if (replicate_spu.swap)
	{
		crPackColor3uiSWAP(red, green, blue);
	}
	else
	{
		crPackColor3ui(red, green, blue);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Color3uiv( const GLuint * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileColor3uiv(v);
	}
	if (replicate_spu.swap)
	{
		crPackColor3uivSWAP(v);
	}
	else
	{
		crPackColor3uiv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Color3us( GLushort red, GLushort green, GLushort blue )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileColor3us(red, green, blue);
	}
	if (replicate_spu.swap)
	{
		crPackColor3usSWAP(red, green, blue);
	}
	else
	{
		crPackColor3us(red, green, blue);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Color3usv( const GLushort * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileColor3usv(v);
	}
	if (replicate_spu.swap)
	{
		crPackColor3usvSWAP(v);
	}
	else
	{
		crPackColor3usv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Color4b( GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileColor4b(red, green, blue, alpha);
	}
	if (replicate_spu.swap)
	{
		crPackColor4bSWAP(red, green, blue, alpha);
	}
	else
	{
		crPackColor4b(red, green, blue, alpha);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Color4bv( const GLbyte * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileColor4bv(v);
	}
	if (replicate_spu.swap)
	{
		crPackColor4bvSWAP(v);
	}
	else
	{
		crPackColor4bv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Color4d( GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileColor4d(red, green, blue, alpha);
	}
	if (replicate_spu.swap)
	{
		crPackColor4dSWAP(red, green, blue, alpha);
	}
	else
	{
		crPackColor4d(red, green, blue, alpha);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Color4dv( const GLdouble * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileColor4dv(v);
	}
	if (replicate_spu.swap)
	{
		crPackColor4dvSWAP(v);
	}
	else
	{
		crPackColor4dv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Color4f( GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileColor4f(red, green, blue, alpha);
	}
	if (replicate_spu.swap)
	{
		crPackColor4fSWAP(red, green, blue, alpha);
	}
	else
	{
		crPackColor4f(red, green, blue, alpha);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Color4fv( const GLfloat * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileColor4fv(v);
	}
	if (replicate_spu.swap)
	{
		crPackColor4fvSWAP(v);
	}
	else
	{
		crPackColor4fv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Color4i( GLint red, GLint green, GLint blue, GLint alpha )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileColor4i(red, green, blue, alpha);
	}
	if (replicate_spu.swap)
	{
		crPackColor4iSWAP(red, green, blue, alpha);
	}
	else
	{
		crPackColor4i(red, green, blue, alpha);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Color4iv( const GLint * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileColor4iv(v);
	}
	if (replicate_spu.swap)
	{
		crPackColor4ivSWAP(v);
	}
	else
	{
		crPackColor4iv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Color4s( GLshort red, GLshort green, GLshort blue, GLshort alpha )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileColor4s(red, green, blue, alpha);
	}
	if (replicate_spu.swap)
	{
		crPackColor4sSWAP(red, green, blue, alpha);
	}
	else
	{
		crPackColor4s(red, green, blue, alpha);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Color4sv( const GLshort * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileColor4sv(v);
	}
	if (replicate_spu.swap)
	{
		crPackColor4svSWAP(v);
	}
	else
	{
		crPackColor4sv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Color4ub( GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileColor4ub(red, green, blue, alpha);
	}
	if (replicate_spu.swap)
	{
		crPackColor4ubSWAP(red, green, blue, alpha);
	}
	else
	{
		crPackColor4ub(red, green, blue, alpha);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Color4ubv( const GLubyte * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileColor4ubv(v);
	}
	if (replicate_spu.swap)
	{
		crPackColor4ubvSWAP(v);
	}
	else
	{
		crPackColor4ubv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Color4ui( GLuint red, GLuint green, GLuint blue, GLuint alpha )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileColor4ui(red, green, blue, alpha);
	}
	if (replicate_spu.swap)
	{
		crPackColor4uiSWAP(red, green, blue, alpha);
	}
	else
	{
		crPackColor4ui(red, green, blue, alpha);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Color4uiv( const GLuint * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileColor4uiv(v);
	}
	if (replicate_spu.swap)
	{
		crPackColor4uivSWAP(v);
	}
	else
	{
		crPackColor4uiv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Color4us( GLushort red, GLushort green, GLushort blue, GLushort alpha )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileColor4us(red, green, blue, alpha);
	}
	if (replicate_spu.swap)
	{
		crPackColor4usSWAP(red, green, blue, alpha);
	}
	else
	{
		crPackColor4us(red, green, blue, alpha);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Color4usv( const GLushort * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileColor4usv(v);
	}
	if (replicate_spu.swap)
	{
		crPackColor4usvSWAP(v);
	}
	else
	{
		crPackColor4usv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_ColorMask( GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileColorMask(red, green, blue, alpha);
	}
	if (replicate_spu.swap)
	{
		crPackColorMaskSWAP(red, green, blue, alpha);
	}
	else
	{
		crPackColorMask(red, green, blue, alpha);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateColorMask( red, green, blue, alpha );
	}
}

void REPLICATESPU_APIENTRY replicatespu_ColorMaterial( GLenum face, GLenum mode )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileColorMaterial(face, mode);
	}
	if (replicate_spu.swap)
	{
		crPackColorMaterialSWAP(face, mode);
	}
	else
	{
		crPackColorMaterial(face, mode);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateColorMaterial( face, mode );
	}
}

void REPLICATESPU_APIENTRY replicatespu_ColorPointer( GLint size, GLenum type, GLsizei stride, const GLvoid * pointer )
{
	crStateColorPointer( size, type, stride, pointer );
}

void REPLICATESPU_APIENTRY replicatespu_CombinerInputNV( GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileCombinerInputNV(stage, portion, variable, input, mapping, componentUsage);
	}
	if (replicate_spu.swap)
	{
		crPackCombinerInputNVSWAP(stage, portion, variable, input, mapping, componentUsage);
	}
	else
	{
		crPackCombinerInputNV(stage, portion, variable, input, mapping, componentUsage);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateCombinerInputNV( stage, portion, variable, input, mapping, componentUsage );
	}
}

void REPLICATESPU_APIENTRY replicatespu_CombinerOutputNV( GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileCombinerOutputNV(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum);
	}
	if (replicate_spu.swap)
	{
		crPackCombinerOutputNVSWAP(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum);
	}
	else
	{
		crPackCombinerOutputNV(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateCombinerOutputNV( stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum );
	}
}

void REPLICATESPU_APIENTRY replicatespu_CombinerParameterfNV( GLenum pname, GLfloat param )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileCombinerParameterfNV(pname, param);
	}
	if (replicate_spu.swap)
	{
		crPackCombinerParameterfNVSWAP(pname, param);
	}
	else
	{
		crPackCombinerParameterfNV(pname, param);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateCombinerParameterfNV( pname, param );
	}
}

void REPLICATESPU_APIENTRY replicatespu_CombinerParameterfvNV( GLenum pname, const GLfloat * params )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileCombinerParameterfvNV(pname, params);
	}
	if (replicate_spu.swap)
	{
		crPackCombinerParameterfvNVSWAP(pname, params);
	}
	else
	{
		crPackCombinerParameterfvNV(pname, params);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateCombinerParameterfvNV( pname, params );
	}
}

void REPLICATESPU_APIENTRY replicatespu_CombinerParameteriNV( GLenum pname, GLint param )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileCombinerParameteriNV(pname, param);
	}
	if (replicate_spu.swap)
	{
		crPackCombinerParameteriNVSWAP(pname, param);
	}
	else
	{
		crPackCombinerParameteriNV(pname, param);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateCombinerParameteriNV( pname, param );
	}
}

void REPLICATESPU_APIENTRY replicatespu_CombinerParameterivNV( GLenum pname, const GLint * params )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileCombinerParameterivNV(pname, params);
	}
	if (replicate_spu.swap)
	{
		crPackCombinerParameterivNVSWAP(pname, params);
	}
	else
	{
		crPackCombinerParameterivNV(pname, params);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateCombinerParameterivNV( pname, params );
	}
}

void REPLICATESPU_APIENTRY replicatespu_CombinerStageParameterfvNV( GLenum stage, GLenum pname, const GLfloat * params )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileCombinerStageParameterfvNV(stage, pname, params);
	}
	if (replicate_spu.swap)
	{
		crPackCombinerStageParameterfvNVSWAP(stage, pname, params);
	}
	else
	{
		crPackCombinerStageParameterfvNV(stage, pname, params);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateCombinerStageParameterfvNV( stage, pname, params );
	}
}

void REPLICATESPU_APIENTRY replicatespu_CompressedTexImage1DARB( GLenum target, GLint level, GLenum internalFormat, GLsizei width, GLint border, GLsizei imagesize, const GLvoid * data )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE &&
		crDLMCheckListCompressedTexImage1DARB(target, level, internalFormat, width, border, imagesize, data)) {
		crDLMCompileCompressedTexImage1DARB(target, level, internalFormat, width, border, imagesize, data);
	}
	if (replicate_spu.swap)
	{
		crPackCompressedTexImage1DARBSWAP(target, level, internalFormat, width, border, imagesize, data);
	}
	else
	{
		crPackCompressedTexImage1DARB(target, level, internalFormat, width, border, imagesize, data);
	}
}

void REPLICATESPU_APIENTRY replicatespu_CompressedTexImage2DARB( GLenum target, GLint level, GLenum internalFormat, GLsizei width, GLsizei height, GLint border, GLsizei imagesize, const GLvoid * data )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE &&
		crDLMCheckListCompressedTexImage2DARB(target, level, internalFormat, width, height, border, imagesize, data)) {
		crDLMCompileCompressedTexImage2DARB(target, level, internalFormat, width, height, border, imagesize, data);
	}
	if (replicate_spu.swap)
	{
		crPackCompressedTexImage2DARBSWAP(target, level, internalFormat, width, height, border, imagesize, data);
	}
	else
	{
		crPackCompressedTexImage2DARB(target, level, internalFormat, width, height, border, imagesize, data);
	}
}

void REPLICATESPU_APIENTRY replicatespu_CompressedTexImage3DARB( GLenum target, GLint level, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imagesize, const GLvoid * data )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE &&
		crDLMCheckListCompressedTexImage3DARB(target, level, internalFormat, width, height, depth, border, imagesize, data)) {
		crDLMCompileCompressedTexImage3DARB(target, level, internalFormat, width, height, depth, border, imagesize, data);
	}
	if (replicate_spu.swap)
	{
		crPackCompressedTexImage3DARBSWAP(target, level, internalFormat, width, height, depth, border, imagesize, data);
	}
	else
	{
		crPackCompressedTexImage3DARB(target, level, internalFormat, width, height, depth, border, imagesize, data);
	}
}

void REPLICATESPU_APIENTRY replicatespu_CompressedTexSubImage1DARB( GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imagesize, const GLvoid * data )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileCompressedTexSubImage1DARB(target, level, xoffset, width, format, imagesize, data);
	}
	if (replicate_spu.swap)
	{
		crPackCompressedTexSubImage1DARBSWAP(target, level, xoffset, width, format, imagesize, data);
	}
	else
	{
		crPackCompressedTexSubImage1DARB(target, level, xoffset, width, format, imagesize, data);
	}
}

void REPLICATESPU_APIENTRY replicatespu_CompressedTexSubImage2DARB( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imagesize, const GLvoid * data )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileCompressedTexSubImage2DARB(target, level, xoffset, yoffset, width, height, format, imagesize, data);
	}
	if (replicate_spu.swap)
	{
		crPackCompressedTexSubImage2DARBSWAP(target, level, xoffset, yoffset, width, height, format, imagesize, data);
	}
	else
	{
		crPackCompressedTexSubImage2DARB(target, level, xoffset, yoffset, width, height, format, imagesize, data);
	}
}

void REPLICATESPU_APIENTRY replicatespu_CompressedTexSubImage3DARB( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imagesize, const GLvoid * data )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileCompressedTexSubImage3DARB(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imagesize, data);
	}
	if (replicate_spu.swap)
	{
		crPackCompressedTexSubImage3DARBSWAP(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imagesize, data);
	}
	else
	{
		crPackCompressedTexSubImage3DARB(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imagesize, data);
	}
}

void REPLICATESPU_APIENTRY replicatespu_CopyPixels( GLint x, GLint y, GLsizei width, GLsizei height, GLenum type )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileCopyPixels(x, y, width, height, type);
	}
	if (replicate_spu.swap)
	{
		crPackCopyPixelsSWAP(x, y, width, height, type);
	}
	else
	{
		crPackCopyPixels(x, y, width, height, type);
	}
	replicatespuFlushOne(thread, 0);
}

void REPLICATESPU_APIENTRY replicatespu_CopyTexImage1D( GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileCopyTexImage1D(target, level, internalFormat, x, y, width, border);
	}
	if (replicate_spu.swap)
	{
		crPackCopyTexImage1DSWAP(target, level, internalFormat, x, y, width, border);
	}
	else
	{
		crPackCopyTexImage1D(target, level, internalFormat, x, y, width, border);
	}
}

void REPLICATESPU_APIENTRY replicatespu_CopyTexImage2D( GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileCopyTexImage2D(target, level, internalFormat, x, y, width, height, border);
	}
	if (replicate_spu.swap)
	{
		crPackCopyTexImage2DSWAP(target, level, internalFormat, x, y, width, height, border);
	}
	else
	{
		crPackCopyTexImage2D(target, level, internalFormat, x, y, width, height, border);
	}
}

void REPLICATESPU_APIENTRY replicatespu_CopyTexSubImage1D( GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileCopyTexSubImage1D(target, level, xoffset, x, y, width);
	}
	if (replicate_spu.swap)
	{
		crPackCopyTexSubImage1DSWAP(target, level, xoffset, x, y, width);
	}
	else
	{
		crPackCopyTexSubImage1D(target, level, xoffset, x, y, width);
	}
}

void REPLICATESPU_APIENTRY replicatespu_CopyTexSubImage2D( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
	}
	if (replicate_spu.swap)
	{
		crPackCopyTexSubImage2DSWAP(target, level, xoffset, yoffset, x, y, width, height);
	}
	else
	{
		crPackCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
	}
}

void REPLICATESPU_APIENTRY replicatespu_CopyTexSubImage3D( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileCopyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height);
	}
	if (replicate_spu.swap)
	{
		crPackCopyTexSubImage3DSWAP(target, level, xoffset, yoffset, zoffset, x, y, width, height);
	}
	else
	{
		crPackCopyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height);
	}
}

/* CreateContext not generated: special implementation exists */

void REPLICATESPU_APIENTRY replicatespu_CullFace( GLenum mode )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileCullFace(mode);
	}
	if (replicate_spu.swap)
	{
		crPackCullFaceSWAP(mode);
	}
	else
	{
		crPackCullFace(mode);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateCullFace( mode );
	}
}

/* DeleteBuffersARB not generated: crPack implementation suffices */

void REPLICATESPU_APIENTRY replicatespu_DeleteFencesNV( GLsizei n, const GLuint * fences )
{
	if (replicate_spu.swap)
	{
		crPackDeleteFencesNVSWAP(n, fences);
	}
	else
	{
		crPackDeleteFencesNV(n, fences);
	}
	crStateDeleteFencesNV( n, fences );
}

/* DeleteLists not generated: special implementation exists */
/* DeleteProgramsARB not generated: crPack implementation suffices */
/* DeleteQueriesARB not generated: crPack implementation suffices */

void REPLICATESPU_APIENTRY replicatespu_DeleteTextures( GLsizei n, const GLuint * textures )
{
	if (replicate_spu.swap)
	{
		crPackDeleteTexturesSWAP(n, textures);
	}
	else
	{
		crPackDeleteTextures(n, textures);
	}
	crStateDeleteTextures( n, textures );
}

void REPLICATESPU_APIENTRY replicatespu_DepthFunc( GLenum func )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileDepthFunc(func);
	}
	if (replicate_spu.swap)
	{
		crPackDepthFuncSWAP(func);
	}
	else
	{
		crPackDepthFunc(func);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateDepthFunc( func );
	}
}

void REPLICATESPU_APIENTRY replicatespu_DepthMask( GLboolean flag )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileDepthMask(flag);
	}
	if (replicate_spu.swap)
	{
		crPackDepthMaskSWAP(flag);
	}
	else
	{
		crPackDepthMask(flag);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateDepthMask( flag );
	}
}

void REPLICATESPU_APIENTRY replicatespu_DepthRange( GLclampd zNear, GLclampd zFar )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileDepthRange(zNear, zFar);
	}
	if (replicate_spu.swap)
	{
		crPackDepthRangeSWAP(zNear, zFar);
	}
	else
	{
		crPackDepthRange(zNear, zFar);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateDepthRange( zNear, zFar );
	}
}

/* DestroyContext not generated: special implementation exists */

void REPLICATESPU_APIENTRY replicatespu_Disable( GLenum cap )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileDisable(cap);
	}
	if (replicate_spu.swap)
	{
		crPackDisableSWAP(cap);
	}
	else
	{
		crPackDisable(cap);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateDisable( cap );
	}
}

void REPLICATESPU_APIENTRY replicatespu_DisableClientState( GLenum array )
{
	crStateDisableClientState( array );
}

void REPLICATESPU_APIENTRY replicatespu_DisableVertexAttribArrayARB( GLuint index )
{
	crStateDisableVertexAttribArrayARB( index );
}

/* DrawArrays not generated: special implementation exists */

void REPLICATESPU_APIENTRY replicatespu_DrawBuffer( GLenum mode )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileDrawBuffer(mode);
	}
	if (replicate_spu.swap)
	{
		crPackDrawBufferSWAP(mode);
	}
	else
	{
		crPackDrawBuffer(mode);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateDrawBuffer( mode );
	}
}

/* DrawElements not generated: special implementation exists */

void REPLICATESPU_APIENTRY replicatespu_DrawPixels( GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels )
{
	GET_THREAD(thread);
	ContextInfo *ctx = thread->currentContext;
	CRClientState *clientState = &(ctx->State->client);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileDrawPixels(width, height, format, type, pixels, clientState);
	}
	if (replicate_spu.swap)
	{
		crPackDrawPixelsSWAP(width, height, format, type, pixels, &(clientState->unpack));
	}
	else
	{
		crPackDrawPixels(width, height, format, type, pixels, &(clientState->unpack));
	}
}

/* DrawRangeElements not generated: special implementation exists */

void REPLICATESPU_APIENTRY replicatespu_EdgeFlag( GLboolean flag )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileEdgeFlag(flag);
	}
	if (replicate_spu.swap)
	{
		crPackEdgeFlagSWAP(flag);
	}
	else
	{
		crPackEdgeFlag(flag);
	}
}

void REPLICATESPU_APIENTRY replicatespu_EdgeFlagPointer( GLsizei stride, const GLvoid * pointer )
{
	crStateEdgeFlagPointer( stride, pointer );
}

void REPLICATESPU_APIENTRY replicatespu_EdgeFlagv( const GLboolean * flag )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileEdgeFlagv(flag);
	}
	if (replicate_spu.swap)
	{
		crPackEdgeFlagvSWAP(flag);
	}
	else
	{
		crPackEdgeFlagv(flag);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Enable( GLenum cap )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileEnable(cap);
	}
	if (replicate_spu.swap)
	{
		crPackEnableSWAP(cap);
	}
	else
	{
		crPackEnable(cap);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateEnable( cap );
	}
}

void REPLICATESPU_APIENTRY replicatespu_EnableClientState( GLenum array )
{
	crStateEnableClientState( array );
}

void REPLICATESPU_APIENTRY replicatespu_EnableVertexAttribArrayARB( GLuint index )
{
	crStateEnableVertexAttribArrayARB( index );
}

/* End not generated: special implementation exists */
/* EndList not generated: special implementation exists */

void REPLICATESPU_APIENTRY replicatespu_EndQueryARB( GLenum target )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileEndQueryARB(target);
	}
	if (replicate_spu.swap)
	{
		crPackEndQueryARBSWAP(target);
	}
	else
	{
		crPackEndQueryARB(target);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateEndQueryARB( target );
	}
}

void REPLICATESPU_APIENTRY replicatespu_EvalCoord1d( GLdouble u )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileEvalCoord1d(u);
	}
	if (replicate_spu.swap)
	{
		crPackEvalCoord1dSWAP(u);
	}
	else
	{
		crPackEvalCoord1d(u);
	}
}

void REPLICATESPU_APIENTRY replicatespu_EvalCoord1dv( const GLdouble * u )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileEvalCoord1dv(u);
	}
	if (replicate_spu.swap)
	{
		crPackEvalCoord1dvSWAP(u);
	}
	else
	{
		crPackEvalCoord1dv(u);
	}
}

void REPLICATESPU_APIENTRY replicatespu_EvalCoord1f( GLfloat u )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileEvalCoord1f(u);
	}
	if (replicate_spu.swap)
	{
		crPackEvalCoord1fSWAP(u);
	}
	else
	{
		crPackEvalCoord1f(u);
	}
}

void REPLICATESPU_APIENTRY replicatespu_EvalCoord1fv( const GLfloat * u )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileEvalCoord1fv(u);
	}
	if (replicate_spu.swap)
	{
		crPackEvalCoord1fvSWAP(u);
	}
	else
	{
		crPackEvalCoord1fv(u);
	}
}

void REPLICATESPU_APIENTRY replicatespu_EvalCoord2d( GLdouble u, GLdouble v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileEvalCoord2d(u, v);
	}
	if (replicate_spu.swap)
	{
		crPackEvalCoord2dSWAP(u, v);
	}
	else
	{
		crPackEvalCoord2d(u, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_EvalCoord2dv( const GLdouble * u )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileEvalCoord2dv(u);
	}
	if (replicate_spu.swap)
	{
		crPackEvalCoord2dvSWAP(u);
	}
	else
	{
		crPackEvalCoord2dv(u);
	}
}

void REPLICATESPU_APIENTRY replicatespu_EvalCoord2f( GLfloat u, GLfloat v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileEvalCoord2f(u, v);
	}
	if (replicate_spu.swap)
	{
		crPackEvalCoord2fSWAP(u, v);
	}
	else
	{
		crPackEvalCoord2f(u, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_EvalCoord2fv( const GLfloat * u )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileEvalCoord2fv(u);
	}
	if (replicate_spu.swap)
	{
		crPackEvalCoord2fvSWAP(u);
	}
	else
	{
		crPackEvalCoord2fv(u);
	}
}

void REPLICATESPU_APIENTRY replicatespu_EvalMesh1( GLenum mode, GLint i1, GLint i2 )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileEvalMesh1(mode, i1, i2);
	}
	if (replicate_spu.swap)
	{
		crPackEvalMesh1SWAP(mode, i1, i2);
	}
	else
	{
		crPackEvalMesh1(mode, i1, i2);
	}
}

void REPLICATESPU_APIENTRY replicatespu_EvalMesh2( GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2 )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileEvalMesh2(mode, i1, i2, j1, j2);
	}
	if (replicate_spu.swap)
	{
		crPackEvalMesh2SWAP(mode, i1, i2, j1, j2);
	}
	else
	{
		crPackEvalMesh2(mode, i1, i2, j1, j2);
	}
}

void REPLICATESPU_APIENTRY replicatespu_EvalPoint1( GLint i )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileEvalPoint1(i);
	}
	if (replicate_spu.swap)
	{
		crPackEvalPoint1SWAP(i);
	}
	else
	{
		crPackEvalPoint1(i);
	}
}

void REPLICATESPU_APIENTRY replicatespu_EvalPoint2( GLint i, GLint j )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileEvalPoint2(i, j);
	}
	if (replicate_spu.swap)
	{
		crPackEvalPoint2SWAP(i, j);
	}
	else
	{
		crPackEvalPoint2(i, j);
	}
}

void REPLICATESPU_APIENTRY replicatespu_ExecuteProgramNV( GLenum target, GLuint id, const GLfloat * params )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileExecuteProgramNV(target, id, params);
	}
	if (replicate_spu.swap)
	{
		crPackExecuteProgramNVSWAP(target, id, params);
	}
	else
	{
		crPackExecuteProgramNV(target, id, params);
	}
}

void REPLICATESPU_APIENTRY replicatespu_FeedbackBuffer( GLsizei size, GLenum type, GLfloat * buffer )
{
	if (replicate_spu.swap)
	{
		crPackFeedbackBufferSWAP(size, type, buffer);
	}
	else
	{
		crPackFeedbackBuffer(size, type, buffer);
	}
	crStateFeedbackBuffer( size, type, buffer );
}

void REPLICATESPU_APIENTRY replicatespu_FinalCombinerInputNV( GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileFinalCombinerInputNV(variable, input, mapping, componentUsage);
	}
	if (replicate_spu.swap)
	{
		crPackFinalCombinerInputNVSWAP(variable, input, mapping, componentUsage);
	}
	else
	{
		crPackFinalCombinerInputNV(variable, input, mapping, componentUsage);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateFinalCombinerInputNV( variable, input, mapping, componentUsage );
	}
}

/* Finish not generated: special implementation exists */
/* FinishFenceNV not generated: crPack implementation suffices */
/* Flush not generated: special implementation exists */

void REPLICATESPU_APIENTRY replicatespu_FlushVertexArrayRangeNV( void )
{
	crStateFlushVertexArrayRangeNV(  );
}

void REPLICATESPU_APIENTRY replicatespu_FogCoordPointerEXT( GLenum type, GLsizei stride, const GLvoid * pointer )
{
	crStateFogCoordPointerEXT( type, stride, pointer );
}

void REPLICATESPU_APIENTRY replicatespu_FogCoorddEXT( GLdouble coord )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileFogCoorddEXT(coord);
	}
	if (replicate_spu.swap)
	{
		crPackFogCoorddEXTSWAP(coord);
	}
	else
	{
		crPackFogCoorddEXT(coord);
	}
}

void REPLICATESPU_APIENTRY replicatespu_FogCoorddvEXT( const GLdouble * coord )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileFogCoorddvEXT(coord);
	}
	if (replicate_spu.swap)
	{
		crPackFogCoorddvEXTSWAP(coord);
	}
	else
	{
		crPackFogCoorddvEXT(coord);
	}
}

void REPLICATESPU_APIENTRY replicatespu_FogCoordfEXT( GLfloat coord )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileFogCoordfEXT(coord);
	}
	if (replicate_spu.swap)
	{
		crPackFogCoordfEXTSWAP(coord);
	}
	else
	{
		crPackFogCoordfEXT(coord);
	}
}

void REPLICATESPU_APIENTRY replicatespu_FogCoordfvEXT( const GLfloat * coord )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileFogCoordfvEXT(coord);
	}
	if (replicate_spu.swap)
	{
		crPackFogCoordfvEXTSWAP(coord);
	}
	else
	{
		crPackFogCoordfvEXT(coord);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Fogf( GLenum pname, GLfloat param )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileFogf(pname, param);
	}
	if (replicate_spu.swap)
	{
		crPackFogfSWAP(pname, param);
	}
	else
	{
		crPackFogf(pname, param);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateFogf( pname, param );
	}
}

void REPLICATESPU_APIENTRY replicatespu_Fogfv( GLenum pname, const GLfloat * params )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileFogfv(pname, params);
	}
	if (replicate_spu.swap)
	{
		crPackFogfvSWAP(pname, params);
	}
	else
	{
		crPackFogfv(pname, params);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateFogfv( pname, params );
	}
}

void REPLICATESPU_APIENTRY replicatespu_Fogi( GLenum pname, GLint param )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileFogi(pname, param);
	}
	if (replicate_spu.swap)
	{
		crPackFogiSWAP(pname, param);
	}
	else
	{
		crPackFogi(pname, param);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateFogi( pname, param );
	}
}

void REPLICATESPU_APIENTRY replicatespu_Fogiv( GLenum pname, const GLint * params )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileFogiv(pname, params);
	}
	if (replicate_spu.swap)
	{
		crPackFogivSWAP(pname, params);
	}
	else
	{
		crPackFogiv(pname, params);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateFogiv( pname, params );
	}
}

void REPLICATESPU_APIENTRY replicatespu_FrontFace( GLenum mode )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileFrontFace(mode);
	}
	if (replicate_spu.swap)
	{
		crPackFrontFaceSWAP(mode);
	}
	else
	{
		crPackFrontFace(mode);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateFrontFace( mode );
	}
}

void REPLICATESPU_APIENTRY replicatespu_Frustum( GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileFrustum(left, right, bottom, top, zNear, zFar);
	}
	if (replicate_spu.swap)
	{
		crPackFrustumSWAP(left, right, bottom, top, zNear, zFar);
	}
	else
	{
		crPackFrustum(left, right, bottom, top, zNear, zFar);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateFrustum( left, right, bottom, top, zNear, zFar );
	}
}

void REPLICATESPU_APIENTRY replicatespu_GenBuffersARB( GLsizei n, GLuint * buffer )
{
	GET_THREAD(thread);
	int writeback = 1;
	replicatespuFlushAll( (void *) thread );
	if (replicate_spu.swap)
	{
		crPackGenBuffersARBSWAP(n, buffer, &writeback);
	}
	else
	{
		crPackGenBuffersARB(n, buffer, &writeback);
	}
	replicatespuFlushOne(thread, 0);
	while (writeback)
		crNetRecv();
}

void REPLICATESPU_APIENTRY replicatespu_GenFencesNV( GLsizei n, GLuint * fences )
{
	GET_THREAD(thread);
	int writeback = 1;
	replicatespuFlushAll( (void *) thread );
	if (replicate_spu.swap)
	{
		crPackGenFencesNVSWAP(n, fences, &writeback);
	}
	else
	{
		crPackGenFencesNV(n, fences, &writeback);
	}
	replicatespuFlushOne(thread, 0);
	while (writeback)
		crNetRecv();
}

/* GenLists not generated: special implementation exists */

void REPLICATESPU_APIENTRY replicatespu_GenProgramsARB( GLsizei n, GLuint * programs )
{
	GET_THREAD(thread);
	int writeback = 1;
	replicatespuFlushAll( (void *) thread );
	if (replicate_spu.swap)
	{
		crPackGenProgramsARBSWAP(n, programs, &writeback);
	}
	else
	{
		crPackGenProgramsARB(n, programs, &writeback);
	}
	replicatespuFlushOne(thread, 0);
	while (writeback)
		crNetRecv();
}

void REPLICATESPU_APIENTRY replicatespu_GenProgramsNV( GLsizei n, GLuint * ids )
{
	GET_THREAD(thread);
	int writeback = 1;
	replicatespuFlushAll( (void *) thread );
	if (replicate_spu.swap)
	{
		crPackGenProgramsNVSWAP(n, ids, &writeback);
	}
	else
	{
		crPackGenProgramsNV(n, ids, &writeback);
	}
	replicatespuFlushOne(thread, 0);
	while (writeback)
		crNetRecv();
}

void REPLICATESPU_APIENTRY replicatespu_GenQueriesARB( GLsizei n, GLuint * ids )
{
	GET_THREAD(thread);
	int writeback = 1;
	replicatespuFlushAll( (void *) thread );
	if (replicate_spu.swap)
	{
		crPackGenQueriesARBSWAP(n, ids, &writeback);
	}
	else
	{
		crPackGenQueriesARB(n, ids, &writeback);
	}
	replicatespuFlushOne(thread, 0);
	while (writeback)
		crNetRecv();
}

/* GenTextures not generated: special implementation exists */

void REPLICATESPU_APIENTRY replicatespu_GetBooleanv( GLenum pname, GLboolean * params )
{
	crStateGetBooleanv( pname, params );
}

/* GetBufferParameterivARB not generated: special implementation exists */
/* GetBufferPointervARB not generated: special implementation exists */

void REPLICATESPU_APIENTRY replicatespu_GetBufferSubDataARB( GLenum target, GLintptrARB offset, GLsizeiptrARB size, void * data )
{
	crStateGetBufferSubDataARB( target, offset, size, data );
}

void REPLICATESPU_APIENTRY replicatespu_GetChromiumParametervCR( GLenum target, GLuint index, GLenum type, GLsizei count, GLvoid * values )
{
	crStateGetChromiumParametervCR( target, index, type, count, values );
}

void REPLICATESPU_APIENTRY replicatespu_GetClipPlane( GLenum plane, GLdouble * equation )
{
	crStateGetClipPlane( plane, equation );
}

void REPLICATESPU_APIENTRY replicatespu_GetCombinerInputParameterfvNV( GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat * params )
{
	crStateGetCombinerInputParameterfvNV( stage, portion, variable, pname, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetCombinerInputParameterivNV( GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint * params )
{
	crStateGetCombinerInputParameterivNV( stage, portion, variable, pname, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetCombinerOutputParameterfvNV( GLenum stage, GLenum portion, GLenum pname, GLfloat * params )
{
	crStateGetCombinerOutputParameterfvNV( stage, portion, pname, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetCombinerOutputParameterivNV( GLenum stage, GLenum portion, GLenum pname, GLint * params )
{
	crStateGetCombinerOutputParameterivNV( stage, portion, pname, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetCombinerStageParameterfvNV( GLenum stage, GLenum pname, GLfloat * params )
{
	crStateGetCombinerStageParameterfvNV( stage, pname, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetCompressedTexImageARB( GLenum target, GLint level, GLvoid * img )
{
	GET_THREAD(thread);
	int writeback = 1;
	replicatespuFlushAll( (void *) thread );
	if (replicate_spu.swap)
	{
		crPackGetCompressedTexImageARBSWAP(target, level, img, &writeback);
	}
	else
	{
		crPackGetCompressedTexImageARB(target, level, img, &writeback);
	}
	replicatespuFlushOne(thread, 0);
	while (writeback)
		crNetRecv();
}

void REPLICATESPU_APIENTRY replicatespu_GetDoublev( GLenum pname, GLdouble * params )
{
	crStateGetDoublev( pname, params );
}

GLenum REPLICATESPU_APIENTRY replicatespu_GetError( void )
{
	return crStateGetError(  );
}

void REPLICATESPU_APIENTRY replicatespu_GetFenceivNV( GLuint fence, GLenum pname, GLint * params )
{
	GET_THREAD(thread);
	int writeback = 1;
	replicatespuFlushAll( (void *) thread );
	if (replicate_spu.swap)
	{
		crPackGetFenceivNVSWAP(fence, pname, params, &writeback);
	}
	else
	{
		crPackGetFenceivNV(fence, pname, params, &writeback);
	}
	replicatespuFlushOne(thread, 0);
	while (writeback)
		crNetRecv();
}

void REPLICATESPU_APIENTRY replicatespu_GetFinalCombinerInputParameterfvNV( GLenum variable, GLenum pname, GLfloat * params )
{
	crStateGetFinalCombinerInputParameterfvNV( variable, pname, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetFinalCombinerInputParameterivNV( GLenum variable, GLenum pname, GLint * params )
{
	crStateGetFinalCombinerInputParameterivNV( variable, pname, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetFloatv( GLenum pname, GLfloat * params )
{
	crStateGetFloatv( pname, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetIntegerv( GLenum pname, GLint * params )
{
	crStateGetIntegerv( pname, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetLightfv( GLenum light, GLenum pname, GLfloat * params )
{
	crStateGetLightfv( light, pname, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetLightiv( GLenum light, GLenum pname, GLint * params )
{
	crStateGetLightiv( light, pname, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetMapdv( GLenum target, GLenum query, GLdouble * v )
{
	crStateGetMapdv( target, query, v );
}

void REPLICATESPU_APIENTRY replicatespu_GetMapfv( GLenum target, GLenum query, GLfloat * v )
{
	crStateGetMapfv( target, query, v );
}

void REPLICATESPU_APIENTRY replicatespu_GetMapiv( GLenum target, GLenum query, GLint * v )
{
	crStateGetMapiv( target, query, v );
}

void REPLICATESPU_APIENTRY replicatespu_GetMaterialfv( GLenum face, GLenum pname, GLfloat * params )
{
	crStateGetMaterialfv( face, pname, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetMaterialiv( GLenum face, GLenum pname, GLint * params )
{
	crStateGetMaterialiv( face, pname, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetPixelMapfv( GLenum map, GLfloat * values )
{
	crStateGetPixelMapfv( map, values );
}

void REPLICATESPU_APIENTRY replicatespu_GetPixelMapuiv( GLenum map, GLuint * values )
{
	crStateGetPixelMapuiv( map, values );
}

void REPLICATESPU_APIENTRY replicatespu_GetPixelMapusv( GLenum map, GLushort * values )
{
	crStateGetPixelMapusv( map, values );
}

void REPLICATESPU_APIENTRY replicatespu_GetPointerv( GLenum pname, GLvoid ** params )
{
	crStateGetPointerv( pname, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetPolygonStipple( GLubyte * mask )
{
	crStateGetPolygonStipple( mask );
}

void REPLICATESPU_APIENTRY replicatespu_GetProgramEnvParameterdvARB( GLenum target, GLuint index, GLdouble * params )
{
	crStateGetProgramEnvParameterdvARB( target, index, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetProgramEnvParameterfvARB( GLenum target, GLuint index, GLfloat * params )
{
	crStateGetProgramEnvParameterfvARB( target, index, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetProgramLocalParameterdvARB( GLenum target, GLuint index, GLdouble * params )
{
	crStateGetProgramLocalParameterdvARB( target, index, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetProgramLocalParameterfvARB( GLenum target, GLuint index, GLfloat * params )
{
	crStateGetProgramLocalParameterfvARB( target, index, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetProgramNamedParameterdvNV( GLuint id, GLsizei len, const GLubyte * name, GLdouble * params )
{
	crStateGetProgramNamedParameterdvNV( id, len, name, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetProgramNamedParameterfvNV( GLuint id, GLsizei len, const GLubyte * name, GLfloat * params )
{
	crStateGetProgramNamedParameterfvNV( id, len, name, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetProgramParameterdvNV( GLenum target, GLuint index, GLenum pname, GLdouble * params )
{
	crStateGetProgramParameterdvNV( target, index, pname, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetProgramParameterfvNV( GLenum target, GLuint index, GLenum pname, GLfloat * params )
{
	crStateGetProgramParameterfvNV( target, index, pname, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetProgramStringARB( GLenum target, GLenum pname, GLvoid * string )
{
	crStateGetProgramStringARB( target, pname, string );
}

void REPLICATESPU_APIENTRY replicatespu_GetProgramStringNV( GLuint id, GLenum pname, GLubyte * program )
{
	crStateGetProgramStringNV( id, pname, program );
}

void REPLICATESPU_APIENTRY replicatespu_GetProgramivARB( GLenum target, GLenum pname, GLint * params )
{
	GET_THREAD(thread);
	int writeback = 1;
	replicatespuFlushAll( (void *) thread );
	if (replicate_spu.swap)
	{
		crPackGetProgramivARBSWAP(target, pname, params, &writeback);
	}
	else
	{
		crPackGetProgramivARB(target, pname, params, &writeback);
	}
	replicatespuFlushOne(thread, 0);
	while (writeback)
		crNetRecv();
}

void REPLICATESPU_APIENTRY replicatespu_GetProgramivNV( GLuint id, GLenum pname, GLint * params )
{
	GET_THREAD(thread);
	int writeback = 1;
	replicatespuFlushAll( (void *) thread );
	if (replicate_spu.swap)
	{
		crPackGetProgramivNVSWAP(id, pname, params, &writeback);
	}
	else
	{
		crPackGetProgramivNV(id, pname, params, &writeback);
	}
	replicatespuFlushOne(thread, 0);
	while (writeback)
		crNetRecv();
}

void REPLICATESPU_APIENTRY replicatespu_GetQueryObjectivARB( GLuint id, GLenum pname, GLint * params )
{
	GET_THREAD(thread);
	int writeback = 1;
	replicatespuFlushAll( (void *) thread );
	if (replicate_spu.swap)
	{
		crPackGetQueryObjectivARBSWAP(id, pname, params, &writeback);
	}
	else
	{
		crPackGetQueryObjectivARB(id, pname, params, &writeback);
	}
	replicatespuFlushOne(thread, 0);
	while (writeback)
		crNetRecv();
}

void REPLICATESPU_APIENTRY replicatespu_GetQueryObjectuivARB( GLuint id, GLenum pname, GLuint * params )
{
	GET_THREAD(thread);
	int writeback = 1;
	replicatespuFlushAll( (void *) thread );
	if (replicate_spu.swap)
	{
		crPackGetQueryObjectuivARBSWAP(id, pname, params, &writeback);
	}
	else
	{
		crPackGetQueryObjectuivARB(id, pname, params, &writeback);
	}
	replicatespuFlushOne(thread, 0);
	while (writeback)
		crNetRecv();
}

void REPLICATESPU_APIENTRY replicatespu_GetQueryivARB( GLenum target, GLenum pname, GLint * params )
{
	crStateGetQueryivARB( target, pname, params );
}

/* GetString not generated: special implementation exists */

void REPLICATESPU_APIENTRY replicatespu_GetTexEnvfv( GLenum target, GLenum pname, GLfloat * params )
{
	crStateGetTexEnvfv( target, pname, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetTexEnviv( GLenum target, GLenum pname, GLint * params )
{
	crStateGetTexEnviv( target, pname, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetTexGendv( GLenum coord, GLenum pname, GLdouble * params )
{
	crStateGetTexGendv( coord, pname, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetTexGenfv( GLenum coord, GLenum pname, GLfloat * params )
{
	crStateGetTexGenfv( coord, pname, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetTexGeniv( GLenum coord, GLenum pname, GLint * params )
{
	crStateGetTexGeniv( coord, pname, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetTexImage( GLenum target, GLint level, GLenum format, GLenum type, GLvoid * pixels )
{
	crStateGetTexImage( target, level, format, type, pixels );
}

void REPLICATESPU_APIENTRY replicatespu_GetTexLevelParameterfv( GLenum target, GLint level, GLenum pname, GLfloat * params )
{
	crStateGetTexLevelParameterfv( target, level, pname, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetTexLevelParameteriv( GLenum target, GLint level, GLenum pname, GLint * params )
{
	crStateGetTexLevelParameteriv( target, level, pname, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetTexParameterfv( GLenum target, GLenum pname, GLfloat * params )
{
	crStateGetTexParameterfv( target, pname, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetTexParameteriv( GLenum target, GLenum pname, GLint * params )
{
	crStateGetTexParameteriv( target, pname, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetTrackMatrixivNV( GLenum target, GLuint address, GLenum pname, GLint * params )
{
	crStateGetTrackMatrixivNV( target, address, pname, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetVertexAttribPointervARB( GLuint index, GLenum pname, GLvoid ** pointer )
{
	crStateGetVertexAttribPointervARB( index, pname, pointer );
}

void REPLICATESPU_APIENTRY replicatespu_GetVertexAttribPointervNV( GLuint index, GLenum pname, GLvoid ** pointer )
{
	crStateGetVertexAttribPointervNV( index, pname, pointer );
}

void REPLICATESPU_APIENTRY replicatespu_GetVertexAttribdvARB( GLuint index, GLenum pname, GLdouble * params )
{
	crStateGetVertexAttribdvARB( index, pname, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetVertexAttribdvNV( GLuint index, GLenum pname, GLdouble * params )
{
	crStateGetVertexAttribdvNV( index, pname, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetVertexAttribfvARB( GLuint index, GLenum pname, GLfloat * params )
{
	crStateGetVertexAttribfvARB( index, pname, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetVertexAttribfvNV( GLuint index, GLenum pname, GLfloat * params )
{
	crStateGetVertexAttribfvNV( index, pname, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetVertexAttribivARB( GLuint index, GLenum pname, GLint * params )
{
	crStateGetVertexAttribivARB( index, pname, params );
}

void REPLICATESPU_APIENTRY replicatespu_GetVertexAttribivNV( GLuint index, GLenum pname, GLint * params )
{
	crStateGetVertexAttribivNV( index, pname, params );
}

void REPLICATESPU_APIENTRY replicatespu_Hint( GLenum target, GLenum mode )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileHint(target, mode);
	}
	if (replicate_spu.swap)
	{
		crPackHintSWAP(target, mode);
	}
	else
	{
		crPackHint(target, mode);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateHint( target, mode );
	}
}

void REPLICATESPU_APIENTRY replicatespu_IndexMask( GLuint mask )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileIndexMask(mask);
	}
	if (replicate_spu.swap)
	{
		crPackIndexMaskSWAP(mask);
	}
	else
	{
		crPackIndexMask(mask);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateIndexMask( mask );
	}
}

void REPLICATESPU_APIENTRY replicatespu_IndexPointer( GLenum type, GLsizei stride, const GLvoid * pointer )
{
	crStateIndexPointer( type, stride, pointer );
}

void REPLICATESPU_APIENTRY replicatespu_Indexd( GLdouble c )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileIndexd(c);
	}
	if (replicate_spu.swap)
	{
		crPackIndexdSWAP(c);
	}
	else
	{
		crPackIndexd(c);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Indexdv( const GLdouble * c )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileIndexdv(c);
	}
	if (replicate_spu.swap)
	{
		crPackIndexdvSWAP(c);
	}
	else
	{
		crPackIndexdv(c);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Indexf( GLfloat c )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileIndexf(c);
	}
	if (replicate_spu.swap)
	{
		crPackIndexfSWAP(c);
	}
	else
	{
		crPackIndexf(c);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Indexfv( const GLfloat * c )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileIndexfv(c);
	}
	if (replicate_spu.swap)
	{
		crPackIndexfvSWAP(c);
	}
	else
	{
		crPackIndexfv(c);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Indexi( GLint c )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileIndexi(c);
	}
	if (replicate_spu.swap)
	{
		crPackIndexiSWAP(c);
	}
	else
	{
		crPackIndexi(c);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Indexiv( const GLint * c )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileIndexiv(c);
	}
	if (replicate_spu.swap)
	{
		crPackIndexivSWAP(c);
	}
	else
	{
		crPackIndexiv(c);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Indexs( GLshort c )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileIndexs(c);
	}
	if (replicate_spu.swap)
	{
		crPackIndexsSWAP(c);
	}
	else
	{
		crPackIndexs(c);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Indexsv( const GLshort * c )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileIndexsv(c);
	}
	if (replicate_spu.swap)
	{
		crPackIndexsvSWAP(c);
	}
	else
	{
		crPackIndexsv(c);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Indexub( GLubyte c )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileIndexub(c);
	}
	if (replicate_spu.swap)
	{
		crPackIndexubSWAP(c);
	}
	else
	{
		crPackIndexub(c);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Indexubv( const GLubyte * c )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileIndexubv(c);
	}
	if (replicate_spu.swap)
	{
		crPackIndexubvSWAP(c);
	}
	else
	{
		crPackIndexubv(c);
	}
}

void REPLICATESPU_APIENTRY replicatespu_InitNames( void )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileInitNames();
	}
	if (replicate_spu.swap)
	{
		crPackInitNamesSWAP();
	}
	else
	{
		crPackInitNames();
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateInitNames(  );
	}
}

void REPLICATESPU_APIENTRY replicatespu_InterleavedArrays( GLenum format, GLsizei stride, const GLvoid * pointer )
{
	crStateInterleavedArrays( format, stride, pointer );
}

GLboolean REPLICATESPU_APIENTRY replicatespu_IsBufferARB( GLuint buffer )
{
	return crStateIsBufferARB( buffer );
}

GLboolean REPLICATESPU_APIENTRY replicatespu_IsEnabled( GLenum cap )
{
	return crStateIsEnabled( cap );
}

GLboolean REPLICATESPU_APIENTRY replicatespu_IsFenceNV( GLuint fence )
{
	GET_THREAD(thread);
	int writeback = 1;
	GLboolean return_val = (GLboolean) 0;
	replicatespuFlushAll( (void *) thread );
	if (replicate_spu.swap)
	{
		crPackIsFenceNVSWAP(fence, &return_val, &writeback);
	}
	else
	{
		crPackIsFenceNV(fence, &return_val, &writeback);
	}
	replicatespuFlushOne(thread, 0);
	while (writeback)
		crNetRecv();
	if (replicate_spu.swap)
	{
		return_val = (GLboolean) SWAP32(return_val);
	}
	return return_val;
}

GLboolean REPLICATESPU_APIENTRY replicatespu_IsList( GLuint list )
{
	return crStateIsList( list );
}

GLboolean REPLICATESPU_APIENTRY replicatespu_IsProgramARB( GLuint program )
{
	return crStateIsProgramARB( program );
}

GLboolean REPLICATESPU_APIENTRY replicatespu_IsQueryARB( GLuint id )
{
	return crStateIsQueryARB( id );
}

GLboolean REPLICATESPU_APIENTRY replicatespu_IsTexture( GLuint texture )
{
	return crStateIsTexture( texture );
}

void REPLICATESPU_APIENTRY replicatespu_LightModelf( GLenum pname, GLfloat param )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileLightModelf(pname, param);
	}
	if (replicate_spu.swap)
	{
		crPackLightModelfSWAP(pname, param);
	}
	else
	{
		crPackLightModelf(pname, param);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateLightModelf( pname, param );
	}
}

void REPLICATESPU_APIENTRY replicatespu_LightModelfv( GLenum pname, const GLfloat * params )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileLightModelfv(pname, params);
	}
	if (replicate_spu.swap)
	{
		crPackLightModelfvSWAP(pname, params);
	}
	else
	{
		crPackLightModelfv(pname, params);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateLightModelfv( pname, params );
	}
}

void REPLICATESPU_APIENTRY replicatespu_LightModeli( GLenum pname, GLint param )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileLightModeli(pname, param);
	}
	if (replicate_spu.swap)
	{
		crPackLightModeliSWAP(pname, param);
	}
	else
	{
		crPackLightModeli(pname, param);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateLightModeli( pname, param );
	}
}

void REPLICATESPU_APIENTRY replicatespu_LightModeliv( GLenum pname, const GLint * params )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileLightModeliv(pname, params);
	}
	if (replicate_spu.swap)
	{
		crPackLightModelivSWAP(pname, params);
	}
	else
	{
		crPackLightModeliv(pname, params);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateLightModeliv( pname, params );
	}
}

void REPLICATESPU_APIENTRY replicatespu_Lightf( GLenum light, GLenum pname, GLfloat param )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileLightf(light, pname, param);
	}
	if (replicate_spu.swap)
	{
		crPackLightfSWAP(light, pname, param);
	}
	else
	{
		crPackLightf(light, pname, param);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateLightf( light, pname, param );
	}
}

void REPLICATESPU_APIENTRY replicatespu_Lightfv( GLenum light, GLenum pname, const GLfloat * params )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileLightfv(light, pname, params);
	}
	if (replicate_spu.swap)
	{
		crPackLightfvSWAP(light, pname, params);
	}
	else
	{
		crPackLightfv(light, pname, params);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateLightfv( light, pname, params );
	}
}

void REPLICATESPU_APIENTRY replicatespu_Lighti( GLenum light, GLenum pname, GLint param )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileLighti(light, pname, param);
	}
	if (replicate_spu.swap)
	{
		crPackLightiSWAP(light, pname, param);
	}
	else
	{
		crPackLighti(light, pname, param);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateLighti( light, pname, param );
	}
}

void REPLICATESPU_APIENTRY replicatespu_Lightiv( GLenum light, GLenum pname, const GLint * params )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileLightiv(light, pname, params);
	}
	if (replicate_spu.swap)
	{
		crPackLightivSWAP(light, pname, params);
	}
	else
	{
		crPackLightiv(light, pname, params);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateLightiv( light, pname, params );
	}
}

void REPLICATESPU_APIENTRY replicatespu_LineStipple( GLint factor, GLushort pattern )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileLineStipple(factor, pattern);
	}
	if (replicate_spu.swap)
	{
		crPackLineStippleSWAP(factor, pattern);
	}
	else
	{
		crPackLineStipple(factor, pattern);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateLineStipple( factor, pattern );
	}
}

void REPLICATESPU_APIENTRY replicatespu_LineWidth( GLfloat width )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileLineWidth(width);
	}
	if (replicate_spu.swap)
	{
		crPackLineWidthSWAP(width);
	}
	else
	{
		crPackLineWidth(width);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateLineWidth( width );
	}
}

/* ListBase not generated: special implementation exists */

void REPLICATESPU_APIENTRY replicatespu_LoadIdentity( void )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileLoadIdentity();
	}
	if (replicate_spu.swap)
	{
		crPackLoadIdentitySWAP();
	}
	else
	{
		crPackLoadIdentity();
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateLoadIdentity(  );
	}
}

void REPLICATESPU_APIENTRY replicatespu_LoadMatrixd( const GLdouble * m )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileLoadMatrixd(m);
	}
	if (replicate_spu.swap)
	{
		crPackLoadMatrixdSWAP(m);
	}
	else
	{
		crPackLoadMatrixd(m);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateLoadMatrixd( m );
	}
}

void REPLICATESPU_APIENTRY replicatespu_LoadMatrixf( const GLfloat * m )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileLoadMatrixf(m);
	}
	if (replicate_spu.swap)
	{
		crPackLoadMatrixfSWAP(m);
	}
	else
	{
		crPackLoadMatrixf(m);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateLoadMatrixf( m );
	}
}

void REPLICATESPU_APIENTRY replicatespu_LoadName( GLuint name )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileLoadName(name);
	}
	if (replicate_spu.swap)
	{
		crPackLoadNameSWAP(name);
	}
	else
	{
		crPackLoadName(name);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateLoadName( name );
	}
}

void REPLICATESPU_APIENTRY replicatespu_LoadProgramNV( GLenum target, GLuint id, GLsizei len, const GLubyte * program )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileLoadProgramNV(target, id, len, program);
	}
	if (replicate_spu.swap)
	{
		crPackLoadProgramNVSWAP(target, id, len, program);
	}
	else
	{
		crPackLoadProgramNV(target, id, len, program);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateLoadProgramNV( target, id, len, program );
	}
}

void REPLICATESPU_APIENTRY replicatespu_LoadTransposeMatrixdARB( const GLdouble * m )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileLoadTransposeMatrixdARB(m);
	}
	if (replicate_spu.swap)
	{
		crPackLoadTransposeMatrixdARBSWAP(m);
	}
	else
	{
		crPackLoadTransposeMatrixdARB(m);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateLoadTransposeMatrixdARB( m );
	}
}

void REPLICATESPU_APIENTRY replicatespu_LoadTransposeMatrixfARB( const GLfloat * m )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileLoadTransposeMatrixfARB(m);
	}
	if (replicate_spu.swap)
	{
		crPackLoadTransposeMatrixfARBSWAP(m);
	}
	else
	{
		crPackLoadTransposeMatrixfARB(m);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateLoadTransposeMatrixfARB( m );
	}
}

void REPLICATESPU_APIENTRY replicatespu_LogicOp( GLenum opcode )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileLogicOp(opcode);
	}
	if (replicate_spu.swap)
	{
		crPackLogicOpSWAP(opcode);
	}
	else
	{
		crPackLogicOp(opcode);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateLogicOp( opcode );
	}
}

/* MakeCurrent not generated: special implementation exists */

void REPLICATESPU_APIENTRY replicatespu_Map1d( GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble * points )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMap1d(target, u1, u2, stride, order, points);
	}
	if (replicate_spu.swap)
	{
		crPackMap1dSWAP(target, u1, u2, stride, order, points);
	}
	else
	{
		crPackMap1d(target, u1, u2, stride, order, points);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateMap1d( target, u1, u2, stride, order, points );
	}
}

void REPLICATESPU_APIENTRY replicatespu_Map1f( GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat * points )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMap1f(target, u1, u2, stride, order, points);
	}
	if (replicate_spu.swap)
	{
		crPackMap1fSWAP(target, u1, u2, stride, order, points);
	}
	else
	{
		crPackMap1f(target, u1, u2, stride, order, points);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateMap1f( target, u1, u2, stride, order, points );
	}
}

void REPLICATESPU_APIENTRY replicatespu_Map2d( GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble * points )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMap2d(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
	}
	if (replicate_spu.swap)
	{
		crPackMap2dSWAP(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
	}
	else
	{
		crPackMap2d(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateMap2d( target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points );
	}
}

void REPLICATESPU_APIENTRY replicatespu_Map2f( GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat * points )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMap2f(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
	}
	if (replicate_spu.swap)
	{
		crPackMap2fSWAP(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
	}
	else
	{
		crPackMap2f(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateMap2f( target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points );
	}
}

/* MapBufferARB not generated: special implementation exists */

void REPLICATESPU_APIENTRY replicatespu_MapGrid1d( GLint un, GLdouble u1, GLdouble u2 )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMapGrid1d(un, u1, u2);
	}
	if (replicate_spu.swap)
	{
		crPackMapGrid1dSWAP(un, u1, u2);
	}
	else
	{
		crPackMapGrid1d(un, u1, u2);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateMapGrid1d( un, u1, u2 );
	}
}

void REPLICATESPU_APIENTRY replicatespu_MapGrid1f( GLint un, GLfloat u1, GLfloat u2 )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMapGrid1f(un, u1, u2);
	}
	if (replicate_spu.swap)
	{
		crPackMapGrid1fSWAP(un, u1, u2);
	}
	else
	{
		crPackMapGrid1f(un, u1, u2);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateMapGrid1f( un, u1, u2 );
	}
}

void REPLICATESPU_APIENTRY replicatespu_MapGrid2d( GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2 )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMapGrid2d(un, u1, u2, vn, v1, v2);
	}
	if (replicate_spu.swap)
	{
		crPackMapGrid2dSWAP(un, u1, u2, vn, v1, v2);
	}
	else
	{
		crPackMapGrid2d(un, u1, u2, vn, v1, v2);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateMapGrid2d( un, u1, u2, vn, v1, v2 );
	}
}

void REPLICATESPU_APIENTRY replicatespu_MapGrid2f( GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2 )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMapGrid2f(un, u1, u2, vn, v1, v2);
	}
	if (replicate_spu.swap)
	{
		crPackMapGrid2fSWAP(un, u1, u2, vn, v1, v2);
	}
	else
	{
		crPackMapGrid2f(un, u1, u2, vn, v1, v2);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateMapGrid2f( un, u1, u2, vn, v1, v2 );
	}
}

void REPLICATESPU_APIENTRY replicatespu_Materialf( GLenum face, GLenum pname, GLfloat param )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMaterialf(face, pname, param);
	}
	if (replicate_spu.swap)
	{
		crPackMaterialfSWAP(face, pname, param);
	}
	else
	{
		crPackMaterialf(face, pname, param);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateMaterialf( face, pname, param );
	}
}

void REPLICATESPU_APIENTRY replicatespu_Materialfv( GLenum face, GLenum pname, const GLfloat * params )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMaterialfv(face, pname, params);
	}
	if (replicate_spu.swap)
	{
		crPackMaterialfvSWAP(face, pname, params);
	}
	else
	{
		crPackMaterialfv(face, pname, params);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateMaterialfv( face, pname, params );
	}
}

void REPLICATESPU_APIENTRY replicatespu_Materiali( GLenum face, GLenum pname, GLint param )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMateriali(face, pname, param);
	}
	if (replicate_spu.swap)
	{
		crPackMaterialiSWAP(face, pname, param);
	}
	else
	{
		crPackMateriali(face, pname, param);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateMateriali( face, pname, param );
	}
}

void REPLICATESPU_APIENTRY replicatespu_Materialiv( GLenum face, GLenum pname, const GLint * params )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMaterialiv(face, pname, params);
	}
	if (replicate_spu.swap)
	{
		crPackMaterialivSWAP(face, pname, params);
	}
	else
	{
		crPackMaterialiv(face, pname, params);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateMaterialiv( face, pname, params );
	}
}

void REPLICATESPU_APIENTRY replicatespu_MatrixMode( GLenum mode )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMatrixMode(mode);
	}
	if (replicate_spu.swap)
	{
		crPackMatrixModeSWAP(mode);
	}
	else
	{
		crPackMatrixMode(mode);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateMatrixMode( mode );
	}
}

void REPLICATESPU_APIENTRY replicatespu_MultMatrixd( const GLdouble * m )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultMatrixd(m);
	}
	if (replicate_spu.swap)
	{
		crPackMultMatrixdSWAP(m);
	}
	else
	{
		crPackMultMatrixd(m);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateMultMatrixd( m );
	}
}

void REPLICATESPU_APIENTRY replicatespu_MultMatrixf( const GLfloat * m )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultMatrixf(m);
	}
	if (replicate_spu.swap)
	{
		crPackMultMatrixfSWAP(m);
	}
	else
	{
		crPackMultMatrixf(m);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateMultMatrixf( m );
	}
}

void REPLICATESPU_APIENTRY replicatespu_MultTransposeMatrixdARB( const GLdouble * m )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultTransposeMatrixdARB(m);
	}
	if (replicate_spu.swap)
	{
		crPackMultTransposeMatrixdARBSWAP(m);
	}
	else
	{
		crPackMultTransposeMatrixdARB(m);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateMultTransposeMatrixdARB( m );
	}
}

void REPLICATESPU_APIENTRY replicatespu_MultTransposeMatrixfARB( const GLfloat * m )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultTransposeMatrixfARB(m);
	}
	if (replicate_spu.swap)
	{
		crPackMultTransposeMatrixfARBSWAP(m);
	}
	else
	{
		crPackMultTransposeMatrixfARB(m);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateMultTransposeMatrixfARB( m );
	}
}

/* MultiDrawArraysEXT not generated: special implementation exists */
/* MultiDrawElementsEXT not generated: special implementation exists */

void REPLICATESPU_APIENTRY replicatespu_MultiTexCoord1dARB( GLenum texture, GLdouble s )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultiTexCoord1dARB(texture, s);
	}
	if (replicate_spu.swap)
	{
		crPackMultiTexCoord1dARBSWAP(texture, s);
	}
	else
	{
		crPackMultiTexCoord1dARB(texture, s);
	}
}

void REPLICATESPU_APIENTRY replicatespu_MultiTexCoord1dvARB( GLenum texture, const GLdouble * t )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultiTexCoord1dvARB(texture, t);
	}
	if (replicate_spu.swap)
	{
		crPackMultiTexCoord1dvARBSWAP(texture, t);
	}
	else
	{
		crPackMultiTexCoord1dvARB(texture, t);
	}
}

void REPLICATESPU_APIENTRY replicatespu_MultiTexCoord1fARB( GLenum texture, GLfloat s )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultiTexCoord1fARB(texture, s);
	}
	if (replicate_spu.swap)
	{
		crPackMultiTexCoord1fARBSWAP(texture, s);
	}
	else
	{
		crPackMultiTexCoord1fARB(texture, s);
	}
}

void REPLICATESPU_APIENTRY replicatespu_MultiTexCoord1fvARB( GLenum texture, const GLfloat * t )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultiTexCoord1fvARB(texture, t);
	}
	if (replicate_spu.swap)
	{
		crPackMultiTexCoord1fvARBSWAP(texture, t);
	}
	else
	{
		crPackMultiTexCoord1fvARB(texture, t);
	}
}

void REPLICATESPU_APIENTRY replicatespu_MultiTexCoord1iARB( GLenum texture, GLint s )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultiTexCoord1iARB(texture, s);
	}
	if (replicate_spu.swap)
	{
		crPackMultiTexCoord1iARBSWAP(texture, s);
	}
	else
	{
		crPackMultiTexCoord1iARB(texture, s);
	}
}

void REPLICATESPU_APIENTRY replicatespu_MultiTexCoord1ivARB( GLenum texture, const GLint * t )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultiTexCoord1ivARB(texture, t);
	}
	if (replicate_spu.swap)
	{
		crPackMultiTexCoord1ivARBSWAP(texture, t);
	}
	else
	{
		crPackMultiTexCoord1ivARB(texture, t);
	}
}

void REPLICATESPU_APIENTRY replicatespu_MultiTexCoord1sARB( GLenum texture, GLshort s )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultiTexCoord1sARB(texture, s);
	}
	if (replicate_spu.swap)
	{
		crPackMultiTexCoord1sARBSWAP(texture, s);
	}
	else
	{
		crPackMultiTexCoord1sARB(texture, s);
	}
}

void REPLICATESPU_APIENTRY replicatespu_MultiTexCoord1svARB( GLenum texture, const GLshort * t )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultiTexCoord1svARB(texture, t);
	}
	if (replicate_spu.swap)
	{
		crPackMultiTexCoord1svARBSWAP(texture, t);
	}
	else
	{
		crPackMultiTexCoord1svARB(texture, t);
	}
}

void REPLICATESPU_APIENTRY replicatespu_MultiTexCoord2dARB( GLenum texture, GLdouble s, GLdouble t )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultiTexCoord2dARB(texture, s, t);
	}
	if (replicate_spu.swap)
	{
		crPackMultiTexCoord2dARBSWAP(texture, s, t);
	}
	else
	{
		crPackMultiTexCoord2dARB(texture, s, t);
	}
}

void REPLICATESPU_APIENTRY replicatespu_MultiTexCoord2dvARB( GLenum texture, const GLdouble * t )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultiTexCoord2dvARB(texture, t);
	}
	if (replicate_spu.swap)
	{
		crPackMultiTexCoord2dvARBSWAP(texture, t);
	}
	else
	{
		crPackMultiTexCoord2dvARB(texture, t);
	}
}

void REPLICATESPU_APIENTRY replicatespu_MultiTexCoord2fARB( GLenum texture, GLfloat s, GLfloat t )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultiTexCoord2fARB(texture, s, t);
	}
	if (replicate_spu.swap)
	{
		crPackMultiTexCoord2fARBSWAP(texture, s, t);
	}
	else
	{
		crPackMultiTexCoord2fARB(texture, s, t);
	}
}

void REPLICATESPU_APIENTRY replicatespu_MultiTexCoord2fvARB( GLenum texture, const GLfloat * t )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultiTexCoord2fvARB(texture, t);
	}
	if (replicate_spu.swap)
	{
		crPackMultiTexCoord2fvARBSWAP(texture, t);
	}
	else
	{
		crPackMultiTexCoord2fvARB(texture, t);
	}
}

void REPLICATESPU_APIENTRY replicatespu_MultiTexCoord2iARB( GLenum texture, GLint s, GLint t )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultiTexCoord2iARB(texture, s, t);
	}
	if (replicate_spu.swap)
	{
		crPackMultiTexCoord2iARBSWAP(texture, s, t);
	}
	else
	{
		crPackMultiTexCoord2iARB(texture, s, t);
	}
}

void REPLICATESPU_APIENTRY replicatespu_MultiTexCoord2ivARB( GLenum texture, const GLint * t )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultiTexCoord2ivARB(texture, t);
	}
	if (replicate_spu.swap)
	{
		crPackMultiTexCoord2ivARBSWAP(texture, t);
	}
	else
	{
		crPackMultiTexCoord2ivARB(texture, t);
	}
}

void REPLICATESPU_APIENTRY replicatespu_MultiTexCoord2sARB( GLenum texture, GLshort s, GLshort t )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultiTexCoord2sARB(texture, s, t);
	}
	if (replicate_spu.swap)
	{
		crPackMultiTexCoord2sARBSWAP(texture, s, t);
	}
	else
	{
		crPackMultiTexCoord2sARB(texture, s, t);
	}
}

void REPLICATESPU_APIENTRY replicatespu_MultiTexCoord2svARB( GLenum texture, const GLshort * t )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultiTexCoord2svARB(texture, t);
	}
	if (replicate_spu.swap)
	{
		crPackMultiTexCoord2svARBSWAP(texture, t);
	}
	else
	{
		crPackMultiTexCoord2svARB(texture, t);
	}
}

void REPLICATESPU_APIENTRY replicatespu_MultiTexCoord3dARB( GLenum texture, GLdouble s, GLdouble t, GLdouble r )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultiTexCoord3dARB(texture, s, t, r);
	}
	if (replicate_spu.swap)
	{
		crPackMultiTexCoord3dARBSWAP(texture, s, t, r);
	}
	else
	{
		crPackMultiTexCoord3dARB(texture, s, t, r);
	}
}

void REPLICATESPU_APIENTRY replicatespu_MultiTexCoord3dvARB( GLenum texture, const GLdouble * t )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultiTexCoord3dvARB(texture, t);
	}
	if (replicate_spu.swap)
	{
		crPackMultiTexCoord3dvARBSWAP(texture, t);
	}
	else
	{
		crPackMultiTexCoord3dvARB(texture, t);
	}
}

void REPLICATESPU_APIENTRY replicatespu_MultiTexCoord3fARB( GLenum texture, GLfloat s, GLfloat t, GLfloat r )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultiTexCoord3fARB(texture, s, t, r);
	}
	if (replicate_spu.swap)
	{
		crPackMultiTexCoord3fARBSWAP(texture, s, t, r);
	}
	else
	{
		crPackMultiTexCoord3fARB(texture, s, t, r);
	}
}

void REPLICATESPU_APIENTRY replicatespu_MultiTexCoord3fvARB( GLenum texture, const GLfloat * t )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultiTexCoord3fvARB(texture, t);
	}
	if (replicate_spu.swap)
	{
		crPackMultiTexCoord3fvARBSWAP(texture, t);
	}
	else
	{
		crPackMultiTexCoord3fvARB(texture, t);
	}
}

void REPLICATESPU_APIENTRY replicatespu_MultiTexCoord3iARB( GLenum texture, GLint s, GLint t, GLint r )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultiTexCoord3iARB(texture, s, t, r);
	}
	if (replicate_spu.swap)
	{
		crPackMultiTexCoord3iARBSWAP(texture, s, t, r);
	}
	else
	{
		crPackMultiTexCoord3iARB(texture, s, t, r);
	}
}

void REPLICATESPU_APIENTRY replicatespu_MultiTexCoord3ivARB( GLenum texture, const GLint * t )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultiTexCoord3ivARB(texture, t);
	}
	if (replicate_spu.swap)
	{
		crPackMultiTexCoord3ivARBSWAP(texture, t);
	}
	else
	{
		crPackMultiTexCoord3ivARB(texture, t);
	}
}

void REPLICATESPU_APIENTRY replicatespu_MultiTexCoord3sARB( GLenum texture, GLshort s, GLshort t, GLshort r )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultiTexCoord3sARB(texture, s, t, r);
	}
	if (replicate_spu.swap)
	{
		crPackMultiTexCoord3sARBSWAP(texture, s, t, r);
	}
	else
	{
		crPackMultiTexCoord3sARB(texture, s, t, r);
	}
}

void REPLICATESPU_APIENTRY replicatespu_MultiTexCoord3svARB( GLenum texture, const GLshort * t )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultiTexCoord3svARB(texture, t);
	}
	if (replicate_spu.swap)
	{
		crPackMultiTexCoord3svARBSWAP(texture, t);
	}
	else
	{
		crPackMultiTexCoord3svARB(texture, t);
	}
}

void REPLICATESPU_APIENTRY replicatespu_MultiTexCoord4dARB( GLenum texture, GLdouble s, GLdouble t, GLdouble r, GLdouble q )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultiTexCoord4dARB(texture, s, t, r, q);
	}
	if (replicate_spu.swap)
	{
		crPackMultiTexCoord4dARBSWAP(texture, s, t, r, q);
	}
	else
	{
		crPackMultiTexCoord4dARB(texture, s, t, r, q);
	}
}

void REPLICATESPU_APIENTRY replicatespu_MultiTexCoord4dvARB( GLenum texture, const GLdouble * t )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultiTexCoord4dvARB(texture, t);
	}
	if (replicate_spu.swap)
	{
		crPackMultiTexCoord4dvARBSWAP(texture, t);
	}
	else
	{
		crPackMultiTexCoord4dvARB(texture, t);
	}
}

void REPLICATESPU_APIENTRY replicatespu_MultiTexCoord4fARB( GLenum texture, GLfloat s, GLfloat t, GLfloat r, GLfloat q )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultiTexCoord4fARB(texture, s, t, r, q);
	}
	if (replicate_spu.swap)
	{
		crPackMultiTexCoord4fARBSWAP(texture, s, t, r, q);
	}
	else
	{
		crPackMultiTexCoord4fARB(texture, s, t, r, q);
	}
}

void REPLICATESPU_APIENTRY replicatespu_MultiTexCoord4fvARB( GLenum texture, const GLfloat * t )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultiTexCoord4fvARB(texture, t);
	}
	if (replicate_spu.swap)
	{
		crPackMultiTexCoord4fvARBSWAP(texture, t);
	}
	else
	{
		crPackMultiTexCoord4fvARB(texture, t);
	}
}

void REPLICATESPU_APIENTRY replicatespu_MultiTexCoord4iARB( GLenum texture, GLint s, GLint t, GLint r, GLint q )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultiTexCoord4iARB(texture, s, t, r, q);
	}
	if (replicate_spu.swap)
	{
		crPackMultiTexCoord4iARBSWAP(texture, s, t, r, q);
	}
	else
	{
		crPackMultiTexCoord4iARB(texture, s, t, r, q);
	}
}

void REPLICATESPU_APIENTRY replicatespu_MultiTexCoord4ivARB( GLenum texture, const GLint * t )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultiTexCoord4ivARB(texture, t);
	}
	if (replicate_spu.swap)
	{
		crPackMultiTexCoord4ivARBSWAP(texture, t);
	}
	else
	{
		crPackMultiTexCoord4ivARB(texture, t);
	}
}

void REPLICATESPU_APIENTRY replicatespu_MultiTexCoord4sARB( GLenum texture, GLshort s, GLshort t, GLshort r, GLshort q )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultiTexCoord4sARB(texture, s, t, r, q);
	}
	if (replicate_spu.swap)
	{
		crPackMultiTexCoord4sARBSWAP(texture, s, t, r, q);
	}
	else
	{
		crPackMultiTexCoord4sARB(texture, s, t, r, q);
	}
}

void REPLICATESPU_APIENTRY replicatespu_MultiTexCoord4svARB( GLenum texture, const GLshort * t )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileMultiTexCoord4svARB(texture, t);
	}
	if (replicate_spu.swap)
	{
		crPackMultiTexCoord4svARBSWAP(texture, t);
	}
	else
	{
		crPackMultiTexCoord4svARB(texture, t);
	}
}

/* NewList not generated: special implementation exists */

void REPLICATESPU_APIENTRY replicatespu_Normal3b( GLbyte nx, GLbyte ny, GLbyte nz )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileNormal3b(nx, ny, nz);
	}
	if (replicate_spu.swap)
	{
		crPackNormal3bSWAP(nx, ny, nz);
	}
	else
	{
		crPackNormal3b(nx, ny, nz);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Normal3bv( const GLbyte * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileNormal3bv(v);
	}
	if (replicate_spu.swap)
	{
		crPackNormal3bvSWAP(v);
	}
	else
	{
		crPackNormal3bv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Normal3d( GLdouble nx, GLdouble ny, GLdouble nz )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileNormal3d(nx, ny, nz);
	}
	if (replicate_spu.swap)
	{
		crPackNormal3dSWAP(nx, ny, nz);
	}
	else
	{
		crPackNormal3d(nx, ny, nz);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Normal3dv( const GLdouble * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileNormal3dv(v);
	}
	if (replicate_spu.swap)
	{
		crPackNormal3dvSWAP(v);
	}
	else
	{
		crPackNormal3dv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Normal3f( GLfloat nx, GLfloat ny, GLfloat nz )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileNormal3f(nx, ny, nz);
	}
	if (replicate_spu.swap)
	{
		crPackNormal3fSWAP(nx, ny, nz);
	}
	else
	{
		crPackNormal3f(nx, ny, nz);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Normal3fv( const GLfloat * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileNormal3fv(v);
	}
	if (replicate_spu.swap)
	{
		crPackNormal3fvSWAP(v);
	}
	else
	{
		crPackNormal3fv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Normal3i( GLint nx, GLint ny, GLint nz )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileNormal3i(nx, ny, nz);
	}
	if (replicate_spu.swap)
	{
		crPackNormal3iSWAP(nx, ny, nz);
	}
	else
	{
		crPackNormal3i(nx, ny, nz);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Normal3iv( const GLint * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileNormal3iv(v);
	}
	if (replicate_spu.swap)
	{
		crPackNormal3ivSWAP(v);
	}
	else
	{
		crPackNormal3iv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Normal3s( GLshort nx, GLshort ny, GLshort nz )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileNormal3s(nx, ny, nz);
	}
	if (replicate_spu.swap)
	{
		crPackNormal3sSWAP(nx, ny, nz);
	}
	else
	{
		crPackNormal3s(nx, ny, nz);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Normal3sv( const GLshort * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileNormal3sv(v);
	}
	if (replicate_spu.swap)
	{
		crPackNormal3svSWAP(v);
	}
	else
	{
		crPackNormal3sv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_NormalPointer( GLenum type, GLsizei stride, const GLvoid * pointer )
{
	crStateNormalPointer( type, stride, pointer );
}

void REPLICATESPU_APIENTRY replicatespu_Ortho( GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileOrtho(left, right, bottom, top, zNear, zFar);
	}
	if (replicate_spu.swap)
	{
		crPackOrthoSWAP(left, right, bottom, top, zNear, zFar);
	}
	else
	{
		crPackOrtho(left, right, bottom, top, zNear, zFar);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateOrtho( left, right, bottom, top, zNear, zFar );
	}
}

void REPLICATESPU_APIENTRY replicatespu_PassThrough( GLfloat token )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompilePassThrough(token);
	}
	if (replicate_spu.swap)
	{
		crPackPassThroughSWAP(token);
	}
	else
	{
		crPackPassThrough(token);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStatePassThrough( token );
	}
}

void REPLICATESPU_APIENTRY replicatespu_PixelMapfv( GLenum map, GLsizei mapsize, const GLfloat * values )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompilePixelMapfv(map, mapsize, values);
	}
	if (replicate_spu.swap)
	{
		crPackPixelMapfvSWAP(map, mapsize, values);
	}
	else
	{
		crPackPixelMapfv(map, mapsize, values);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStatePixelMapfv( map, mapsize, values );
	}
}

void REPLICATESPU_APIENTRY replicatespu_PixelMapuiv( GLenum map, GLsizei mapsize, const GLuint * values )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompilePixelMapuiv(map, mapsize, values);
	}
	if (replicate_spu.swap)
	{
		crPackPixelMapuivSWAP(map, mapsize, values);
	}
	else
	{
		crPackPixelMapuiv(map, mapsize, values);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStatePixelMapuiv( map, mapsize, values );
	}
}

void REPLICATESPU_APIENTRY replicatespu_PixelMapusv( GLenum map, GLsizei mapsize, const GLushort * values )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompilePixelMapusv(map, mapsize, values);
	}
	if (replicate_spu.swap)
	{
		crPackPixelMapusvSWAP(map, mapsize, values);
	}
	else
	{
		crPackPixelMapusv(map, mapsize, values);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStatePixelMapusv( map, mapsize, values );
	}
}

void REPLICATESPU_APIENTRY replicatespu_PixelStoref( GLenum pname, GLfloat param )
{
	crStatePixelStoref( pname, param );
}

void REPLICATESPU_APIENTRY replicatespu_PixelStorei( GLenum pname, GLint param )
{
	crStatePixelStorei( pname, param );
}

void REPLICATESPU_APIENTRY replicatespu_PixelTransferf( GLenum pname, GLfloat param )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompilePixelTransferf(pname, param);
	}
	if (replicate_spu.swap)
	{
		crPackPixelTransferfSWAP(pname, param);
	}
	else
	{
		crPackPixelTransferf(pname, param);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStatePixelTransferf( pname, param );
	}
}

void REPLICATESPU_APIENTRY replicatespu_PixelTransferi( GLenum pname, GLint param )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompilePixelTransferi(pname, param);
	}
	if (replicate_spu.swap)
	{
		crPackPixelTransferiSWAP(pname, param);
	}
	else
	{
		crPackPixelTransferi(pname, param);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStatePixelTransferi( pname, param );
	}
}

void REPLICATESPU_APIENTRY replicatespu_PixelZoom( GLfloat xfactor, GLfloat yfactor )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompilePixelZoom(xfactor, yfactor);
	}
	if (replicate_spu.swap)
	{
		crPackPixelZoomSWAP(xfactor, yfactor);
	}
	else
	{
		crPackPixelZoom(xfactor, yfactor);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStatePixelZoom( xfactor, yfactor );
	}
}

void REPLICATESPU_APIENTRY replicatespu_PointParameterfARB( GLenum pname, GLfloat param )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompilePointParameterfARB(pname, param);
	}
	if (replicate_spu.swap)
	{
		crPackPointParameterfARBSWAP(pname, param);
	}
	else
	{
		crPackPointParameterfARB(pname, param);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStatePointParameterfARB( pname, param );
	}
}

void REPLICATESPU_APIENTRY replicatespu_PointParameterfvARB( GLenum pname, const GLfloat * params )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompilePointParameterfvARB(pname, params);
	}
	if (replicate_spu.swap)
	{
		crPackPointParameterfvARBSWAP(pname, params);
	}
	else
	{
		crPackPointParameterfvARB(pname, params);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStatePointParameterfvARB( pname, params );
	}
}

void REPLICATESPU_APIENTRY replicatespu_PointParameteri( GLenum pname, GLint param )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompilePointParameteri(pname, param);
	}
	if (replicate_spu.swap)
	{
		crPackPointParameteriSWAP(pname, param);
	}
	else
	{
		crPackPointParameteri(pname, param);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStatePointParameteri( pname, param );
	}
}

void REPLICATESPU_APIENTRY replicatespu_PointParameteriv( GLenum pname, const GLint * param )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompilePointParameteriv(pname, param);
	}
	if (replicate_spu.swap)
	{
		crPackPointParameterivSWAP(pname, param);
	}
	else
	{
		crPackPointParameteriv(pname, param);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStatePointParameteriv( pname, param );
	}
}

void REPLICATESPU_APIENTRY replicatespu_PointSize( GLfloat size )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompilePointSize(size);
	}
	if (replicate_spu.swap)
	{
		crPackPointSizeSWAP(size);
	}
	else
	{
		crPackPointSize(size);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStatePointSize( size );
	}
}

void REPLICATESPU_APIENTRY replicatespu_PolygonMode( GLenum face, GLenum mode )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompilePolygonMode(face, mode);
	}
	if (replicate_spu.swap)
	{
		crPackPolygonModeSWAP(face, mode);
	}
	else
	{
		crPackPolygonMode(face, mode);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStatePolygonMode( face, mode );
	}
}

void REPLICATESPU_APIENTRY replicatespu_PolygonOffset( GLfloat factor, GLfloat units )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompilePolygonOffset(factor, units);
	}
	if (replicate_spu.swap)
	{
		crPackPolygonOffsetSWAP(factor, units);
	}
	else
	{
		crPackPolygonOffset(factor, units);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStatePolygonOffset( factor, units );
	}
}

void REPLICATESPU_APIENTRY replicatespu_PolygonStipple( const GLubyte * mask )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompilePolygonStipple(mask);
	}
	if (replicate_spu.swap)
	{
		crPackPolygonStippleSWAP(mask);
	}
	else
	{
		crPackPolygonStipple(mask);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStatePolygonStipple( mask );
	}
}

void REPLICATESPU_APIENTRY replicatespu_PopAttrib( void )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompilePopAttrib();
	}
	if (replicate_spu.swap)
	{
		crPackPopAttribSWAP();
	}
	else
	{
		crPackPopAttrib();
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStatePopAttrib(  );
	}
}

void REPLICATESPU_APIENTRY replicatespu_PopClientAttrib( void )
{
	crStatePopClientAttrib(  );
}

void REPLICATESPU_APIENTRY replicatespu_PopMatrix( void )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompilePopMatrix();
	}
	if (replicate_spu.swap)
	{
		crPackPopMatrixSWAP();
	}
	else
	{
		crPackPopMatrix();
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStatePopMatrix(  );
	}
}

void REPLICATESPU_APIENTRY replicatespu_PopName( void )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompilePopName();
	}
	if (replicate_spu.swap)
	{
		crPackPopNameSWAP();
	}
	else
	{
		crPackPopName();
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStatePopName(  );
	}
}

void REPLICATESPU_APIENTRY replicatespu_PrioritizeTextures( GLsizei n, const GLuint * textures, const GLclampf * priorities )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompilePrioritizeTextures(n, textures, priorities);
	}
	if (replicate_spu.swap)
	{
		crPackPrioritizeTexturesSWAP(n, textures, priorities);
	}
	else
	{
		crPackPrioritizeTextures(n, textures, priorities);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStatePrioritizeTextures( n, textures, priorities );
	}
}

void REPLICATESPU_APIENTRY replicatespu_ProgramEnvParameter4dARB( GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileProgramEnvParameter4dARB(target, index, x, y, z, w);
	}
	if (replicate_spu.swap)
	{
		crPackProgramEnvParameter4dARBSWAP(target, index, x, y, z, w);
	}
	else
	{
		crPackProgramEnvParameter4dARB(target, index, x, y, z, w);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateProgramEnvParameter4dARB( target, index, x, y, z, w );
	}
}

void REPLICATESPU_APIENTRY replicatespu_ProgramEnvParameter4dvARB( GLenum target, GLuint index, const GLdouble * params )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileProgramEnvParameter4dvARB(target, index, params);
	}
	if (replicate_spu.swap)
	{
		crPackProgramEnvParameter4dvARBSWAP(target, index, params);
	}
	else
	{
		crPackProgramEnvParameter4dvARB(target, index, params);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateProgramEnvParameter4dvARB( target, index, params );
	}
}

void REPLICATESPU_APIENTRY replicatespu_ProgramEnvParameter4fARB( GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileProgramEnvParameter4fARB(target, index, x, y, z, w);
	}
	if (replicate_spu.swap)
	{
		crPackProgramEnvParameter4fARBSWAP(target, index, x, y, z, w);
	}
	else
	{
		crPackProgramEnvParameter4fARB(target, index, x, y, z, w);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateProgramEnvParameter4fARB( target, index, x, y, z, w );
	}
}

void REPLICATESPU_APIENTRY replicatespu_ProgramEnvParameter4fvARB( GLenum target, GLuint index, const GLfloat * params )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileProgramEnvParameter4fvARB(target, index, params);
	}
	if (replicate_spu.swap)
	{
		crPackProgramEnvParameter4fvARBSWAP(target, index, params);
	}
	else
	{
		crPackProgramEnvParameter4fvARB(target, index, params);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateProgramEnvParameter4fvARB( target, index, params );
	}
}

void REPLICATESPU_APIENTRY replicatespu_ProgramLocalParameter4dARB( GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileProgramLocalParameter4dARB(target, index, x, y, z, w);
	}
	if (replicate_spu.swap)
	{
		crPackProgramLocalParameter4dARBSWAP(target, index, x, y, z, w);
	}
	else
	{
		crPackProgramLocalParameter4dARB(target, index, x, y, z, w);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateProgramLocalParameter4dARB( target, index, x, y, z, w );
	}
}

void REPLICATESPU_APIENTRY replicatespu_ProgramLocalParameter4dvARB( GLenum target, GLuint index, const GLdouble * params )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileProgramLocalParameter4dvARB(target, index, params);
	}
	if (replicate_spu.swap)
	{
		crPackProgramLocalParameter4dvARBSWAP(target, index, params);
	}
	else
	{
		crPackProgramLocalParameter4dvARB(target, index, params);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateProgramLocalParameter4dvARB( target, index, params );
	}
}

void REPLICATESPU_APIENTRY replicatespu_ProgramLocalParameter4fARB( GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileProgramLocalParameter4fARB(target, index, x, y, z, w);
	}
	if (replicate_spu.swap)
	{
		crPackProgramLocalParameter4fARBSWAP(target, index, x, y, z, w);
	}
	else
	{
		crPackProgramLocalParameter4fARB(target, index, x, y, z, w);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateProgramLocalParameter4fARB( target, index, x, y, z, w );
	}
}

void REPLICATESPU_APIENTRY replicatespu_ProgramLocalParameter4fvARB( GLenum target, GLuint index, const GLfloat * params )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileProgramLocalParameter4fvARB(target, index, params);
	}
	if (replicate_spu.swap)
	{
		crPackProgramLocalParameter4fvARBSWAP(target, index, params);
	}
	else
	{
		crPackProgramLocalParameter4fvARB(target, index, params);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateProgramLocalParameter4fvARB( target, index, params );
	}
}

void REPLICATESPU_APIENTRY replicatespu_ProgramNamedParameter4dNV( GLuint id, GLsizei len, const GLubyte * name, GLdouble x, GLdouble y, GLdouble z, GLdouble w )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileProgramNamedParameter4dNV(id, len, name, x, y, z, w);
	}
	if (replicate_spu.swap)
	{
		crPackProgramNamedParameter4dNVSWAP(id, len, name, x, y, z, w);
	}
	else
	{
		crPackProgramNamedParameter4dNV(id, len, name, x, y, z, w);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateProgramNamedParameter4dNV( id, len, name, x, y, z, w );
	}
}

void REPLICATESPU_APIENTRY replicatespu_ProgramNamedParameter4dvNV( GLuint id, GLsizei len, const GLubyte * name, const GLdouble * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileProgramNamedParameter4dvNV(id, len, name, v);
	}
	if (replicate_spu.swap)
	{
		crPackProgramNamedParameter4dvNVSWAP(id, len, name, v);
	}
	else
	{
		crPackProgramNamedParameter4dvNV(id, len, name, v);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateProgramNamedParameter4dvNV( id, len, name, v );
	}
}

void REPLICATESPU_APIENTRY replicatespu_ProgramNamedParameter4fNV( GLuint id, GLsizei len, const GLubyte * name, GLfloat x, GLfloat y, GLfloat z, GLfloat w )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileProgramNamedParameter4fNV(id, len, name, x, y, z, w);
	}
	if (replicate_spu.swap)
	{
		crPackProgramNamedParameter4fNVSWAP(id, len, name, x, y, z, w);
	}
	else
	{
		crPackProgramNamedParameter4fNV(id, len, name, x, y, z, w);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateProgramNamedParameter4fNV( id, len, name, x, y, z, w );
	}
}

void REPLICATESPU_APIENTRY replicatespu_ProgramNamedParameter4fvNV( GLuint id, GLsizei len, const GLubyte * name, const GLfloat * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileProgramNamedParameter4fvNV(id, len, name, v);
	}
	if (replicate_spu.swap)
	{
		crPackProgramNamedParameter4fvNVSWAP(id, len, name, v);
	}
	else
	{
		crPackProgramNamedParameter4fvNV(id, len, name, v);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateProgramNamedParameter4fvNV( id, len, name, v );
	}
}

void REPLICATESPU_APIENTRY replicatespu_ProgramParameter4dNV( GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileProgramParameter4dNV(target, index, x, y, z, w);
	}
	if (replicate_spu.swap)
	{
		crPackProgramParameter4dNVSWAP(target, index, x, y, z, w);
	}
	else
	{
		crPackProgramParameter4dNV(target, index, x, y, z, w);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateProgramParameter4dNV( target, index, x, y, z, w );
	}
}

void REPLICATESPU_APIENTRY replicatespu_ProgramParameter4dvNV( GLenum target, GLuint index, const GLdouble * params )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileProgramParameter4dvNV(target, index, params);
	}
	if (replicate_spu.swap)
	{
		crPackProgramParameter4dvNVSWAP(target, index, params);
	}
	else
	{
		crPackProgramParameter4dvNV(target, index, params);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateProgramParameter4dvNV( target, index, params );
	}
}

void REPLICATESPU_APIENTRY replicatespu_ProgramParameter4fNV( GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileProgramParameter4fNV(target, index, x, y, z, w);
	}
	if (replicate_spu.swap)
	{
		crPackProgramParameter4fNVSWAP(target, index, x, y, z, w);
	}
	else
	{
		crPackProgramParameter4fNV(target, index, x, y, z, w);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateProgramParameter4fNV( target, index, x, y, z, w );
	}
}

void REPLICATESPU_APIENTRY replicatespu_ProgramParameter4fvNV( GLenum target, GLuint index, const GLfloat * params )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileProgramParameter4fvNV(target, index, params);
	}
	if (replicate_spu.swap)
	{
		crPackProgramParameter4fvNVSWAP(target, index, params);
	}
	else
	{
		crPackProgramParameter4fvNV(target, index, params);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateProgramParameter4fvNV( target, index, params );
	}
}

void REPLICATESPU_APIENTRY replicatespu_ProgramParameters4dvNV( GLenum target, GLuint index, GLuint num, const GLdouble * params )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileProgramParameters4dvNV(target, index, num, params);
	}
	if (replicate_spu.swap)
	{
		crPackProgramParameters4dvNVSWAP(target, index, num, params);
	}
	else
	{
		crPackProgramParameters4dvNV(target, index, num, params);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateProgramParameters4dvNV( target, index, num, params );
	}
}

void REPLICATESPU_APIENTRY replicatespu_ProgramParameters4fvNV( GLenum target, GLuint index, GLuint num, const GLfloat * params )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileProgramParameters4fvNV(target, index, num, params);
	}
	if (replicate_spu.swap)
	{
		crPackProgramParameters4fvNVSWAP(target, index, num, params);
	}
	else
	{
		crPackProgramParameters4fvNV(target, index, num, params);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateProgramParameters4fvNV( target, index, num, params );
	}
}

void REPLICATESPU_APIENTRY replicatespu_ProgramStringARB( GLenum target, GLenum format, GLsizei len, const GLvoid * string )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileProgramStringARB(target, format, len, string);
	}
	if (replicate_spu.swap)
	{
		crPackProgramStringARBSWAP(target, format, len, string);
	}
	else
	{
		crPackProgramStringARB(target, format, len, string);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateProgramStringARB( target, format, len, string );
	}
}

void REPLICATESPU_APIENTRY replicatespu_PushAttrib( GLbitfield mask )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompilePushAttrib(mask);
	}
	if (replicate_spu.swap)
	{
		crPackPushAttribSWAP(mask);
	}
	else
	{
		crPackPushAttrib(mask);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStatePushAttrib( mask );
	}
}

void REPLICATESPU_APIENTRY replicatespu_PushClientAttrib( GLbitfield mask )
{
	crStatePushClientAttrib( mask );
}

void REPLICATESPU_APIENTRY replicatespu_PushMatrix( void )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompilePushMatrix();
	}
	if (replicate_spu.swap)
	{
		crPackPushMatrixSWAP();
	}
	else
	{
		crPackPushMatrix();
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStatePushMatrix(  );
	}
}

void REPLICATESPU_APIENTRY replicatespu_PushName( GLuint name )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompilePushName(name);
	}
	if (replicate_spu.swap)
	{
		crPackPushNameSWAP(name);
	}
	else
	{
		crPackPushName(name);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStatePushName( name );
	}
}

void REPLICATESPU_APIENTRY replicatespu_RasterPos2d( GLdouble x, GLdouble y )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileRasterPos2d(x, y);
	}
	if (replicate_spu.swap)
	{
		crPackRasterPos2dSWAP(x, y);
	}
	else
	{
		crPackRasterPos2d(x, y);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateRasterPos2d( x, y );
	}
}

void REPLICATESPU_APIENTRY replicatespu_RasterPos2dv( const GLdouble * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileRasterPos2dv(v);
	}
	if (replicate_spu.swap)
	{
		crPackRasterPos2dvSWAP(v);
	}
	else
	{
		crPackRasterPos2dv(v);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateRasterPos2dv( v );
	}
}

void REPLICATESPU_APIENTRY replicatespu_RasterPos2f( GLfloat x, GLfloat y )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileRasterPos2f(x, y);
	}
	if (replicate_spu.swap)
	{
		crPackRasterPos2fSWAP(x, y);
	}
	else
	{
		crPackRasterPos2f(x, y);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateRasterPos2f( x, y );
	}
}

void REPLICATESPU_APIENTRY replicatespu_RasterPos2fv( const GLfloat * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileRasterPos2fv(v);
	}
	if (replicate_spu.swap)
	{
		crPackRasterPos2fvSWAP(v);
	}
	else
	{
		crPackRasterPos2fv(v);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateRasterPos2fv( v );
	}
}

void REPLICATESPU_APIENTRY replicatespu_RasterPos2i( GLint x, GLint y )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileRasterPos2i(x, y);
	}
	if (replicate_spu.swap)
	{
		crPackRasterPos2iSWAP(x, y);
	}
	else
	{
		crPackRasterPos2i(x, y);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateRasterPos2i( x, y );
	}
}

void REPLICATESPU_APIENTRY replicatespu_RasterPos2iv( const GLint * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileRasterPos2iv(v);
	}
	if (replicate_spu.swap)
	{
		crPackRasterPos2ivSWAP(v);
	}
	else
	{
		crPackRasterPos2iv(v);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateRasterPos2iv( v );
	}
}

void REPLICATESPU_APIENTRY replicatespu_RasterPos2s( GLshort x, GLshort y )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileRasterPos2s(x, y);
	}
	if (replicate_spu.swap)
	{
		crPackRasterPos2sSWAP(x, y);
	}
	else
	{
		crPackRasterPos2s(x, y);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateRasterPos2s( x, y );
	}
}

void REPLICATESPU_APIENTRY replicatespu_RasterPos2sv( const GLshort * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileRasterPos2sv(v);
	}
	if (replicate_spu.swap)
	{
		crPackRasterPos2svSWAP(v);
	}
	else
	{
		crPackRasterPos2sv(v);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateRasterPos2sv( v );
	}
}

void REPLICATESPU_APIENTRY replicatespu_RasterPos3d( GLdouble x, GLdouble y, GLdouble z )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileRasterPos3d(x, y, z);
	}
	if (replicate_spu.swap)
	{
		crPackRasterPos3dSWAP(x, y, z);
	}
	else
	{
		crPackRasterPos3d(x, y, z);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateRasterPos3d( x, y, z );
	}
}

void REPLICATESPU_APIENTRY replicatespu_RasterPos3dv( const GLdouble * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileRasterPos3dv(v);
	}
	if (replicate_spu.swap)
	{
		crPackRasterPos3dvSWAP(v);
	}
	else
	{
		crPackRasterPos3dv(v);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateRasterPos3dv( v );
	}
}

void REPLICATESPU_APIENTRY replicatespu_RasterPos3f( GLfloat x, GLfloat y, GLfloat z )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileRasterPos3f(x, y, z);
	}
	if (replicate_spu.swap)
	{
		crPackRasterPos3fSWAP(x, y, z);
	}
	else
	{
		crPackRasterPos3f(x, y, z);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateRasterPos3f( x, y, z );
	}
}

void REPLICATESPU_APIENTRY replicatespu_RasterPos3fv( const GLfloat * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileRasterPos3fv(v);
	}
	if (replicate_spu.swap)
	{
		crPackRasterPos3fvSWAP(v);
	}
	else
	{
		crPackRasterPos3fv(v);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateRasterPos3fv( v );
	}
}

void REPLICATESPU_APIENTRY replicatespu_RasterPos3i( GLint x, GLint y, GLint z )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileRasterPos3i(x, y, z);
	}
	if (replicate_spu.swap)
	{
		crPackRasterPos3iSWAP(x, y, z);
	}
	else
	{
		crPackRasterPos3i(x, y, z);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateRasterPos3i( x, y, z );
	}
}

void REPLICATESPU_APIENTRY replicatespu_RasterPos3iv( const GLint * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileRasterPos3iv(v);
	}
	if (replicate_spu.swap)
	{
		crPackRasterPos3ivSWAP(v);
	}
	else
	{
		crPackRasterPos3iv(v);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateRasterPos3iv( v );
	}
}

void REPLICATESPU_APIENTRY replicatespu_RasterPos3s( GLshort x, GLshort y, GLshort z )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileRasterPos3s(x, y, z);
	}
	if (replicate_spu.swap)
	{
		crPackRasterPos3sSWAP(x, y, z);
	}
	else
	{
		crPackRasterPos3s(x, y, z);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateRasterPos3s( x, y, z );
	}
}

void REPLICATESPU_APIENTRY replicatespu_RasterPos3sv( const GLshort * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileRasterPos3sv(v);
	}
	if (replicate_spu.swap)
	{
		crPackRasterPos3svSWAP(v);
	}
	else
	{
		crPackRasterPos3sv(v);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateRasterPos3sv( v );
	}
}

void REPLICATESPU_APIENTRY replicatespu_RasterPos4d( GLdouble x, GLdouble y, GLdouble z, GLdouble w )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileRasterPos4d(x, y, z, w);
	}
	if (replicate_spu.swap)
	{
		crPackRasterPos4dSWAP(x, y, z, w);
	}
	else
	{
		crPackRasterPos4d(x, y, z, w);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateRasterPos4d( x, y, z, w );
	}
}

void REPLICATESPU_APIENTRY replicatespu_RasterPos4dv( const GLdouble * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileRasterPos4dv(v);
	}
	if (replicate_spu.swap)
	{
		crPackRasterPos4dvSWAP(v);
	}
	else
	{
		crPackRasterPos4dv(v);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateRasterPos4dv( v );
	}
}

void REPLICATESPU_APIENTRY replicatespu_RasterPos4f( GLfloat x, GLfloat y, GLfloat z, GLfloat w )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileRasterPos4f(x, y, z, w);
	}
	if (replicate_spu.swap)
	{
		crPackRasterPos4fSWAP(x, y, z, w);
	}
	else
	{
		crPackRasterPos4f(x, y, z, w);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateRasterPos4f( x, y, z, w );
	}
}

void REPLICATESPU_APIENTRY replicatespu_RasterPos4fv( const GLfloat * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileRasterPos4fv(v);
	}
	if (replicate_spu.swap)
	{
		crPackRasterPos4fvSWAP(v);
	}
	else
	{
		crPackRasterPos4fv(v);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateRasterPos4fv( v );
	}
}

void REPLICATESPU_APIENTRY replicatespu_RasterPos4i( GLint x, GLint y, GLint z, GLint w )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileRasterPos4i(x, y, z, w);
	}
	if (replicate_spu.swap)
	{
		crPackRasterPos4iSWAP(x, y, z, w);
	}
	else
	{
		crPackRasterPos4i(x, y, z, w);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateRasterPos4i( x, y, z, w );
	}
}

void REPLICATESPU_APIENTRY replicatespu_RasterPos4iv( const GLint * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileRasterPos4iv(v);
	}
	if (replicate_spu.swap)
	{
		crPackRasterPos4ivSWAP(v);
	}
	else
	{
		crPackRasterPos4iv(v);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateRasterPos4iv( v );
	}
}

void REPLICATESPU_APIENTRY replicatespu_RasterPos4s( GLshort x, GLshort y, GLshort z, GLshort w )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileRasterPos4s(x, y, z, w);
	}
	if (replicate_spu.swap)
	{
		crPackRasterPos4sSWAP(x, y, z, w);
	}
	else
	{
		crPackRasterPos4s(x, y, z, w);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateRasterPos4s( x, y, z, w );
	}
}

void REPLICATESPU_APIENTRY replicatespu_RasterPos4sv( const GLshort * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileRasterPos4sv(v);
	}
	if (replicate_spu.swap)
	{
		crPackRasterPos4svSWAP(v);
	}
	else
	{
		crPackRasterPos4sv(v);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateRasterPos4sv( v );
	}
}

void REPLICATESPU_APIENTRY replicatespu_ReadBuffer( GLenum mode )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileReadBuffer(mode);
	}
	if (replicate_spu.swap)
	{
		crPackReadBufferSWAP(mode);
	}
	else
	{
		crPackReadBuffer(mode);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateReadBuffer( mode );
	}
}

/* ReadPixels not generated: special implementation exists */

void REPLICATESPU_APIENTRY replicatespu_Rectd( GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2 )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileRectd(x1, y1, x2, y2);
	}
	if (replicate_spu.swap)
	{
		crPackRectdSWAP(x1, y1, x2, y2);
	}
	else
	{
		crPackRectd(x1, y1, x2, y2);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Rectdv( const GLdouble * v1, const GLdouble * v2 )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileRectdv(v1, v2);
	}
	if (replicate_spu.swap)
	{
		crPackRectdvSWAP(v1, v2);
	}
	else
	{
		crPackRectdv(v1, v2);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Rectf( GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2 )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileRectf(x1, y1, x2, y2);
	}
	if (replicate_spu.swap)
	{
		crPackRectfSWAP(x1, y1, x2, y2);
	}
	else
	{
		crPackRectf(x1, y1, x2, y2);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Rectfv( const GLfloat * v1, const GLfloat * v2 )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileRectfv(v1, v2);
	}
	if (replicate_spu.swap)
	{
		crPackRectfvSWAP(v1, v2);
	}
	else
	{
		crPackRectfv(v1, v2);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Recti( GLint x1, GLint y1, GLint x2, GLint y2 )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileRecti(x1, y1, x2, y2);
	}
	if (replicate_spu.swap)
	{
		crPackRectiSWAP(x1, y1, x2, y2);
	}
	else
	{
		crPackRecti(x1, y1, x2, y2);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Rectiv( const GLint * v1, const GLint * v2 )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileRectiv(v1, v2);
	}
	if (replicate_spu.swap)
	{
		crPackRectivSWAP(v1, v2);
	}
	else
	{
		crPackRectiv(v1, v2);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Rects( GLshort x1, GLshort y1, GLshort x2, GLshort y2 )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileRects(x1, y1, x2, y2);
	}
	if (replicate_spu.swap)
	{
		crPackRectsSWAP(x1, y1, x2, y2);
	}
	else
	{
		crPackRects(x1, y1, x2, y2);
	}
}

void REPLICATESPU_APIENTRY replicatespu_Rectsv( const GLshort * v1, const GLshort * v2 )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileRectsv(v1, v2);
	}
	if (replicate_spu.swap)
	{
		crPackRectsvSWAP(v1, v2);
	}
	else
	{
		crPackRectsv(v1, v2);
	}
}

/* RenderMode not generated: special implementation exists */

void REPLICATESPU_APIENTRY replicatespu_RequestResidentProgramsNV( GLsizei n, const GLuint * ids )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileRequestResidentProgramsNV(n, ids);
	}
	if (replicate_spu.swap)
	{
		crPackRequestResidentProgramsNVSWAP(n, ids);
	}
	else
	{
		crPackRequestResidentProgramsNV(n, ids);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateRequestResidentProgramsNV( n, ids );
	}
}

void REPLICATESPU_APIENTRY replicatespu_Rotated( GLdouble angle, GLdouble x, GLdouble y, GLdouble z )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileRotated(angle, x, y, z);
	}
	if (replicate_spu.swap)
	{
		crPackRotatedSWAP(angle, x, y, z);
	}
	else
	{
		crPackRotated(angle, x, y, z);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateRotated( angle, x, y, z );
	}
}

void REPLICATESPU_APIENTRY replicatespu_Rotatef( GLfloat angle, GLfloat x, GLfloat y, GLfloat z )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileRotatef(angle, x, y, z);
	}
	if (replicate_spu.swap)
	{
		crPackRotatefSWAP(angle, x, y, z);
	}
	else
	{
		crPackRotatef(angle, x, y, z);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateRotatef( angle, x, y, z );
	}
}

void REPLICATESPU_APIENTRY replicatespu_SampleCoverageARB( GLclampf value, GLboolean invert )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileSampleCoverageARB(value, invert);
	}
	if (replicate_spu.swap)
	{
		crPackSampleCoverageARBSWAP(value, invert);
	}
	else
	{
		crPackSampleCoverageARB(value, invert);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateSampleCoverageARB( value, invert );
	}
}

void REPLICATESPU_APIENTRY replicatespu_Scaled( GLdouble x, GLdouble y, GLdouble z )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileScaled(x, y, z);
	}
	if (replicate_spu.swap)
	{
		crPackScaledSWAP(x, y, z);
	}
	else
	{
		crPackScaled(x, y, z);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateScaled( x, y, z );
	}
}

void REPLICATESPU_APIENTRY replicatespu_Scalef( GLfloat x, GLfloat y, GLfloat z )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileScalef(x, y, z);
	}
	if (replicate_spu.swap)
	{
		crPackScalefSWAP(x, y, z);
	}
	else
	{
		crPackScalef(x, y, z);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateScalef( x, y, z );
	}
}

void REPLICATESPU_APIENTRY replicatespu_Scissor( GLint x, GLint y, GLsizei width, GLsizei height )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileScissor(x, y, width, height);
	}
	if (replicate_spu.swap)
	{
		crPackScissorSWAP(x, y, width, height);
	}
	else
	{
		crPackScissor(x, y, width, height);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateScissor( x, y, width, height );
	}
}

void REPLICATESPU_APIENTRY replicatespu_SecondaryColor3bEXT( GLbyte red, GLbyte green, GLbyte blue )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileSecondaryColor3bEXT(red, green, blue);
	}
	if (replicate_spu.swap)
	{
		crPackSecondaryColor3bEXTSWAP(red, green, blue);
	}
	else
	{
		crPackSecondaryColor3bEXT(red, green, blue);
	}
}

void REPLICATESPU_APIENTRY replicatespu_SecondaryColor3bvEXT( const GLbyte * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileSecondaryColor3bvEXT(v);
	}
	if (replicate_spu.swap)
	{
		crPackSecondaryColor3bvEXTSWAP(v);
	}
	else
	{
		crPackSecondaryColor3bvEXT(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_SecondaryColor3dEXT( GLdouble red, GLdouble green, GLdouble blue )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileSecondaryColor3dEXT(red, green, blue);
	}
	if (replicate_spu.swap)
	{
		crPackSecondaryColor3dEXTSWAP(red, green, blue);
	}
	else
	{
		crPackSecondaryColor3dEXT(red, green, blue);
	}
}

void REPLICATESPU_APIENTRY replicatespu_SecondaryColor3dvEXT( const GLdouble * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileSecondaryColor3dvEXT(v);
	}
	if (replicate_spu.swap)
	{
		crPackSecondaryColor3dvEXTSWAP(v);
	}
	else
	{
		crPackSecondaryColor3dvEXT(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_SecondaryColor3fEXT( GLfloat red, GLfloat green, GLfloat blue )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileSecondaryColor3fEXT(red, green, blue);
	}
	if (replicate_spu.swap)
	{
		crPackSecondaryColor3fEXTSWAP(red, green, blue);
	}
	else
	{
		crPackSecondaryColor3fEXT(red, green, blue);
	}
}

void REPLICATESPU_APIENTRY replicatespu_SecondaryColor3fvEXT( const GLfloat * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileSecondaryColor3fvEXT(v);
	}
	if (replicate_spu.swap)
	{
		crPackSecondaryColor3fvEXTSWAP(v);
	}
	else
	{
		crPackSecondaryColor3fvEXT(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_SecondaryColor3iEXT( GLint red, GLint green, GLint blue )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileSecondaryColor3iEXT(red, green, blue);
	}
	if (replicate_spu.swap)
	{
		crPackSecondaryColor3iEXTSWAP(red, green, blue);
	}
	else
	{
		crPackSecondaryColor3iEXT(red, green, blue);
	}
}

void REPLICATESPU_APIENTRY replicatespu_SecondaryColor3ivEXT( const GLint * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileSecondaryColor3ivEXT(v);
	}
	if (replicate_spu.swap)
	{
		crPackSecondaryColor3ivEXTSWAP(v);
	}
	else
	{
		crPackSecondaryColor3ivEXT(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_SecondaryColor3sEXT( GLshort red, GLshort green, GLshort blue )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileSecondaryColor3sEXT(red, green, blue);
	}
	if (replicate_spu.swap)
	{
		crPackSecondaryColor3sEXTSWAP(red, green, blue);
	}
	else
	{
		crPackSecondaryColor3sEXT(red, green, blue);
	}
}

void REPLICATESPU_APIENTRY replicatespu_SecondaryColor3svEXT( const GLshort * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileSecondaryColor3svEXT(v);
	}
	if (replicate_spu.swap)
	{
		crPackSecondaryColor3svEXTSWAP(v);
	}
	else
	{
		crPackSecondaryColor3svEXT(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_SecondaryColor3ubEXT( GLubyte red, GLubyte green, GLubyte blue )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileSecondaryColor3ubEXT(red, green, blue);
	}
	if (replicate_spu.swap)
	{
		crPackSecondaryColor3ubEXTSWAP(red, green, blue);
	}
	else
	{
		crPackSecondaryColor3ubEXT(red, green, blue);
	}
}

void REPLICATESPU_APIENTRY replicatespu_SecondaryColor3ubvEXT( const GLubyte * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileSecondaryColor3ubvEXT(v);
	}
	if (replicate_spu.swap)
	{
		crPackSecondaryColor3ubvEXTSWAP(v);
	}
	else
	{
		crPackSecondaryColor3ubvEXT(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_SecondaryColor3uiEXT( GLuint red, GLuint green, GLuint blue )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileSecondaryColor3uiEXT(red, green, blue);
	}
	if (replicate_spu.swap)
	{
		crPackSecondaryColor3uiEXTSWAP(red, green, blue);
	}
	else
	{
		crPackSecondaryColor3uiEXT(red, green, blue);
	}
}

void REPLICATESPU_APIENTRY replicatespu_SecondaryColor3uivEXT( const GLuint * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileSecondaryColor3uivEXT(v);
	}
	if (replicate_spu.swap)
	{
		crPackSecondaryColor3uivEXTSWAP(v);
	}
	else
	{
		crPackSecondaryColor3uivEXT(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_SecondaryColor3usEXT( GLushort red, GLushort green, GLushort blue )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileSecondaryColor3usEXT(red, green, blue);
	}
	if (replicate_spu.swap)
	{
		crPackSecondaryColor3usEXTSWAP(red, green, blue);
	}
	else
	{
		crPackSecondaryColor3usEXT(red, green, blue);
	}
}

void REPLICATESPU_APIENTRY replicatespu_SecondaryColor3usvEXT( const GLushort * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileSecondaryColor3usvEXT(v);
	}
	if (replicate_spu.swap)
	{
		crPackSecondaryColor3usvEXTSWAP(v);
	}
	else
	{
		crPackSecondaryColor3usvEXT(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_SecondaryColorPointerEXT( GLint size, GLenum type, GLsizei stride, const GLvoid * pointer )
{
	crStateSecondaryColorPointerEXT( size, type, stride, pointer );
}

/* SelectBuffer not generated: crPack implementation suffices */

void REPLICATESPU_APIENTRY replicatespu_SemaphoreCreateCR( GLuint name, GLuint count )
{
	GET_THREAD(thread);
	if (replicate_spu.swap)
	{
		crPackSemaphoreCreateCRSWAP(name, count);
	}
	else
	{
		crPackSemaphoreCreateCR(name, count);
	}
	replicatespuFlushOne(thread, 0);
}

/* SemaphoreDestroyCR not generated: crPack implementation suffices */

void REPLICATESPU_APIENTRY replicatespu_SemaphorePCR( GLuint name )
{
	GET_THREAD(thread);
	if (replicate_spu.swap)
	{
		crPackSemaphorePCRSWAP(name);
	}
	else
	{
		crPackSemaphorePCR(name);
	}
	replicatespuFlushOne(thread, 0);
}

void REPLICATESPU_APIENTRY replicatespu_SemaphoreVCR( GLuint name )
{
	GET_THREAD(thread);
	if (replicate_spu.swap)
	{
		crPackSemaphoreVCRSWAP(name);
	}
	else
	{
		crPackSemaphoreVCR(name);
	}
	replicatespuFlushOne(thread, 0);
}

void REPLICATESPU_APIENTRY replicatespu_SetFenceNV( GLuint fence, GLenum condition )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileSetFenceNV(fence, condition);
	}
	if (replicate_spu.swap)
	{
		crPackSetFenceNVSWAP(fence, condition);
	}
	else
	{
		crPackSetFenceNV(fence, condition);
	}
}

void REPLICATESPU_APIENTRY replicatespu_ShadeModel( GLenum mode )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileShadeModel(mode);
	}
	if (replicate_spu.swap)
	{
		crPackShadeModelSWAP(mode);
	}
	else
	{
		crPackShadeModel(mode);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateShadeModel( mode );
	}
}

void REPLICATESPU_APIENTRY replicatespu_StencilFunc( GLenum func, GLint ref, GLuint mask )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileStencilFunc(func, ref, mask);
	}
	if (replicate_spu.swap)
	{
		crPackStencilFuncSWAP(func, ref, mask);
	}
	else
	{
		crPackStencilFunc(func, ref, mask);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateStencilFunc( func, ref, mask );
	}
}

void REPLICATESPU_APIENTRY replicatespu_StencilMask( GLuint mask )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileStencilMask(mask);
	}
	if (replicate_spu.swap)
	{
		crPackStencilMaskSWAP(mask);
	}
	else
	{
		crPackStencilMask(mask);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateStencilMask( mask );
	}
}

void REPLICATESPU_APIENTRY replicatespu_StencilOp( GLenum fail, GLenum zfail, GLenum zpass )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileStencilOp(fail, zfail, zpass);
	}
	if (replicate_spu.swap)
	{
		crPackStencilOpSWAP(fail, zfail, zpass);
	}
	else
	{
		crPackStencilOp(fail, zfail, zpass);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateStencilOp( fail, zfail, zpass );
	}
}

/* SwapBuffers not generated: special implementation exists */

GLboolean REPLICATESPU_APIENTRY replicatespu_TestFenceNV( GLuint fence )
{
	GET_THREAD(thread);
	int writeback = 1;
	GLboolean return_val = (GLboolean) 0;
	replicatespuFlushAll( (void *) thread );
	if (replicate_spu.swap)
	{
		crPackTestFenceNVSWAP(fence, &return_val, &writeback);
	}
	else
	{
		crPackTestFenceNV(fence, &return_val, &writeback);
	}
	replicatespuFlushOne(thread, 0);
	while (writeback)
		crNetRecv();
	if (replicate_spu.swap)
	{
		return_val = (GLboolean) SWAP32(return_val);
	}
	return return_val;
}

void REPLICATESPU_APIENTRY replicatespu_TexCoord1d( GLdouble s )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexCoord1d(s);
	}
	if (replicate_spu.swap)
	{
		crPackTexCoord1dSWAP(s);
	}
	else
	{
		crPackTexCoord1d(s);
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexCoord1dv( const GLdouble * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexCoord1dv(v);
	}
	if (replicate_spu.swap)
	{
		crPackTexCoord1dvSWAP(v);
	}
	else
	{
		crPackTexCoord1dv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexCoord1f( GLfloat s )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexCoord1f(s);
	}
	if (replicate_spu.swap)
	{
		crPackTexCoord1fSWAP(s);
	}
	else
	{
		crPackTexCoord1f(s);
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexCoord1fv( const GLfloat * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexCoord1fv(v);
	}
	if (replicate_spu.swap)
	{
		crPackTexCoord1fvSWAP(v);
	}
	else
	{
		crPackTexCoord1fv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexCoord1i( GLint s )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexCoord1i(s);
	}
	if (replicate_spu.swap)
	{
		crPackTexCoord1iSWAP(s);
	}
	else
	{
		crPackTexCoord1i(s);
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexCoord1iv( const GLint * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexCoord1iv(v);
	}
	if (replicate_spu.swap)
	{
		crPackTexCoord1ivSWAP(v);
	}
	else
	{
		crPackTexCoord1iv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexCoord1s( GLshort s )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexCoord1s(s);
	}
	if (replicate_spu.swap)
	{
		crPackTexCoord1sSWAP(s);
	}
	else
	{
		crPackTexCoord1s(s);
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexCoord1sv( const GLshort * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexCoord1sv(v);
	}
	if (replicate_spu.swap)
	{
		crPackTexCoord1svSWAP(v);
	}
	else
	{
		crPackTexCoord1sv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexCoord2d( GLdouble s, GLdouble t )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexCoord2d(s, t);
	}
	if (replicate_spu.swap)
	{
		crPackTexCoord2dSWAP(s, t);
	}
	else
	{
		crPackTexCoord2d(s, t);
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexCoord2dv( const GLdouble * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexCoord2dv(v);
	}
	if (replicate_spu.swap)
	{
		crPackTexCoord2dvSWAP(v);
	}
	else
	{
		crPackTexCoord2dv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexCoord2f( GLfloat s, GLfloat t )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexCoord2f(s, t);
	}
	if (replicate_spu.swap)
	{
		crPackTexCoord2fSWAP(s, t);
	}
	else
	{
		crPackTexCoord2f(s, t);
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexCoord2fv( const GLfloat * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexCoord2fv(v);
	}
	if (replicate_spu.swap)
	{
		crPackTexCoord2fvSWAP(v);
	}
	else
	{
		crPackTexCoord2fv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexCoord2i( GLint s, GLint t )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexCoord2i(s, t);
	}
	if (replicate_spu.swap)
	{
		crPackTexCoord2iSWAP(s, t);
	}
	else
	{
		crPackTexCoord2i(s, t);
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexCoord2iv( const GLint * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexCoord2iv(v);
	}
	if (replicate_spu.swap)
	{
		crPackTexCoord2ivSWAP(v);
	}
	else
	{
		crPackTexCoord2iv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexCoord2s( GLshort s, GLshort t )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexCoord2s(s, t);
	}
	if (replicate_spu.swap)
	{
		crPackTexCoord2sSWAP(s, t);
	}
	else
	{
		crPackTexCoord2s(s, t);
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexCoord2sv( const GLshort * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexCoord2sv(v);
	}
	if (replicate_spu.swap)
	{
		crPackTexCoord2svSWAP(v);
	}
	else
	{
		crPackTexCoord2sv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexCoord3d( GLdouble s, GLdouble t, GLdouble r )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexCoord3d(s, t, r);
	}
	if (replicate_spu.swap)
	{
		crPackTexCoord3dSWAP(s, t, r);
	}
	else
	{
		crPackTexCoord3d(s, t, r);
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexCoord3dv( const GLdouble * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexCoord3dv(v);
	}
	if (replicate_spu.swap)
	{
		crPackTexCoord3dvSWAP(v);
	}
	else
	{
		crPackTexCoord3dv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexCoord3f( GLfloat s, GLfloat t, GLfloat r )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexCoord3f(s, t, r);
	}
	if (replicate_spu.swap)
	{
		crPackTexCoord3fSWAP(s, t, r);
	}
	else
	{
		crPackTexCoord3f(s, t, r);
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexCoord3fv( const GLfloat * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexCoord3fv(v);
	}
	if (replicate_spu.swap)
	{
		crPackTexCoord3fvSWAP(v);
	}
	else
	{
		crPackTexCoord3fv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexCoord3i( GLint s, GLint t, GLint r )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexCoord3i(s, t, r);
	}
	if (replicate_spu.swap)
	{
		crPackTexCoord3iSWAP(s, t, r);
	}
	else
	{
		crPackTexCoord3i(s, t, r);
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexCoord3iv( const GLint * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexCoord3iv(v);
	}
	if (replicate_spu.swap)
	{
		crPackTexCoord3ivSWAP(v);
	}
	else
	{
		crPackTexCoord3iv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexCoord3s( GLshort s, GLshort t, GLshort r )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexCoord3s(s, t, r);
	}
	if (replicate_spu.swap)
	{
		crPackTexCoord3sSWAP(s, t, r);
	}
	else
	{
		crPackTexCoord3s(s, t, r);
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexCoord3sv( const GLshort * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexCoord3sv(v);
	}
	if (replicate_spu.swap)
	{
		crPackTexCoord3svSWAP(v);
	}
	else
	{
		crPackTexCoord3sv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexCoord4d( GLdouble s, GLdouble t, GLdouble r, GLdouble q )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexCoord4d(s, t, r, q);
	}
	if (replicate_spu.swap)
	{
		crPackTexCoord4dSWAP(s, t, r, q);
	}
	else
	{
		crPackTexCoord4d(s, t, r, q);
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexCoord4dv( const GLdouble * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexCoord4dv(v);
	}
	if (replicate_spu.swap)
	{
		crPackTexCoord4dvSWAP(v);
	}
	else
	{
		crPackTexCoord4dv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexCoord4f( GLfloat s, GLfloat t, GLfloat r, GLfloat q )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexCoord4f(s, t, r, q);
	}
	if (replicate_spu.swap)
	{
		crPackTexCoord4fSWAP(s, t, r, q);
	}
	else
	{
		crPackTexCoord4f(s, t, r, q);
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexCoord4fv( const GLfloat * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexCoord4fv(v);
	}
	if (replicate_spu.swap)
	{
		crPackTexCoord4fvSWAP(v);
	}
	else
	{
		crPackTexCoord4fv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexCoord4i( GLint s, GLint t, GLint r, GLint q )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexCoord4i(s, t, r, q);
	}
	if (replicate_spu.swap)
	{
		crPackTexCoord4iSWAP(s, t, r, q);
	}
	else
	{
		crPackTexCoord4i(s, t, r, q);
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexCoord4iv( const GLint * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexCoord4iv(v);
	}
	if (replicate_spu.swap)
	{
		crPackTexCoord4ivSWAP(v);
	}
	else
	{
		crPackTexCoord4iv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexCoord4s( GLshort s, GLshort t, GLshort r, GLshort q )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexCoord4s(s, t, r, q);
	}
	if (replicate_spu.swap)
	{
		crPackTexCoord4sSWAP(s, t, r, q);
	}
	else
	{
		crPackTexCoord4s(s, t, r, q);
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexCoord4sv( const GLshort * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexCoord4sv(v);
	}
	if (replicate_spu.swap)
	{
		crPackTexCoord4svSWAP(v);
	}
	else
	{
		crPackTexCoord4sv(v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexCoordPointer( GLint size, GLenum type, GLsizei stride, const GLvoid * pointer )
{
	crStateTexCoordPointer( size, type, stride, pointer );
}

void REPLICATESPU_APIENTRY replicatespu_TexEnvf( GLenum target, GLenum pname, GLfloat param )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexEnvf(target, pname, param);
	}
	if (replicate_spu.swap)
	{
		crPackTexEnvfSWAP(target, pname, param);
	}
	else
	{
		crPackTexEnvf(target, pname, param);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateTexEnvf( target, pname, param );
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexEnvfv( GLenum target, GLenum pname, const GLfloat * params )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexEnvfv(target, pname, params);
	}
	if (replicate_spu.swap)
	{
		crPackTexEnvfvSWAP(target, pname, params);
	}
	else
	{
		crPackTexEnvfv(target, pname, params);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateTexEnvfv( target, pname, params );
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexEnvi( GLenum target, GLenum pname, GLint param )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexEnvi(target, pname, param);
	}
	if (replicate_spu.swap)
	{
		crPackTexEnviSWAP(target, pname, param);
	}
	else
	{
		crPackTexEnvi(target, pname, param);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateTexEnvi( target, pname, param );
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexEnviv( GLenum target, GLenum pname, const GLint * params )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexEnviv(target, pname, params);
	}
	if (replicate_spu.swap)
	{
		crPackTexEnvivSWAP(target, pname, params);
	}
	else
	{
		crPackTexEnviv(target, pname, params);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateTexEnviv( target, pname, params );
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexGend( GLenum coord, GLenum pname, GLdouble param )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexGend(coord, pname, param);
	}
	if (replicate_spu.swap)
	{
		crPackTexGendSWAP(coord, pname, param);
	}
	else
	{
		crPackTexGend(coord, pname, param);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateTexGend( coord, pname, param );
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexGendv( GLenum coord, GLenum pname, const GLdouble * params )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexGendv(coord, pname, params);
	}
	if (replicate_spu.swap)
	{
		crPackTexGendvSWAP(coord, pname, params);
	}
	else
	{
		crPackTexGendv(coord, pname, params);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateTexGendv( coord, pname, params );
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexGenf( GLenum coord, GLenum pname, GLfloat param )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexGenf(coord, pname, param);
	}
	if (replicate_spu.swap)
	{
		crPackTexGenfSWAP(coord, pname, param);
	}
	else
	{
		crPackTexGenf(coord, pname, param);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateTexGenf( coord, pname, param );
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexGenfv( GLenum coord, GLenum pname, const GLfloat * params )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexGenfv(coord, pname, params);
	}
	if (replicate_spu.swap)
	{
		crPackTexGenfvSWAP(coord, pname, params);
	}
	else
	{
		crPackTexGenfv(coord, pname, params);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateTexGenfv( coord, pname, params );
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexGeni( GLenum coord, GLenum pname, GLint param )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexGeni(coord, pname, param);
	}
	if (replicate_spu.swap)
	{
		crPackTexGeniSWAP(coord, pname, param);
	}
	else
	{
		crPackTexGeni(coord, pname, param);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateTexGeni( coord, pname, param );
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexGeniv( GLenum coord, GLenum pname, const GLint * params )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexGeniv(coord, pname, params);
	}
	if (replicate_spu.swap)
	{
		crPackTexGenivSWAP(coord, pname, params);
	}
	else
	{
		crPackTexGeniv(coord, pname, params);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateTexGeniv( coord, pname, params );
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexImage1D( GLenum target, GLint level, GLint internalFormat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid * pixels )
{
	GET_THREAD(thread);
	ContextInfo *ctx = thread->currentContext;
	CRClientState *clientState = &(ctx->State->client);
	if (thread->currentContext->displayListMode != GL_FALSE &&
		crDLMCheckListTexImage1D(target, level, internalFormat, width, border, format, type, pixels)) {
		crDLMCompileTexImage1D(target, level, internalFormat, width, border, format, type, pixels, clientState);
	}
	if (replicate_spu.swap)
	{
		crPackTexImage1DSWAP(target, level, internalFormat, width, border, format, type, pixels, &(clientState->unpack));
	}
	else
	{
		crPackTexImage1D(target, level, internalFormat, width, border, format, type, pixels, &(clientState->unpack));
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateTexImage1D( target, level, internalFormat, width, border, format, type, pixels );
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexImage2D( GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid * pixels )
{
	GET_THREAD(thread);
	ContextInfo *ctx = thread->currentContext;
	CRClientState *clientState = &(ctx->State->client);
	if (thread->currentContext->displayListMode != GL_FALSE &&
		crDLMCheckListTexImage2D(target, level, internalFormat, width, height, border, format, type, pixels)) {
		crDLMCompileTexImage2D(target, level, internalFormat, width, height, border, format, type, pixels, clientState);
	}
	if (replicate_spu.swap)
	{
		crPackTexImage2DSWAP(target, level, internalFormat, width, height, border, format, type, pixels, &(clientState->unpack));
	}
	else
	{
		crPackTexImage2D(target, level, internalFormat, width, height, border, format, type, pixels, &(clientState->unpack));
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateTexImage2D( target, level, internalFormat, width, height, border, format, type, pixels );
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexImage3D( GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels )
{
	GET_THREAD(thread);
	ContextInfo *ctx = thread->currentContext;
	CRClientState *clientState = &(ctx->State->client);
	if (thread->currentContext->displayListMode != GL_FALSE &&
		crDLMCheckListTexImage3D(target, level, internalFormat, width, height, depth, border, format, type, pixels)) {
		crDLMCompileTexImage3D(target, level, internalFormat, width, height, depth, border, format, type, pixels, clientState);
	}
	if (replicate_spu.swap)
	{
		crPackTexImage3DSWAP(target, level, internalFormat, width, height, depth, border, format, type, pixels, &(clientState->unpack));
	}
	else
	{
		crPackTexImage3D(target, level, internalFormat, width, height, depth, border, format, type, pixels, &(clientState->unpack));
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateTexImage3D( target, level, internalFormat, width, height, depth, border, format, type, pixels );
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexImage3DEXT( GLenum target, GLint level, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels )
{
	GET_THREAD(thread);
	ContextInfo *ctx = thread->currentContext;
	CRClientState *clientState = &(ctx->State->client);
	if (thread->currentContext->displayListMode != GL_FALSE &&
		crDLMCheckListTexImage3DEXT(target, level, internalFormat, width, height, depth, border, format, type, pixels)) {
		crDLMCompileTexImage3DEXT(target, level, internalFormat, width, height, depth, border, format, type, pixels, clientState);
	}
	if (replicate_spu.swap)
	{
		crPackTexImage3DEXTSWAP(target, level, internalFormat, width, height, depth, border, format, type, pixels, &(clientState->unpack));
	}
	else
	{
		crPackTexImage3DEXT(target, level, internalFormat, width, height, depth, border, format, type, pixels, &(clientState->unpack));
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateTexImage3DEXT( target, level, internalFormat, width, height, depth, border, format, type, pixels );
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexParameterf( GLenum target, GLenum pname, GLfloat param )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexParameterf(target, pname, param);
	}
	if (replicate_spu.swap)
	{
		crPackTexParameterfSWAP(target, pname, param);
	}
	else
	{
		crPackTexParameterf(target, pname, param);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateTexParameterf( target, pname, param );
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexParameterfv( GLenum target, GLenum pname, const GLfloat * params )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexParameterfv(target, pname, params);
	}
	if (replicate_spu.swap)
	{
		crPackTexParameterfvSWAP(target, pname, params);
	}
	else
	{
		crPackTexParameterfv(target, pname, params);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateTexParameterfv( target, pname, params );
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexParameteri( GLenum target, GLenum pname, GLint param )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexParameteri(target, pname, param);
	}
	if (replicate_spu.swap)
	{
		crPackTexParameteriSWAP(target, pname, param);
	}
	else
	{
		crPackTexParameteri(target, pname, param);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateTexParameteri( target, pname, param );
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexParameteriv( GLenum target, GLenum pname, const GLint * params )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexParameteriv(target, pname, params);
	}
	if (replicate_spu.swap)
	{
		crPackTexParameterivSWAP(target, pname, params);
	}
	else
	{
		crPackTexParameteriv(target, pname, params);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateTexParameteriv( target, pname, params );
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexSubImage1D( GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * pixels )
{
	GET_THREAD(thread);
	ContextInfo *ctx = thread->currentContext;
	CRClientState *clientState = &(ctx->State->client);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexSubImage1D(target, level, xoffset, width, format, type, pixels, clientState);
	}
	if (replicate_spu.swap)
	{
		crPackTexSubImage1DSWAP(target, level, xoffset, width, format, type, pixels, &(clientState->unpack));
	}
	else
	{
		crPackTexSubImage1D(target, level, xoffset, width, format, type, pixels, &(clientState->unpack));
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateTexSubImage1D( target, level, xoffset, width, format, type, pixels );
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexSubImage2D( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels )
{
	GET_THREAD(thread);
	ContextInfo *ctx = thread->currentContext;
	CRClientState *clientState = &(ctx->State->client);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels, clientState);
	}
	if (replicate_spu.swap)
	{
		crPackTexSubImage2DSWAP(target, level, xoffset, yoffset, width, height, format, type, pixels, &(clientState->unpack));
	}
	else
	{
		crPackTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels, &(clientState->unpack));
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateTexSubImage2D( target, level, xoffset, yoffset, width, height, format, type, pixels );
	}
}

void REPLICATESPU_APIENTRY replicatespu_TexSubImage3D( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels )
{
	GET_THREAD(thread);
	ContextInfo *ctx = thread->currentContext;
	CRClientState *clientState = &(ctx->State->client);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels, clientState);
	}
	if (replicate_spu.swap)
	{
		crPackTexSubImage3DSWAP(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels, &(clientState->unpack));
	}
	else
	{
		crPackTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels, &(clientState->unpack));
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateTexSubImage3D( target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels );
	}
}

void REPLICATESPU_APIENTRY replicatespu_TrackMatrixNV( GLenum target, GLuint address, GLenum matrix, GLenum transform )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTrackMatrixNV(target, address, matrix, transform);
	}
	if (replicate_spu.swap)
	{
		crPackTrackMatrixNVSWAP(target, address, matrix, transform);
	}
	else
	{
		crPackTrackMatrixNV(target, address, matrix, transform);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateTrackMatrixNV( target, address, matrix, transform );
	}
}

void REPLICATESPU_APIENTRY replicatespu_Translated( GLdouble x, GLdouble y, GLdouble z )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTranslated(x, y, z);
	}
	if (replicate_spu.swap)
	{
		crPackTranslatedSWAP(x, y, z);
	}
	else
	{
		crPackTranslated(x, y, z);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateTranslated( x, y, z );
	}
}

void REPLICATESPU_APIENTRY replicatespu_Translatef( GLfloat x, GLfloat y, GLfloat z )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileTranslatef(x, y, z);
	}
	if (replicate_spu.swap)
	{
		crPackTranslatefSWAP(x, y, z);
	}
	else
	{
		crPackTranslatef(x, y, z);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateTranslatef( x, y, z );
	}
}

/* UnmapBufferARB not generated: special implementation exists */
/* Vertex2d not generated: special implementation exists */
/* Vertex2dv not generated: special implementation exists */
/* Vertex2f not generated: special implementation exists */
/* Vertex2fv not generated: special implementation exists */
/* Vertex2i not generated: special implementation exists */
/* Vertex2iv not generated: special implementation exists */
/* Vertex2s not generated: special implementation exists */
/* Vertex2sv not generated: special implementation exists */
/* Vertex3d not generated: special implementation exists */
/* Vertex3dv not generated: special implementation exists */
/* Vertex3f not generated: special implementation exists */
/* Vertex3fv not generated: special implementation exists */
/* Vertex3i not generated: special implementation exists */
/* Vertex3iv not generated: special implementation exists */
/* Vertex3s not generated: special implementation exists */
/* Vertex3sv not generated: special implementation exists */
/* Vertex4d not generated: special implementation exists */
/* Vertex4dv not generated: special implementation exists */
/* Vertex4f not generated: special implementation exists */
/* Vertex4fv not generated: special implementation exists */
/* Vertex4i not generated: special implementation exists */
/* Vertex4iv not generated: special implementation exists */
/* Vertex4s not generated: special implementation exists */
/* Vertex4sv not generated: special implementation exists */

void REPLICATESPU_APIENTRY replicatespu_VertexArrayRangeNV( GLsizei length, const GLvoid * pointer )
{
	crStateVertexArrayRangeNV( length, pointer );
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib1dARB( GLuint index, GLdouble x )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib1dARB(index, x);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib1dARBSWAP(index, x);
	}
	else
	{
		crPackVertexAttrib1dARB(index, x);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib1dvARB( GLuint index, const GLdouble * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib1dvARB(index, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib1dvARBSWAP(index, v);
	}
	else
	{
		crPackVertexAttrib1dvARB(index, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib1fARB( GLuint index, GLfloat x )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib1fARB(index, x);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib1fARBSWAP(index, x);
	}
	else
	{
		crPackVertexAttrib1fARB(index, x);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib1fvARB( GLuint index, const GLfloat * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib1fvARB(index, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib1fvARBSWAP(index, v);
	}
	else
	{
		crPackVertexAttrib1fvARB(index, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib1sARB( GLuint index, GLshort x )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib1sARB(index, x);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib1sARBSWAP(index, x);
	}
	else
	{
		crPackVertexAttrib1sARB(index, x);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib1svARB( GLuint index, const GLshort * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib1svARB(index, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib1svARBSWAP(index, v);
	}
	else
	{
		crPackVertexAttrib1svARB(index, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib2dARB( GLuint index, GLdouble x, GLdouble y )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib2dARB(index, x, y);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib2dARBSWAP(index, x, y);
	}
	else
	{
		crPackVertexAttrib2dARB(index, x, y);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib2dvARB( GLuint index, const GLdouble * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib2dvARB(index, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib2dvARBSWAP(index, v);
	}
	else
	{
		crPackVertexAttrib2dvARB(index, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib2fARB( GLuint index, GLfloat x, GLfloat y )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib2fARB(index, x, y);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib2fARBSWAP(index, x, y);
	}
	else
	{
		crPackVertexAttrib2fARB(index, x, y);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib2fvARB( GLuint index, const GLfloat * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib2fvARB(index, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib2fvARBSWAP(index, v);
	}
	else
	{
		crPackVertexAttrib2fvARB(index, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib2sARB( GLuint index, GLshort x, GLshort y )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib2sARB(index, x, y);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib2sARBSWAP(index, x, y);
	}
	else
	{
		crPackVertexAttrib2sARB(index, x, y);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib2svARB( GLuint index, const GLshort * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib2svARB(index, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib2svARBSWAP(index, v);
	}
	else
	{
		crPackVertexAttrib2svARB(index, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib3dARB( GLuint index, GLdouble x, GLdouble y, GLdouble z )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib3dARB(index, x, y, z);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib3dARBSWAP(index, x, y, z);
	}
	else
	{
		crPackVertexAttrib3dARB(index, x, y, z);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib3dvARB( GLuint index, const GLdouble * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib3dvARB(index, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib3dvARBSWAP(index, v);
	}
	else
	{
		crPackVertexAttrib3dvARB(index, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib3fARB( GLuint index, GLfloat x, GLfloat y, GLfloat z )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib3fARB(index, x, y, z);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib3fARBSWAP(index, x, y, z);
	}
	else
	{
		crPackVertexAttrib3fARB(index, x, y, z);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib3fvARB( GLuint index, const GLfloat * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib3fvARB(index, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib3fvARBSWAP(index, v);
	}
	else
	{
		crPackVertexAttrib3fvARB(index, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib3sARB( GLuint index, GLshort x, GLshort y, GLshort z )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib3sARB(index, x, y, z);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib3sARBSWAP(index, x, y, z);
	}
	else
	{
		crPackVertexAttrib3sARB(index, x, y, z);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib3svARB( GLuint index, const GLshort * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib3svARB(index, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib3svARBSWAP(index, v);
	}
	else
	{
		crPackVertexAttrib3svARB(index, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib4NbvARB( GLuint index, const GLbyte * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib4NbvARB(index, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib4NbvARBSWAP(index, v);
	}
	else
	{
		crPackVertexAttrib4NbvARB(index, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib4NivARB( GLuint index, const GLint * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib4NivARB(index, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib4NivARBSWAP(index, v);
	}
	else
	{
		crPackVertexAttrib4NivARB(index, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib4NsvARB( GLuint index, const GLshort * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib4NsvARB(index, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib4NsvARBSWAP(index, v);
	}
	else
	{
		crPackVertexAttrib4NsvARB(index, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib4NubARB( GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib4NubARB(index, x, y, z, w);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib4NubARBSWAP(index, x, y, z, w);
	}
	else
	{
		crPackVertexAttrib4NubARB(index, x, y, z, w);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib4NubvARB( GLuint index, const GLubyte * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib4NubvARB(index, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib4NubvARBSWAP(index, v);
	}
	else
	{
		crPackVertexAttrib4NubvARB(index, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib4NuivARB( GLuint index, const GLuint * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib4NuivARB(index, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib4NuivARBSWAP(index, v);
	}
	else
	{
		crPackVertexAttrib4NuivARB(index, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib4NusvARB( GLuint index, const GLushort * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib4NusvARB(index, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib4NusvARBSWAP(index, v);
	}
	else
	{
		crPackVertexAttrib4NusvARB(index, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib4bvARB( GLuint index, const GLbyte * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib4bvARB(index, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib4bvARBSWAP(index, v);
	}
	else
	{
		crPackVertexAttrib4bvARB(index, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib4dARB( GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib4dARB(index, x, y, z, w);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib4dARBSWAP(index, x, y, z, w);
	}
	else
	{
		crPackVertexAttrib4dARB(index, x, y, z, w);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib4dvARB( GLuint index, const GLdouble * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib4dvARB(index, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib4dvARBSWAP(index, v);
	}
	else
	{
		crPackVertexAttrib4dvARB(index, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib4fARB( GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib4fARB(index, x, y, z, w);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib4fARBSWAP(index, x, y, z, w);
	}
	else
	{
		crPackVertexAttrib4fARB(index, x, y, z, w);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib4fvARB( GLuint index, const GLfloat * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib4fvARB(index, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib4fvARBSWAP(index, v);
	}
	else
	{
		crPackVertexAttrib4fvARB(index, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib4ivARB( GLuint index, const GLint * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib4ivARB(index, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib4ivARBSWAP(index, v);
	}
	else
	{
		crPackVertexAttrib4ivARB(index, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib4sARB( GLuint index, GLshort x, GLshort y, GLshort z, GLshort w )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib4sARB(index, x, y, z, w);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib4sARBSWAP(index, x, y, z, w);
	}
	else
	{
		crPackVertexAttrib4sARB(index, x, y, z, w);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib4svARB( GLuint index, const GLshort * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib4svARB(index, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib4svARBSWAP(index, v);
	}
	else
	{
		crPackVertexAttrib4svARB(index, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib4ubvARB( GLuint index, const GLubyte * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib4ubvARB(index, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib4ubvARBSWAP(index, v);
	}
	else
	{
		crPackVertexAttrib4ubvARB(index, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib4uivARB( GLuint index, const GLuint * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib4uivARB(index, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib4uivARBSWAP(index, v);
	}
	else
	{
		crPackVertexAttrib4uivARB(index, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttrib4usvARB( GLuint index, const GLushort * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttrib4usvARB(index, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttrib4usvARBSWAP(index, v);
	}
	else
	{
		crPackVertexAttrib4usvARB(index, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttribPointerARB( GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid * pointer )
{
	crStateVertexAttribPointerARB( index, size, type, normalized, stride, pointer );
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttribPointerNV( GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer )
{
	crStateVertexAttribPointerNV( index, size, type, stride, pointer );
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttribs1dvNV( GLuint index, GLsizei n, const GLdouble * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttribs1dvNV(index, n, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttribs1dvNVSWAP(index, n, v);
	}
	else
	{
		crPackVertexAttribs1dvNV(index, n, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttribs1fvNV( GLuint index, GLsizei n, const GLfloat * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttribs1fvNV(index, n, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttribs1fvNVSWAP(index, n, v);
	}
	else
	{
		crPackVertexAttribs1fvNV(index, n, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttribs1svNV( GLuint index, GLsizei n, const GLshort * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttribs1svNV(index, n, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttribs1svNVSWAP(index, n, v);
	}
	else
	{
		crPackVertexAttribs1svNV(index, n, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttribs2dvNV( GLuint index, GLsizei n, const GLdouble * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttribs2dvNV(index, n, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttribs2dvNVSWAP(index, n, v);
	}
	else
	{
		crPackVertexAttribs2dvNV(index, n, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttribs2fvNV( GLuint index, GLsizei n, const GLfloat * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttribs2fvNV(index, n, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttribs2fvNVSWAP(index, n, v);
	}
	else
	{
		crPackVertexAttribs2fvNV(index, n, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttribs2svNV( GLuint index, GLsizei n, const GLshort * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttribs2svNV(index, n, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttribs2svNVSWAP(index, n, v);
	}
	else
	{
		crPackVertexAttribs2svNV(index, n, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttribs3dvNV( GLuint index, GLsizei n, const GLdouble * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttribs3dvNV(index, n, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttribs3dvNVSWAP(index, n, v);
	}
	else
	{
		crPackVertexAttribs3dvNV(index, n, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttribs3fvNV( GLuint index, GLsizei n, const GLfloat * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttribs3fvNV(index, n, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttribs3fvNVSWAP(index, n, v);
	}
	else
	{
		crPackVertexAttribs3fvNV(index, n, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttribs3svNV( GLuint index, GLsizei n, const GLshort * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttribs3svNV(index, n, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttribs3svNVSWAP(index, n, v);
	}
	else
	{
		crPackVertexAttribs3svNV(index, n, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttribs4dvNV( GLuint index, GLsizei n, const GLdouble * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttribs4dvNV(index, n, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttribs4dvNVSWAP(index, n, v);
	}
	else
	{
		crPackVertexAttribs4dvNV(index, n, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttribs4fvNV( GLuint index, GLsizei n, const GLfloat * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttribs4fvNV(index, n, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttribs4fvNVSWAP(index, n, v);
	}
	else
	{
		crPackVertexAttribs4fvNV(index, n, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttribs4svNV( GLuint index, GLsizei n, const GLshort * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttribs4svNV(index, n, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttribs4svNVSWAP(index, n, v);
	}
	else
	{
		crPackVertexAttribs4svNV(index, n, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexAttribs4ubvNV( GLuint index, GLsizei n, const GLubyte * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileVertexAttribs4ubvNV(index, n, v);
	}
	if (replicate_spu.swap)
	{
		crPackVertexAttribs4ubvNVSWAP(index, n, v);
	}
	else
	{
		crPackVertexAttribs4ubvNV(index, n, v);
	}
}

void REPLICATESPU_APIENTRY replicatespu_VertexPointer( GLint size, GLenum type, GLsizei stride, const GLvoid * pointer )
{
	crStateVertexPointer( size, type, stride, pointer );
}

void REPLICATESPU_APIENTRY replicatespu_Viewport( GLint x, GLint y, GLsizei width, GLsizei height )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileViewport(x, y, width, height);
	}
	if (replicate_spu.swap)
	{
		crPackViewportSWAP(x, y, width, height);
	}
	else
	{
		crPackViewport(x, y, width, height);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateViewport( x, y, width, height );
	}
}

/* WindowCreate not generated: special implementation exists */
/* WindowDestroy not generated: special implementation exists */

void REPLICATESPU_APIENTRY replicatespu_WindowPos2dARB( GLdouble x, GLdouble y )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileWindowPos2dARB(x, y);
	}
	if (replicate_spu.swap)
	{
		crPackWindowPos2dARBSWAP(x, y);
	}
	else
	{
		crPackWindowPos2dARB(x, y);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateWindowPos2dARB( x, y );
	}
}

void REPLICATESPU_APIENTRY replicatespu_WindowPos2dvARB( const GLdouble * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileWindowPos2dvARB(v);
	}
	if (replicate_spu.swap)
	{
		crPackWindowPos2dvARBSWAP(v);
	}
	else
	{
		crPackWindowPos2dvARB(v);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateWindowPos2dvARB( v );
	}
}

void REPLICATESPU_APIENTRY replicatespu_WindowPos2fARB( GLfloat x, GLfloat y )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileWindowPos2fARB(x, y);
	}
	if (replicate_spu.swap)
	{
		crPackWindowPos2fARBSWAP(x, y);
	}
	else
	{
		crPackWindowPos2fARB(x, y);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateWindowPos2fARB( x, y );
	}
}

void REPLICATESPU_APIENTRY replicatespu_WindowPos2fvARB( const GLfloat * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileWindowPos2fvARB(v);
	}
	if (replicate_spu.swap)
	{
		crPackWindowPos2fvARBSWAP(v);
	}
	else
	{
		crPackWindowPos2fvARB(v);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateWindowPos2fvARB( v );
	}
}

void REPLICATESPU_APIENTRY replicatespu_WindowPos2iARB( GLint x, GLint y )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileWindowPos2iARB(x, y);
	}
	if (replicate_spu.swap)
	{
		crPackWindowPos2iARBSWAP(x, y);
	}
	else
	{
		crPackWindowPos2iARB(x, y);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateWindowPos2iARB( x, y );
	}
}

void REPLICATESPU_APIENTRY replicatespu_WindowPos2ivARB( const GLint * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileWindowPos2ivARB(v);
	}
	if (replicate_spu.swap)
	{
		crPackWindowPos2ivARBSWAP(v);
	}
	else
	{
		crPackWindowPos2ivARB(v);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateWindowPos2ivARB( v );
	}
}

void REPLICATESPU_APIENTRY replicatespu_WindowPos2sARB( GLshort x, GLshort y )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileWindowPos2sARB(x, y);
	}
	if (replicate_spu.swap)
	{
		crPackWindowPos2sARBSWAP(x, y);
	}
	else
	{
		crPackWindowPos2sARB(x, y);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateWindowPos2sARB( x, y );
	}
}

void REPLICATESPU_APIENTRY replicatespu_WindowPos2svARB( const GLshort * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileWindowPos2svARB(v);
	}
	if (replicate_spu.swap)
	{
		crPackWindowPos2svARBSWAP(v);
	}
	else
	{
		crPackWindowPos2svARB(v);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateWindowPos2svARB( v );
	}
}

void REPLICATESPU_APIENTRY replicatespu_WindowPos3dARB( GLdouble x, GLdouble y, GLdouble z )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileWindowPos3dARB(x, y, z);
	}
	if (replicate_spu.swap)
	{
		crPackWindowPos3dARBSWAP(x, y, z);
	}
	else
	{
		crPackWindowPos3dARB(x, y, z);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateWindowPos3dARB( x, y, z );
	}
}

void REPLICATESPU_APIENTRY replicatespu_WindowPos3dvARB( const GLdouble * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileWindowPos3dvARB(v);
	}
	if (replicate_spu.swap)
	{
		crPackWindowPos3dvARBSWAP(v);
	}
	else
	{
		crPackWindowPos3dvARB(v);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateWindowPos3dvARB( v );
	}
}

void REPLICATESPU_APIENTRY replicatespu_WindowPos3fARB( GLfloat x, GLfloat y, GLfloat z )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileWindowPos3fARB(x, y, z);
	}
	if (replicate_spu.swap)
	{
		crPackWindowPos3fARBSWAP(x, y, z);
	}
	else
	{
		crPackWindowPos3fARB(x, y, z);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateWindowPos3fARB( x, y, z );
	}
}

void REPLICATESPU_APIENTRY replicatespu_WindowPos3fvARB( const GLfloat * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileWindowPos3fvARB(v);
	}
	if (replicate_spu.swap)
	{
		crPackWindowPos3fvARBSWAP(v);
	}
	else
	{
		crPackWindowPos3fvARB(v);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateWindowPos3fvARB( v );
	}
}

void REPLICATESPU_APIENTRY replicatespu_WindowPos3iARB( GLint x, GLint y, GLint z )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileWindowPos3iARB(x, y, z);
	}
	if (replicate_spu.swap)
	{
		crPackWindowPos3iARBSWAP(x, y, z);
	}
	else
	{
		crPackWindowPos3iARB(x, y, z);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateWindowPos3iARB( x, y, z );
	}
}

void REPLICATESPU_APIENTRY replicatespu_WindowPos3ivARB( const GLint * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileWindowPos3ivARB(v);
	}
	if (replicate_spu.swap)
	{
		crPackWindowPos3ivARBSWAP(v);
	}
	else
	{
		crPackWindowPos3ivARB(v);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateWindowPos3ivARB( v );
	}
}

void REPLICATESPU_APIENTRY replicatespu_WindowPos3sARB( GLshort x, GLshort y, GLshort z )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileWindowPos3sARB(x, y, z);
	}
	if (replicate_spu.swap)
	{
		crPackWindowPos3sARBSWAP(x, y, z);
	}
	else
	{
		crPackWindowPos3sARB(x, y, z);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateWindowPos3sARB( x, y, z );
	}
}

void REPLICATESPU_APIENTRY replicatespu_WindowPos3svARB( const GLshort * v )
{
	GET_THREAD(thread);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileWindowPos3svARB(v);
	}
	if (replicate_spu.swap)
	{
		crPackWindowPos3svARBSWAP(v);
	}
	else
	{
		crPackWindowPos3svARB(v);
	}
	if (thread->currentContext->displayListMode != GL_COMPILE) {
		crStateWindowPos3svARB( v );
	}
}

/* WindowPosition not generated: crPack implementation suffices */
/* WindowShow not generated: crPack implementation suffices */
/* WindowSize not generated: special implementation exists */
/* Writeback not generated: crPack implementation suffices */

void REPLICATESPU_APIENTRY replicatespu_ZPixCR( GLsizei width, GLsizei height, GLenum format, GLenum type, GLenum ztype, GLint zparm, GLint length, const GLvoid * pixels )
{
	GET_THREAD(thread);
	ContextInfo *ctx = thread->currentContext;
	CRClientState *clientState = &(ctx->State->client);
	if (thread->currentContext->displayListMode != GL_FALSE) {
		crDLMCompileZPixCR(width, height, format, type, ztype, zparm, length, pixels, clientState);
	}
	if (replicate_spu.swap)
	{
		crPackZPixCRSWAP(width, height, format, type, ztype, zparm, length, pixels, &(clientState->unpack));
	}
	else
	{
		crPackZPixCR(width, height, format, type, ztype, zparm, length, pixels, &(clientState->unpack));
	}
}

