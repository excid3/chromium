#include <stdio.h>
#include "cr_spu.h"
#include "cr_dlm.h"
#include "cr_mem.h"
#include "cr_error.h"
#include "dlm.h"
#include "dlm_dispatch.h"
#include "dlm_client.h"

/* DO NOT EDIT.  This file is auto-generated by dlm_dispatch.py. */

/* Following are all the auto-generated functions. */
	

/*** Accum ***/
static void DLM_APIENTRY passAccum(GLenum op, GLfloat value)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Accum(op, value);
}
static void DLM_APIENTRY executeAccum(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceAccum *instance = (struct instanceAccum *)x;
	dispatchTable->Accum(instance->op, instance->value);
}
void DLM_APIENTRY crdlm_compile_Accum( GLenum op, GLfloat value )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceAccum *instance;
	instance = crCalloc(sizeof(struct instanceAccum));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Accum to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeAccum;
	instance->op = op;
	instance->value = value;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** ActiveTextureARB ***/
static void DLM_APIENTRY passActiveTextureARB(GLenum texture)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ActiveTextureARB(texture);
}
static void DLM_APIENTRY executeActiveTextureARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceActiveTextureARB *instance = (struct instanceActiveTextureARB *)x;
	dispatchTable->ActiveTextureARB(instance->texture);
}
void DLM_APIENTRY crdlm_compile_ActiveTextureARB( GLenum texture )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceActiveTextureARB *instance;
	instance = crCalloc(sizeof(struct instanceActiveTextureARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding ActiveTextureARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeActiveTextureARB;
	instance->texture = texture;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** AlphaFunc ***/
static void DLM_APIENTRY passAlphaFunc(GLenum func, GLclampf ref)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.AlphaFunc(func, ref);
}
static void DLM_APIENTRY executeAlphaFunc(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceAlphaFunc *instance = (struct instanceAlphaFunc *)x;
	dispatchTable->AlphaFunc(instance->func, instance->ref);
}
void DLM_APIENTRY crdlm_compile_AlphaFunc( GLenum func, GLclampf ref )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceAlphaFunc *instance;
	instance = crCalloc(sizeof(struct instanceAlphaFunc));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding AlphaFunc to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeAlphaFunc;
	instance->func = func;
	instance->ref = ref;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** AreProgramsResidentNV ***/
static GLboolean DLM_APIENTRY passAreProgramsResidentNV(GLsizei n, const GLuint * ids, GLboolean * residences)
{
	CRDLMContextState *state = CURRENT_STATE();
	return state->savedDispatchTable.AreProgramsResidentNV(n, ids, residences);
}

/*** AreTexturesResident ***/
static GLboolean DLM_APIENTRY passAreTexturesResident(GLsizei n, const GLuint * textures, GLboolean * residences)
{
	CRDLMContextState *state = CURRENT_STATE();
	return state->savedDispatchTable.AreTexturesResident(n, textures, residences);
}

/*** ArrayElement ***/
static void DLM_APIENTRY passArrayElement(GLint i)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ArrayElement(i);
}

/*** BarrierCreateCR ***/
static void DLM_APIENTRY passBarrierCreateCR(GLuint name, GLuint count)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.BarrierCreateCR(name, count);
}

/*** BarrierDestroyCR ***/
static void DLM_APIENTRY passBarrierDestroyCR(GLuint name)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.BarrierDestroyCR(name);
}

/*** BarrierExecCR ***/
static void DLM_APIENTRY passBarrierExecCR(GLuint name)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.BarrierExecCR(name);
}

/*** Begin ***/
static void DLM_APIENTRY passBegin(GLenum mode)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Begin(mode);
}
static void DLM_APIENTRY executeBegin(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceBegin *instance = (struct instanceBegin *)x;
	dispatchTable->Begin(instance->mode);
}
void DLM_APIENTRY crdlm_compile_Begin( GLenum mode )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceBegin *instance;
	instance = crCalloc(sizeof(struct instanceBegin));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Begin to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeBegin;
	instance->mode = mode;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** BeginQueryARB ***/
static void DLM_APIENTRY passBeginQueryARB(GLenum target, GLuint id)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.BeginQueryARB(target, id);
}
static void DLM_APIENTRY executeBeginQueryARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceBeginQueryARB *instance = (struct instanceBeginQueryARB *)x;
	dispatchTable->BeginQueryARB(instance->target, instance->id);
}
void DLM_APIENTRY crdlm_compile_BeginQueryARB( GLenum target, GLuint id )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceBeginQueryARB *instance;
	instance = crCalloc(sizeof(struct instanceBeginQueryARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding BeginQueryARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeBeginQueryARB;
	instance->target = target;
	instance->id = id;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** BindBufferARB ***/
static void DLM_APIENTRY passBindBufferARB(GLenum target, GLuint buffer)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.BindBufferARB(target, buffer);
}

/*** BindProgramARB ***/
static void DLM_APIENTRY passBindProgramARB(GLenum target, GLuint program)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.BindProgramARB(target, program);
}
static void DLM_APIENTRY executeBindProgramARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceBindProgramARB *instance = (struct instanceBindProgramARB *)x;
	dispatchTable->BindProgramARB(instance->target, instance->program);
}
void DLM_APIENTRY crdlm_compile_BindProgramARB( GLenum target, GLuint program )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceBindProgramARB *instance;
	instance = crCalloc(sizeof(struct instanceBindProgramARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding BindProgramARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeBindProgramARB;
	instance->target = target;
	instance->program = program;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** BindProgramNV ***/
static void DLM_APIENTRY passBindProgramNV(GLenum target, GLuint id)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.BindProgramNV(target, id);
}
static void DLM_APIENTRY executeBindProgramNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceBindProgramNV *instance = (struct instanceBindProgramNV *)x;
	dispatchTable->BindProgramNV(instance->target, instance->id);
}
void DLM_APIENTRY crdlm_compile_BindProgramNV( GLenum target, GLuint id )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceBindProgramNV *instance;
	instance = crCalloc(sizeof(struct instanceBindProgramNV));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding BindProgramNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeBindProgramNV;
	instance->target = target;
	instance->id = id;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** BindTexture ***/
static void DLM_APIENTRY passBindTexture(GLenum target, GLuint texture)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.BindTexture(target, texture);
}
static void DLM_APIENTRY executeBindTexture(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceBindTexture *instance = (struct instanceBindTexture *)x;
	dispatchTable->BindTexture(instance->target, instance->texture);
}
void DLM_APIENTRY crdlm_compile_BindTexture( GLenum target, GLuint texture )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceBindTexture *instance;
	instance = crCalloc(sizeof(struct instanceBindTexture));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding BindTexture to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeBindTexture;
	instance->target = target;
	instance->texture = texture;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Bitmap ***/
static void DLM_APIENTRY passBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte * bitmap)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Bitmap(width, height, xorig, yorig, xmove, ymove, bitmap);
}
static void DLM_APIENTRY executeBitmap(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceBitmap *instance = (struct instanceBitmap *)x;
	dispatchTable->Bitmap(instance->width, instance->height, instance->xorig, instance->yorig, instance->xmove, instance->ymove, instance->bitmap);
}
void DLM_APIENTRY crdlm_compile_Bitmap( GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte * bitmap )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceBitmap *instance;
	instance = crCalloc(sizeof(struct instanceBitmap) + crdlm_pointers_Bitmap(NULL, width, height, xorig, yorig, xmove, ymove, bitmap));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Bitmap to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeBitmap;
	instance->width = width;
	instance->height = height;
	instance->xorig = xorig;
	instance->yorig = yorig;
	instance->xmove = xmove;
	instance->ymove = ymove;
	if (bitmap == NULL) {
		instance->bitmap = NULL;
	}
	else {
		instance->bitmap = instance->bitmapData;
	}
	(void) crdlm_pointers_Bitmap(instance, width, height, xorig, yorig, xmove, ymove, bitmap);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** BlendColorEXT ***/
static void DLM_APIENTRY passBlendColorEXT(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.BlendColorEXT(red, green, blue, alpha);
}
static void DLM_APIENTRY executeBlendColorEXT(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceBlendColorEXT *instance = (struct instanceBlendColorEXT *)x;
	dispatchTable->BlendColorEXT(instance->red, instance->green, instance->blue, instance->alpha);
}
void DLM_APIENTRY crdlm_compile_BlendColorEXT( GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceBlendColorEXT *instance;
	instance = crCalloc(sizeof(struct instanceBlendColorEXT));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding BlendColorEXT to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeBlendColorEXT;
	instance->red = red;
	instance->green = green;
	instance->blue = blue;
	instance->alpha = alpha;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** BlendEquationEXT ***/
static void DLM_APIENTRY passBlendEquationEXT(GLenum mode)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.BlendEquationEXT(mode);
}
static void DLM_APIENTRY executeBlendEquationEXT(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceBlendEquationEXT *instance = (struct instanceBlendEquationEXT *)x;
	dispatchTable->BlendEquationEXT(instance->mode);
}
void DLM_APIENTRY crdlm_compile_BlendEquationEXT( GLenum mode )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceBlendEquationEXT *instance;
	instance = crCalloc(sizeof(struct instanceBlendEquationEXT));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding BlendEquationEXT to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeBlendEquationEXT;
	instance->mode = mode;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** BlendFunc ***/
static void DLM_APIENTRY passBlendFunc(GLenum sfactor, GLenum dfactor)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.BlendFunc(sfactor, dfactor);
}
static void DLM_APIENTRY executeBlendFunc(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceBlendFunc *instance = (struct instanceBlendFunc *)x;
	dispatchTable->BlendFunc(instance->sfactor, instance->dfactor);
}
void DLM_APIENTRY crdlm_compile_BlendFunc( GLenum sfactor, GLenum dfactor )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceBlendFunc *instance;
	instance = crCalloc(sizeof(struct instanceBlendFunc));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding BlendFunc to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeBlendFunc;
	instance->sfactor = sfactor;
	instance->dfactor = dfactor;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** BlendFuncSeparateEXT ***/
static void DLM_APIENTRY passBlendFuncSeparateEXT(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorA, GLenum dfactorA)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.BlendFuncSeparateEXT(sfactorRGB, dfactorRGB, sfactorA, dfactorA);
}
static void DLM_APIENTRY executeBlendFuncSeparateEXT(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceBlendFuncSeparateEXT *instance = (struct instanceBlendFuncSeparateEXT *)x;
	dispatchTable->BlendFuncSeparateEXT(instance->sfactorRGB, instance->dfactorRGB, instance->sfactorA, instance->dfactorA);
}
void DLM_APIENTRY crdlm_compile_BlendFuncSeparateEXT( GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorA, GLenum dfactorA )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceBlendFuncSeparateEXT *instance;
	instance = crCalloc(sizeof(struct instanceBlendFuncSeparateEXT));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding BlendFuncSeparateEXT to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeBlendFuncSeparateEXT;
	instance->sfactorRGB = sfactorRGB;
	instance->dfactorRGB = dfactorRGB;
	instance->sfactorA = sfactorA;
	instance->dfactorA = dfactorA;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** BoundsInfoCR ***/
static void DLM_APIENTRY passBoundsInfoCR(const CRrecti * bounds, const GLbyte * payload, GLint len, GLint num_opcodes)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.BoundsInfoCR(bounds, payload, len, num_opcodes);
}

/*** BufferDataARB ***/
static void DLM_APIENTRY passBufferDataARB(GLenum target, GLsizeiptrARB size, const GLvoid * data, GLenum usage)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.BufferDataARB(target, size, data, usage);
}

/*** BufferSubDataARB ***/
static void DLM_APIENTRY passBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid * data)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.BufferSubDataARB(target, offset, size, data);
}

/*** CallList ***/
static void DLM_APIENTRY passCallList(GLuint list)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.CallList(list);
}
static void DLM_APIENTRY executeCallList(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceCallList *instance = (struct instanceCallList *)x;
	dispatchTable->CallList(instance->list);
}
void DLM_APIENTRY crdlm_compile_CallList( GLuint list )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceCallList *instance;
	instance = crCalloc(sizeof(struct instanceCallList));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding CallList to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeCallList;
	instance->list = list;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** CallLists ***/
static void DLM_APIENTRY passCallLists(GLsizei n, GLenum type, const GLvoid * lists)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.CallLists(n, type, lists);
}
static void DLM_APIENTRY executeCallLists(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceCallLists *instance = (struct instanceCallLists *)x;
	dispatchTable->CallLists(instance->n, instance->type, instance->lists);
}
void DLM_APIENTRY crdlm_compile_CallLists( GLsizei n, GLenum type, const GLvoid * lists )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceCallLists *instance;
	instance = crCalloc(sizeof(struct instanceCallLists) + crdlm_pointers_CallLists(NULL, n, type, lists));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding CallLists to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeCallLists;
	instance->n = n;
	instance->type = type;
	if (lists == NULL) {
		instance->lists = NULL;
	}
	else {
		instance->lists = instance->listsData;
	}
	(void) crdlm_pointers_CallLists(instance, n, type, lists);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** ChromiumParameterfCR ***/
static void DLM_APIENTRY passChromiumParameterfCR(GLenum target, GLfloat value)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ChromiumParameterfCR(target, value);
}

/*** ChromiumParameteriCR ***/
static void DLM_APIENTRY passChromiumParameteriCR(GLenum target, GLint value)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ChromiumParameteriCR(target, value);
}

/*** ChromiumParametervCR ***/
static void DLM_APIENTRY passChromiumParametervCR(GLenum target, GLenum type, GLsizei count, const GLvoid * values)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ChromiumParametervCR(target, type, count, values);
}

/*** Clear ***/
static void DLM_APIENTRY passClear(GLbitfield mask)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Clear(mask);
}
static void DLM_APIENTRY executeClear(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceClear *instance = (struct instanceClear *)x;
	dispatchTable->Clear(instance->mask);
}
void DLM_APIENTRY crdlm_compile_Clear( GLbitfield mask )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceClear *instance;
	instance = crCalloc(sizeof(struct instanceClear));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Clear to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeClear;
	instance->mask = mask;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** ClearAccum ***/
static void DLM_APIENTRY passClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ClearAccum(red, green, blue, alpha);
}
static void DLM_APIENTRY executeClearAccum(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceClearAccum *instance = (struct instanceClearAccum *)x;
	dispatchTable->ClearAccum(instance->red, instance->green, instance->blue, instance->alpha);
}
void DLM_APIENTRY crdlm_compile_ClearAccum( GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceClearAccum *instance;
	instance = crCalloc(sizeof(struct instanceClearAccum));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding ClearAccum to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeClearAccum;
	instance->red = red;
	instance->green = green;
	instance->blue = blue;
	instance->alpha = alpha;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** ClearColor ***/
static void DLM_APIENTRY passClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ClearColor(red, green, blue, alpha);
}
static void DLM_APIENTRY executeClearColor(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceClearColor *instance = (struct instanceClearColor *)x;
	dispatchTable->ClearColor(instance->red, instance->green, instance->blue, instance->alpha);
}
void DLM_APIENTRY crdlm_compile_ClearColor( GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceClearColor *instance;
	instance = crCalloc(sizeof(struct instanceClearColor));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding ClearColor to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeClearColor;
	instance->red = red;
	instance->green = green;
	instance->blue = blue;
	instance->alpha = alpha;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** ClearDepth ***/
static void DLM_APIENTRY passClearDepth(GLclampd depth)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ClearDepth(depth);
}
static void DLM_APIENTRY executeClearDepth(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceClearDepth *instance = (struct instanceClearDepth *)x;
	dispatchTable->ClearDepth(instance->depth);
}
void DLM_APIENTRY crdlm_compile_ClearDepth( GLclampd depth )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceClearDepth *instance;
	instance = crCalloc(sizeof(struct instanceClearDepth));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding ClearDepth to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeClearDepth;
	instance->depth = depth;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** ClearIndex ***/
static void DLM_APIENTRY passClearIndex(GLfloat c)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ClearIndex(c);
}
static void DLM_APIENTRY executeClearIndex(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceClearIndex *instance = (struct instanceClearIndex *)x;
	dispatchTable->ClearIndex(instance->c);
}
void DLM_APIENTRY crdlm_compile_ClearIndex( GLfloat c )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceClearIndex *instance;
	instance = crCalloc(sizeof(struct instanceClearIndex));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding ClearIndex to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeClearIndex;
	instance->c = c;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** ClearStencil ***/
static void DLM_APIENTRY passClearStencil(GLint s)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ClearStencil(s);
}
static void DLM_APIENTRY executeClearStencil(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceClearStencil *instance = (struct instanceClearStencil *)x;
	dispatchTable->ClearStencil(instance->s);
}
void DLM_APIENTRY crdlm_compile_ClearStencil( GLint s )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceClearStencil *instance;
	instance = crCalloc(sizeof(struct instanceClearStencil));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding ClearStencil to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeClearStencil;
	instance->s = s;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** ClientActiveTextureARB ***/
static void DLM_APIENTRY passClientActiveTextureARB(GLenum texture)
{
	CRDLMContextState *state = CURRENT_STATE();
	crdlmClientActiveTextureARB(texture, state->clientState);
	state->savedDispatchTable.ClientActiveTextureARB(texture);
}

/*** ClipPlane ***/
static void DLM_APIENTRY passClipPlane(GLenum plane, const GLdouble * equation)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ClipPlane(plane, equation);
}
static void DLM_APIENTRY executeClipPlane(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceClipPlane *instance = (struct instanceClipPlane *)x;
	dispatchTable->ClipPlane(instance->plane, instance->equation);
}
void DLM_APIENTRY crdlm_compile_ClipPlane( GLenum plane, const GLdouble * equation )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceClipPlane *instance;
	instance = crCalloc(sizeof(struct instanceClipPlane));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding ClipPlane to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeClipPlane;
	instance->plane = plane;
	if (equation == NULL) {
		instance->equation = NULL;
	}
	else {
		instance->equation = instance->equationData;
	}
	crMemcpy((void *)instance->equation, (void *) equation, 4*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Color3b ***/
static void DLM_APIENTRY passColor3b(GLbyte red, GLbyte green, GLbyte blue)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Color3b(red, green, blue);
}
static void DLM_APIENTRY executeColor3b(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceColor3b *instance = (struct instanceColor3b *)x;
	dispatchTable->Color3b(instance->red, instance->green, instance->blue);
}
void DLM_APIENTRY crdlm_compile_Color3b( GLbyte red, GLbyte green, GLbyte blue )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceColor3b *instance;
	instance = crCalloc(sizeof(struct instanceColor3b));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Color3b to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeColor3b;
	instance->red = red;
	instance->green = green;
	instance->blue = blue;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Color3bv ***/
static void DLM_APIENTRY passColor3bv(const GLbyte * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Color3bv(v);
}
static void DLM_APIENTRY executeColor3bv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceColor3bv *instance = (struct instanceColor3bv *)x;
	dispatchTable->Color3bv(instance->v);
}
void DLM_APIENTRY crdlm_compile_Color3bv( const GLbyte * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceColor3bv *instance;
	instance = crCalloc(sizeof(struct instanceColor3bv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Color3bv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeColor3bv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLbyte));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Color3d ***/
static void DLM_APIENTRY passColor3d(GLdouble red, GLdouble green, GLdouble blue)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Color3d(red, green, blue);
}
static void DLM_APIENTRY executeColor3d(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceColor3d *instance = (struct instanceColor3d *)x;
	dispatchTable->Color3d(instance->red, instance->green, instance->blue);
}
void DLM_APIENTRY crdlm_compile_Color3d( GLdouble red, GLdouble green, GLdouble blue )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceColor3d *instance;
	instance = crCalloc(sizeof(struct instanceColor3d));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Color3d to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeColor3d;
	instance->red = red;
	instance->green = green;
	instance->blue = blue;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Color3dv ***/
static void DLM_APIENTRY passColor3dv(const GLdouble * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Color3dv(v);
}
static void DLM_APIENTRY executeColor3dv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceColor3dv *instance = (struct instanceColor3dv *)x;
	dispatchTable->Color3dv(instance->v);
}
void DLM_APIENTRY crdlm_compile_Color3dv( const GLdouble * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceColor3dv *instance;
	instance = crCalloc(sizeof(struct instanceColor3dv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Color3dv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeColor3dv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Color3f ***/
static void DLM_APIENTRY passColor3f(GLfloat red, GLfloat green, GLfloat blue)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Color3f(red, green, blue);
}
static void DLM_APIENTRY executeColor3f(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceColor3f *instance = (struct instanceColor3f *)x;
	dispatchTable->Color3f(instance->red, instance->green, instance->blue);
}
void DLM_APIENTRY crdlm_compile_Color3f( GLfloat red, GLfloat green, GLfloat blue )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceColor3f *instance;
	instance = crCalloc(sizeof(struct instanceColor3f));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Color3f to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeColor3f;
	instance->red = red;
	instance->green = green;
	instance->blue = blue;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Color3fv ***/
static void DLM_APIENTRY passColor3fv(const GLfloat * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Color3fv(v);
}
static void DLM_APIENTRY executeColor3fv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceColor3fv *instance = (struct instanceColor3fv *)x;
	dispatchTable->Color3fv(instance->v);
}
void DLM_APIENTRY crdlm_compile_Color3fv( const GLfloat * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceColor3fv *instance;
	instance = crCalloc(sizeof(struct instanceColor3fv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Color3fv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeColor3fv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Color3i ***/
static void DLM_APIENTRY passColor3i(GLint red, GLint green, GLint blue)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Color3i(red, green, blue);
}
static void DLM_APIENTRY executeColor3i(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceColor3i *instance = (struct instanceColor3i *)x;
	dispatchTable->Color3i(instance->red, instance->green, instance->blue);
}
void DLM_APIENTRY crdlm_compile_Color3i( GLint red, GLint green, GLint blue )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceColor3i *instance;
	instance = crCalloc(sizeof(struct instanceColor3i));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Color3i to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeColor3i;
	instance->red = red;
	instance->green = green;
	instance->blue = blue;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Color3iv ***/
static void DLM_APIENTRY passColor3iv(const GLint * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Color3iv(v);
}
static void DLM_APIENTRY executeColor3iv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceColor3iv *instance = (struct instanceColor3iv *)x;
	dispatchTable->Color3iv(instance->v);
}
void DLM_APIENTRY crdlm_compile_Color3iv( const GLint * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceColor3iv *instance;
	instance = crCalloc(sizeof(struct instanceColor3iv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Color3iv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeColor3iv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLint));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Color3s ***/
static void DLM_APIENTRY passColor3s(GLshort red, GLshort green, GLshort blue)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Color3s(red, green, blue);
}
static void DLM_APIENTRY executeColor3s(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceColor3s *instance = (struct instanceColor3s *)x;
	dispatchTable->Color3s(instance->red, instance->green, instance->blue);
}
void DLM_APIENTRY crdlm_compile_Color3s( GLshort red, GLshort green, GLshort blue )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceColor3s *instance;
	instance = crCalloc(sizeof(struct instanceColor3s));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Color3s to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeColor3s;
	instance->red = red;
	instance->green = green;
	instance->blue = blue;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Color3sv ***/
static void DLM_APIENTRY passColor3sv(const GLshort * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Color3sv(v);
}
static void DLM_APIENTRY executeColor3sv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceColor3sv *instance = (struct instanceColor3sv *)x;
	dispatchTable->Color3sv(instance->v);
}
void DLM_APIENTRY crdlm_compile_Color3sv( const GLshort * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceColor3sv *instance;
	instance = crCalloc(sizeof(struct instanceColor3sv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Color3sv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeColor3sv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLshort));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Color3ub ***/
static void DLM_APIENTRY passColor3ub(GLubyte red, GLubyte green, GLubyte blue)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Color3ub(red, green, blue);
}
static void DLM_APIENTRY executeColor3ub(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceColor3ub *instance = (struct instanceColor3ub *)x;
	dispatchTable->Color3ub(instance->red, instance->green, instance->blue);
}
void DLM_APIENTRY crdlm_compile_Color3ub( GLubyte red, GLubyte green, GLubyte blue )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceColor3ub *instance;
	instance = crCalloc(sizeof(struct instanceColor3ub));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Color3ub to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeColor3ub;
	instance->red = red;
	instance->green = green;
	instance->blue = blue;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Color3ubv ***/
static void DLM_APIENTRY passColor3ubv(const GLubyte * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Color3ubv(v);
}
static void DLM_APIENTRY executeColor3ubv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceColor3ubv *instance = (struct instanceColor3ubv *)x;
	dispatchTable->Color3ubv(instance->v);
}
void DLM_APIENTRY crdlm_compile_Color3ubv( const GLubyte * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceColor3ubv *instance;
	instance = crCalloc(sizeof(struct instanceColor3ubv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Color3ubv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeColor3ubv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLubyte));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Color3ui ***/
static void DLM_APIENTRY passColor3ui(GLuint red, GLuint green, GLuint blue)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Color3ui(red, green, blue);
}
static void DLM_APIENTRY executeColor3ui(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceColor3ui *instance = (struct instanceColor3ui *)x;
	dispatchTable->Color3ui(instance->red, instance->green, instance->blue);
}
void DLM_APIENTRY crdlm_compile_Color3ui( GLuint red, GLuint green, GLuint blue )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceColor3ui *instance;
	instance = crCalloc(sizeof(struct instanceColor3ui));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Color3ui to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeColor3ui;
	instance->red = red;
	instance->green = green;
	instance->blue = blue;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Color3uiv ***/
static void DLM_APIENTRY passColor3uiv(const GLuint * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Color3uiv(v);
}
static void DLM_APIENTRY executeColor3uiv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceColor3uiv *instance = (struct instanceColor3uiv *)x;
	dispatchTable->Color3uiv(instance->v);
}
void DLM_APIENTRY crdlm_compile_Color3uiv( const GLuint * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceColor3uiv *instance;
	instance = crCalloc(sizeof(struct instanceColor3uiv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Color3uiv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeColor3uiv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLuint));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Color3us ***/
static void DLM_APIENTRY passColor3us(GLushort red, GLushort green, GLushort blue)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Color3us(red, green, blue);
}
static void DLM_APIENTRY executeColor3us(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceColor3us *instance = (struct instanceColor3us *)x;
	dispatchTable->Color3us(instance->red, instance->green, instance->blue);
}
void DLM_APIENTRY crdlm_compile_Color3us( GLushort red, GLushort green, GLushort blue )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceColor3us *instance;
	instance = crCalloc(sizeof(struct instanceColor3us));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Color3us to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeColor3us;
	instance->red = red;
	instance->green = green;
	instance->blue = blue;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Color3usv ***/
static void DLM_APIENTRY passColor3usv(const GLushort * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Color3usv(v);
}
static void DLM_APIENTRY executeColor3usv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceColor3usv *instance = (struct instanceColor3usv *)x;
	dispatchTable->Color3usv(instance->v);
}
void DLM_APIENTRY crdlm_compile_Color3usv( const GLushort * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceColor3usv *instance;
	instance = crCalloc(sizeof(struct instanceColor3usv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Color3usv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeColor3usv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLushort));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Color4b ***/
static void DLM_APIENTRY passColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Color4b(red, green, blue, alpha);
}
static void DLM_APIENTRY executeColor4b(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceColor4b *instance = (struct instanceColor4b *)x;
	dispatchTable->Color4b(instance->red, instance->green, instance->blue, instance->alpha);
}
void DLM_APIENTRY crdlm_compile_Color4b( GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceColor4b *instance;
	instance = crCalloc(sizeof(struct instanceColor4b));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Color4b to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeColor4b;
	instance->red = red;
	instance->green = green;
	instance->blue = blue;
	instance->alpha = alpha;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Color4bv ***/
static void DLM_APIENTRY passColor4bv(const GLbyte * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Color4bv(v);
}
static void DLM_APIENTRY executeColor4bv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceColor4bv *instance = (struct instanceColor4bv *)x;
	dispatchTable->Color4bv(instance->v);
}
void DLM_APIENTRY crdlm_compile_Color4bv( const GLbyte * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceColor4bv *instance;
	instance = crCalloc(sizeof(struct instanceColor4bv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Color4bv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeColor4bv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 4*sizeof(GLbyte));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Color4d ***/
static void DLM_APIENTRY passColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Color4d(red, green, blue, alpha);
}
static void DLM_APIENTRY executeColor4d(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceColor4d *instance = (struct instanceColor4d *)x;
	dispatchTable->Color4d(instance->red, instance->green, instance->blue, instance->alpha);
}
void DLM_APIENTRY crdlm_compile_Color4d( GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceColor4d *instance;
	instance = crCalloc(sizeof(struct instanceColor4d));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Color4d to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeColor4d;
	instance->red = red;
	instance->green = green;
	instance->blue = blue;
	instance->alpha = alpha;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Color4dv ***/
static void DLM_APIENTRY passColor4dv(const GLdouble * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Color4dv(v);
}
static void DLM_APIENTRY executeColor4dv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceColor4dv *instance = (struct instanceColor4dv *)x;
	dispatchTable->Color4dv(instance->v);
}
void DLM_APIENTRY crdlm_compile_Color4dv( const GLdouble * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceColor4dv *instance;
	instance = crCalloc(sizeof(struct instanceColor4dv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Color4dv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeColor4dv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 4*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Color4f ***/
static void DLM_APIENTRY passColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Color4f(red, green, blue, alpha);
}
static void DLM_APIENTRY executeColor4f(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceColor4f *instance = (struct instanceColor4f *)x;
	dispatchTable->Color4f(instance->red, instance->green, instance->blue, instance->alpha);
}
void DLM_APIENTRY crdlm_compile_Color4f( GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceColor4f *instance;
	instance = crCalloc(sizeof(struct instanceColor4f));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Color4f to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeColor4f;
	instance->red = red;
	instance->green = green;
	instance->blue = blue;
	instance->alpha = alpha;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Color4fv ***/
static void DLM_APIENTRY passColor4fv(const GLfloat * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Color4fv(v);
}
static void DLM_APIENTRY executeColor4fv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceColor4fv *instance = (struct instanceColor4fv *)x;
	dispatchTable->Color4fv(instance->v);
}
void DLM_APIENTRY crdlm_compile_Color4fv( const GLfloat * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceColor4fv *instance;
	instance = crCalloc(sizeof(struct instanceColor4fv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Color4fv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeColor4fv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 4*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Color4i ***/
static void DLM_APIENTRY passColor4i(GLint red, GLint green, GLint blue, GLint alpha)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Color4i(red, green, blue, alpha);
}
static void DLM_APIENTRY executeColor4i(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceColor4i *instance = (struct instanceColor4i *)x;
	dispatchTable->Color4i(instance->red, instance->green, instance->blue, instance->alpha);
}
void DLM_APIENTRY crdlm_compile_Color4i( GLint red, GLint green, GLint blue, GLint alpha )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceColor4i *instance;
	instance = crCalloc(sizeof(struct instanceColor4i));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Color4i to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeColor4i;
	instance->red = red;
	instance->green = green;
	instance->blue = blue;
	instance->alpha = alpha;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Color4iv ***/
static void DLM_APIENTRY passColor4iv(const GLint * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Color4iv(v);
}
static void DLM_APIENTRY executeColor4iv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceColor4iv *instance = (struct instanceColor4iv *)x;
	dispatchTable->Color4iv(instance->v);
}
void DLM_APIENTRY crdlm_compile_Color4iv( const GLint * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceColor4iv *instance;
	instance = crCalloc(sizeof(struct instanceColor4iv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Color4iv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeColor4iv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 4*sizeof(GLint));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Color4s ***/
static void DLM_APIENTRY passColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Color4s(red, green, blue, alpha);
}
static void DLM_APIENTRY executeColor4s(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceColor4s *instance = (struct instanceColor4s *)x;
	dispatchTable->Color4s(instance->red, instance->green, instance->blue, instance->alpha);
}
void DLM_APIENTRY crdlm_compile_Color4s( GLshort red, GLshort green, GLshort blue, GLshort alpha )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceColor4s *instance;
	instance = crCalloc(sizeof(struct instanceColor4s));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Color4s to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeColor4s;
	instance->red = red;
	instance->green = green;
	instance->blue = blue;
	instance->alpha = alpha;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Color4sv ***/
static void DLM_APIENTRY passColor4sv(const GLshort * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Color4sv(v);
}
static void DLM_APIENTRY executeColor4sv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceColor4sv *instance = (struct instanceColor4sv *)x;
	dispatchTable->Color4sv(instance->v);
}
void DLM_APIENTRY crdlm_compile_Color4sv( const GLshort * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceColor4sv *instance;
	instance = crCalloc(sizeof(struct instanceColor4sv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Color4sv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeColor4sv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 4*sizeof(GLshort));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Color4ub ***/
static void DLM_APIENTRY passColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Color4ub(red, green, blue, alpha);
}
static void DLM_APIENTRY executeColor4ub(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceColor4ub *instance = (struct instanceColor4ub *)x;
	dispatchTable->Color4ub(instance->red, instance->green, instance->blue, instance->alpha);
}
void DLM_APIENTRY crdlm_compile_Color4ub( GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceColor4ub *instance;
	instance = crCalloc(sizeof(struct instanceColor4ub));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Color4ub to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeColor4ub;
	instance->red = red;
	instance->green = green;
	instance->blue = blue;
	instance->alpha = alpha;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Color4ubv ***/
static void DLM_APIENTRY passColor4ubv(const GLubyte * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Color4ubv(v);
}
static void DLM_APIENTRY executeColor4ubv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceColor4ubv *instance = (struct instanceColor4ubv *)x;
	dispatchTable->Color4ubv(instance->v);
}
void DLM_APIENTRY crdlm_compile_Color4ubv( const GLubyte * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceColor4ubv *instance;
	instance = crCalloc(sizeof(struct instanceColor4ubv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Color4ubv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeColor4ubv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 4*sizeof(GLubyte));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Color4ui ***/
static void DLM_APIENTRY passColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Color4ui(red, green, blue, alpha);
}
static void DLM_APIENTRY executeColor4ui(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceColor4ui *instance = (struct instanceColor4ui *)x;
	dispatchTable->Color4ui(instance->red, instance->green, instance->blue, instance->alpha);
}
void DLM_APIENTRY crdlm_compile_Color4ui( GLuint red, GLuint green, GLuint blue, GLuint alpha )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceColor4ui *instance;
	instance = crCalloc(sizeof(struct instanceColor4ui));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Color4ui to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeColor4ui;
	instance->red = red;
	instance->green = green;
	instance->blue = blue;
	instance->alpha = alpha;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Color4uiv ***/
static void DLM_APIENTRY passColor4uiv(const GLuint * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Color4uiv(v);
}
static void DLM_APIENTRY executeColor4uiv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceColor4uiv *instance = (struct instanceColor4uiv *)x;
	dispatchTable->Color4uiv(instance->v);
}
void DLM_APIENTRY crdlm_compile_Color4uiv( const GLuint * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceColor4uiv *instance;
	instance = crCalloc(sizeof(struct instanceColor4uiv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Color4uiv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeColor4uiv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 4*sizeof(GLuint));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Color4us ***/
static void DLM_APIENTRY passColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Color4us(red, green, blue, alpha);
}
static void DLM_APIENTRY executeColor4us(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceColor4us *instance = (struct instanceColor4us *)x;
	dispatchTable->Color4us(instance->red, instance->green, instance->blue, instance->alpha);
}
void DLM_APIENTRY crdlm_compile_Color4us( GLushort red, GLushort green, GLushort blue, GLushort alpha )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceColor4us *instance;
	instance = crCalloc(sizeof(struct instanceColor4us));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Color4us to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeColor4us;
	instance->red = red;
	instance->green = green;
	instance->blue = blue;
	instance->alpha = alpha;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Color4usv ***/
static void DLM_APIENTRY passColor4usv(const GLushort * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Color4usv(v);
}
static void DLM_APIENTRY executeColor4usv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceColor4usv *instance = (struct instanceColor4usv *)x;
	dispatchTable->Color4usv(instance->v);
}
void DLM_APIENTRY crdlm_compile_Color4usv( const GLushort * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceColor4usv *instance;
	instance = crCalloc(sizeof(struct instanceColor4usv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Color4usv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeColor4usv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 4*sizeof(GLushort));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** ColorMask ***/
static void DLM_APIENTRY passColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ColorMask(red, green, blue, alpha);
}
static void DLM_APIENTRY executeColorMask(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceColorMask *instance = (struct instanceColorMask *)x;
	dispatchTable->ColorMask(instance->red, instance->green, instance->blue, instance->alpha);
}
void DLM_APIENTRY crdlm_compile_ColorMask( GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceColorMask *instance;
	instance = crCalloc(sizeof(struct instanceColorMask));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding ColorMask to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeColorMask;
	instance->red = red;
	instance->green = green;
	instance->blue = blue;
	instance->alpha = alpha;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** ColorMaterial ***/
static void DLM_APIENTRY passColorMaterial(GLenum face, GLenum mode)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ColorMaterial(face, mode);
}
static void DLM_APIENTRY executeColorMaterial(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceColorMaterial *instance = (struct instanceColorMaterial *)x;
	dispatchTable->ColorMaterial(instance->face, instance->mode);
}
void DLM_APIENTRY crdlm_compile_ColorMaterial( GLenum face, GLenum mode )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceColorMaterial *instance;
	instance = crCalloc(sizeof(struct instanceColorMaterial));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding ColorMaterial to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeColorMaterial;
	instance->face = face;
	instance->mode = mode;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** ColorPointer ***/
static void DLM_APIENTRY passColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer)
{
	CRDLMContextState *state = CURRENT_STATE();
	crdlmColorPointer(size, type, stride, pointer, state->clientState);
	state->savedDispatchTable.ColorPointer(size, type, stride, pointer);
}

/*** CombinerInputNV ***/
static void DLM_APIENTRY passCombinerInputNV(GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.CombinerInputNV(stage, portion, variable, input, mapping, componentUsage);
}
static void DLM_APIENTRY executeCombinerInputNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceCombinerInputNV *instance = (struct instanceCombinerInputNV *)x;
	dispatchTable->CombinerInputNV(instance->stage, instance->portion, instance->variable, instance->input, instance->mapping, instance->componentUsage);
}
void DLM_APIENTRY crdlm_compile_CombinerInputNV( GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceCombinerInputNV *instance;
	instance = crCalloc(sizeof(struct instanceCombinerInputNV));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding CombinerInputNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeCombinerInputNV;
	instance->stage = stage;
	instance->portion = portion;
	instance->variable = variable;
	instance->input = input;
	instance->mapping = mapping;
	instance->componentUsage = componentUsage;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** CombinerOutputNV ***/
static void DLM_APIENTRY passCombinerOutputNV(GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.CombinerOutputNV(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum);
}
static void DLM_APIENTRY executeCombinerOutputNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceCombinerOutputNV *instance = (struct instanceCombinerOutputNV *)x;
	dispatchTable->CombinerOutputNV(instance->stage, instance->portion, instance->abOutput, instance->cdOutput, instance->sumOutput, instance->scale, instance->bias, instance->abDotProduct, instance->cdDotProduct, instance->muxSum);
}
void DLM_APIENTRY crdlm_compile_CombinerOutputNV( GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceCombinerOutputNV *instance;
	instance = crCalloc(sizeof(struct instanceCombinerOutputNV));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding CombinerOutputNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeCombinerOutputNV;
	instance->stage = stage;
	instance->portion = portion;
	instance->abOutput = abOutput;
	instance->cdOutput = cdOutput;
	instance->sumOutput = sumOutput;
	instance->scale = scale;
	instance->bias = bias;
	instance->abDotProduct = abDotProduct;
	instance->cdDotProduct = cdDotProduct;
	instance->muxSum = muxSum;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** CombinerParameterfNV ***/
static void DLM_APIENTRY passCombinerParameterfNV(GLenum pname, GLfloat param)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.CombinerParameterfNV(pname, param);
}
static void DLM_APIENTRY executeCombinerParameterfNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceCombinerParameterfNV *instance = (struct instanceCombinerParameterfNV *)x;
	dispatchTable->CombinerParameterfNV(instance->pname, instance->param);
}
void DLM_APIENTRY crdlm_compile_CombinerParameterfNV( GLenum pname, GLfloat param )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceCombinerParameterfNV *instance;
	instance = crCalloc(sizeof(struct instanceCombinerParameterfNV));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding CombinerParameterfNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeCombinerParameterfNV;
	instance->pname = pname;
	instance->param = param;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** CombinerParameterfvNV ***/
static void DLM_APIENTRY passCombinerParameterfvNV(GLenum pname, const GLfloat * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.CombinerParameterfvNV(pname, params);
}
static void DLM_APIENTRY executeCombinerParameterfvNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceCombinerParameterfvNV *instance = (struct instanceCombinerParameterfvNV *)x;
	dispatchTable->CombinerParameterfvNV(instance->pname, instance->params);
}
void DLM_APIENTRY crdlm_compile_CombinerParameterfvNV( GLenum pname, const GLfloat * params )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceCombinerParameterfvNV *instance;
	instance = crCalloc(sizeof(struct instanceCombinerParameterfvNV) + crdlm_pointers_CombinerParameterfvNV(NULL, pname, params));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding CombinerParameterfvNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeCombinerParameterfvNV;
	instance->pname = pname;
	if (params == NULL) {
		instance->params = NULL;
	}
	else {
		instance->params = instance->paramsData;
	}
	(void) crdlm_pointers_CombinerParameterfvNV(instance, pname, params);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** CombinerParameteriNV ***/
static void DLM_APIENTRY passCombinerParameteriNV(GLenum pname, GLint param)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.CombinerParameteriNV(pname, param);
}
static void DLM_APIENTRY executeCombinerParameteriNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceCombinerParameteriNV *instance = (struct instanceCombinerParameteriNV *)x;
	dispatchTable->CombinerParameteriNV(instance->pname, instance->param);
}
void DLM_APIENTRY crdlm_compile_CombinerParameteriNV( GLenum pname, GLint param )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceCombinerParameteriNV *instance;
	instance = crCalloc(sizeof(struct instanceCombinerParameteriNV));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding CombinerParameteriNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeCombinerParameteriNV;
	instance->pname = pname;
	instance->param = param;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** CombinerParameterivNV ***/
static void DLM_APIENTRY passCombinerParameterivNV(GLenum pname, const GLint * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.CombinerParameterivNV(pname, params);
}
static void DLM_APIENTRY executeCombinerParameterivNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceCombinerParameterivNV *instance = (struct instanceCombinerParameterivNV *)x;
	dispatchTable->CombinerParameterivNV(instance->pname, instance->params);
}
void DLM_APIENTRY crdlm_compile_CombinerParameterivNV( GLenum pname, const GLint * params )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceCombinerParameterivNV *instance;
	instance = crCalloc(sizeof(struct instanceCombinerParameterivNV) + crdlm_pointers_CombinerParameterivNV(NULL, pname, params));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding CombinerParameterivNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeCombinerParameterivNV;
	instance->pname = pname;
	if (params == NULL) {
		instance->params = NULL;
	}
	else {
		instance->params = instance->paramsData;
	}
	(void) crdlm_pointers_CombinerParameterivNV(instance, pname, params);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** CombinerStageParameterfvNV ***/
static void DLM_APIENTRY passCombinerStageParameterfvNV(GLenum stage, GLenum pname, const GLfloat * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.CombinerStageParameterfvNV(stage, pname, params);
}
static void DLM_APIENTRY executeCombinerStageParameterfvNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceCombinerStageParameterfvNV *instance = (struct instanceCombinerStageParameterfvNV *)x;
	dispatchTable->CombinerStageParameterfvNV(instance->stage, instance->pname, instance->params);
}
void DLM_APIENTRY crdlm_compile_CombinerStageParameterfvNV( GLenum stage, GLenum pname, const GLfloat * params )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceCombinerStageParameterfvNV *instance;
	instance = crCalloc(sizeof(struct instanceCombinerStageParameterfvNV) + crdlm_pointers_CombinerStageParameterfvNV(NULL, stage, pname, params));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding CombinerStageParameterfvNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeCombinerStageParameterfvNV;
	instance->stage = stage;
	instance->pname = pname;
	if (params == NULL) {
		instance->params = NULL;
	}
	else {
		instance->params = instance->paramsData;
	}
	(void) crdlm_pointers_CombinerStageParameterfvNV(instance, stage, pname, params);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** CompressedTexImage1DARB ***/
static void DLM_APIENTRY passCompressedTexImage1DARB(GLenum target, GLint level, GLenum internalFormat, GLsizei width, GLint border, GLsizei imagesize, const GLvoid * data)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.CompressedTexImage1DARB(target, level, internalFormat, width, border, imagesize, data);
}
static void DLM_APIENTRY executeCompressedTexImage1DARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceCompressedTexImage1DARB *instance = (struct instanceCompressedTexImage1DARB *)x;
	dispatchTable->CompressedTexImage1DARB(instance->target, instance->level, instance->internalFormat, instance->width, instance->border, instance->imagesize, instance->data);
}
void DLM_APIENTRY crdlm_compile_CompressedTexImage1DARB( GLenum target, GLint level, GLenum internalFormat, GLsizei width, GLint border, GLsizei imagesize, const GLvoid * data )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceCompressedTexImage1DARB *instance;
	if (crdlm_checkpass_CompressedTexImage1DARB(target, level, internalFormat, width, border, imagesize, data)) {
		passCompressedTexImage1DARB(target, level, internalFormat, width, border, imagesize, data);
		return;
	}
	instance = crCalloc(sizeof(struct instanceCompressedTexImage1DARB) + crdlm_pointers_CompressedTexImage1DARB(NULL, target, level, internalFormat, width, border, imagesize, data));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding CompressedTexImage1DARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeCompressedTexImage1DARB;
	instance->target = target;
	instance->level = level;
	instance->internalFormat = internalFormat;
	instance->width = width;
	instance->border = border;
	instance->imagesize = imagesize;
	if (data == NULL) {
		instance->data = NULL;
	}
	else {
		instance->data = instance->dataData;
	}
	(void) crdlm_pointers_CompressedTexImage1DARB(instance, target, level, internalFormat, width, border, imagesize, data);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** CompressedTexImage2DARB ***/
static void DLM_APIENTRY passCompressedTexImage2DARB(GLenum target, GLint level, GLenum internalFormat, GLsizei width, GLsizei height, GLint border, GLsizei imagesize, const GLvoid * data)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.CompressedTexImage2DARB(target, level, internalFormat, width, height, border, imagesize, data);
}
static void DLM_APIENTRY executeCompressedTexImage2DARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceCompressedTexImage2DARB *instance = (struct instanceCompressedTexImage2DARB *)x;
	dispatchTable->CompressedTexImage2DARB(instance->target, instance->level, instance->internalFormat, instance->width, instance->height, instance->border, instance->imagesize, instance->data);
}
void DLM_APIENTRY crdlm_compile_CompressedTexImage2DARB( GLenum target, GLint level, GLenum internalFormat, GLsizei width, GLsizei height, GLint border, GLsizei imagesize, const GLvoid * data )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceCompressedTexImage2DARB *instance;
	if (crdlm_checkpass_CompressedTexImage2DARB(target, level, internalFormat, width, height, border, imagesize, data)) {
		passCompressedTexImage2DARB(target, level, internalFormat, width, height, border, imagesize, data);
		return;
	}
	instance = crCalloc(sizeof(struct instanceCompressedTexImage2DARB) + crdlm_pointers_CompressedTexImage2DARB(NULL, target, level, internalFormat, width, height, border, imagesize, data));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding CompressedTexImage2DARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeCompressedTexImage2DARB;
	instance->target = target;
	instance->level = level;
	instance->internalFormat = internalFormat;
	instance->width = width;
	instance->height = height;
	instance->border = border;
	instance->imagesize = imagesize;
	if (data == NULL) {
		instance->data = NULL;
	}
	else {
		instance->data = instance->dataData;
	}
	(void) crdlm_pointers_CompressedTexImage2DARB(instance, target, level, internalFormat, width, height, border, imagesize, data);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** CompressedTexImage3DARB ***/
static void DLM_APIENTRY passCompressedTexImage3DARB(GLenum target, GLint level, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imagesize, const GLvoid * data)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.CompressedTexImage3DARB(target, level, internalFormat, width, height, depth, border, imagesize, data);
}
static void DLM_APIENTRY executeCompressedTexImage3DARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceCompressedTexImage3DARB *instance = (struct instanceCompressedTexImage3DARB *)x;
	dispatchTable->CompressedTexImage3DARB(instance->target, instance->level, instance->internalFormat, instance->width, instance->height, instance->depth, instance->border, instance->imagesize, instance->data);
}
void DLM_APIENTRY crdlm_compile_CompressedTexImage3DARB( GLenum target, GLint level, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imagesize, const GLvoid * data )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceCompressedTexImage3DARB *instance;
	if (crdlm_checkpass_CompressedTexImage3DARB(target, level, internalFormat, width, height, depth, border, imagesize, data)) {
		passCompressedTexImage3DARB(target, level, internalFormat, width, height, depth, border, imagesize, data);
		return;
	}
	instance = crCalloc(sizeof(struct instanceCompressedTexImage3DARB) + crdlm_pointers_CompressedTexImage3DARB(NULL, target, level, internalFormat, width, height, depth, border, imagesize, data));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding CompressedTexImage3DARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeCompressedTexImage3DARB;
	instance->target = target;
	instance->level = level;
	instance->internalFormat = internalFormat;
	instance->width = width;
	instance->height = height;
	instance->depth = depth;
	instance->border = border;
	instance->imagesize = imagesize;
	if (data == NULL) {
		instance->data = NULL;
	}
	else {
		instance->data = instance->dataData;
	}
	(void) crdlm_pointers_CompressedTexImage3DARB(instance, target, level, internalFormat, width, height, depth, border, imagesize, data);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** CompressedTexSubImage1DARB ***/
static void DLM_APIENTRY passCompressedTexSubImage1DARB(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imagesize, const GLvoid * data)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.CompressedTexSubImage1DARB(target, level, xoffset, width, format, imagesize, data);
}
static void DLM_APIENTRY executeCompressedTexSubImage1DARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceCompressedTexSubImage1DARB *instance = (struct instanceCompressedTexSubImage1DARB *)x;
	dispatchTable->CompressedTexSubImage1DARB(instance->target, instance->level, instance->xoffset, instance->width, instance->format, instance->imagesize, instance->data);
}
void DLM_APIENTRY crdlm_compile_CompressedTexSubImage1DARB( GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imagesize, const GLvoid * data )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceCompressedTexSubImage1DARB *instance;
	instance = crCalloc(sizeof(struct instanceCompressedTexSubImage1DARB) + crdlm_pointers_CompressedTexSubImage1DARB(NULL, target, level, xoffset, width, format, imagesize, data));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding CompressedTexSubImage1DARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeCompressedTexSubImage1DARB;
	instance->target = target;
	instance->level = level;
	instance->xoffset = xoffset;
	instance->width = width;
	instance->format = format;
	instance->imagesize = imagesize;
	if (data == NULL) {
		instance->data = NULL;
	}
	else {
		instance->data = instance->dataData;
	}
	(void) crdlm_pointers_CompressedTexSubImage1DARB(instance, target, level, xoffset, width, format, imagesize, data);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** CompressedTexSubImage2DARB ***/
static void DLM_APIENTRY passCompressedTexSubImage2DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imagesize, const GLvoid * data)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.CompressedTexSubImage2DARB(target, level, xoffset, yoffset, width, height, format, imagesize, data);
}
static void DLM_APIENTRY executeCompressedTexSubImage2DARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceCompressedTexSubImage2DARB *instance = (struct instanceCompressedTexSubImage2DARB *)x;
	dispatchTable->CompressedTexSubImage2DARB(instance->target, instance->level, instance->xoffset, instance->yoffset, instance->width, instance->height, instance->format, instance->imagesize, instance->data);
}
void DLM_APIENTRY crdlm_compile_CompressedTexSubImage2DARB( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imagesize, const GLvoid * data )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceCompressedTexSubImage2DARB *instance;
	instance = crCalloc(sizeof(struct instanceCompressedTexSubImage2DARB) + crdlm_pointers_CompressedTexSubImage2DARB(NULL, target, level, xoffset, yoffset, width, height, format, imagesize, data));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding CompressedTexSubImage2DARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeCompressedTexSubImage2DARB;
	instance->target = target;
	instance->level = level;
	instance->xoffset = xoffset;
	instance->yoffset = yoffset;
	instance->width = width;
	instance->height = height;
	instance->format = format;
	instance->imagesize = imagesize;
	if (data == NULL) {
		instance->data = NULL;
	}
	else {
		instance->data = instance->dataData;
	}
	(void) crdlm_pointers_CompressedTexSubImage2DARB(instance, target, level, xoffset, yoffset, width, height, format, imagesize, data);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** CompressedTexSubImage3DARB ***/
static void DLM_APIENTRY passCompressedTexSubImage3DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imagesize, const GLvoid * data)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.CompressedTexSubImage3DARB(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imagesize, data);
}
static void DLM_APIENTRY executeCompressedTexSubImage3DARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceCompressedTexSubImage3DARB *instance = (struct instanceCompressedTexSubImage3DARB *)x;
	dispatchTable->CompressedTexSubImage3DARB(instance->target, instance->level, instance->xoffset, instance->yoffset, instance->zoffset, instance->width, instance->height, instance->depth, instance->format, instance->imagesize, instance->data);
}
void DLM_APIENTRY crdlm_compile_CompressedTexSubImage3DARB( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imagesize, const GLvoid * data )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceCompressedTexSubImage3DARB *instance;
	instance = crCalloc(sizeof(struct instanceCompressedTexSubImage3DARB) + crdlm_pointers_CompressedTexSubImage3DARB(NULL, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imagesize, data));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding CompressedTexSubImage3DARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeCompressedTexSubImage3DARB;
	instance->target = target;
	instance->level = level;
	instance->xoffset = xoffset;
	instance->yoffset = yoffset;
	instance->zoffset = zoffset;
	instance->width = width;
	instance->height = height;
	instance->depth = depth;
	instance->format = format;
	instance->imagesize = imagesize;
	if (data == NULL) {
		instance->data = NULL;
	}
	else {
		instance->data = instance->dataData;
	}
	(void) crdlm_pointers_CompressedTexSubImage3DARB(instance, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imagesize, data);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** CopyPixels ***/
static void DLM_APIENTRY passCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.CopyPixels(x, y, width, height, type);
}
static void DLM_APIENTRY executeCopyPixels(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceCopyPixels *instance = (struct instanceCopyPixels *)x;
	dispatchTable->CopyPixels(instance->x, instance->y, instance->width, instance->height, instance->type);
}
void DLM_APIENTRY crdlm_compile_CopyPixels( GLint x, GLint y, GLsizei width, GLsizei height, GLenum type )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceCopyPixels *instance;
	instance = crCalloc(sizeof(struct instanceCopyPixels));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding CopyPixels to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeCopyPixels;
	instance->x = x;
	instance->y = y;
	instance->width = width;
	instance->height = height;
	instance->type = type;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** CopyTexImage1D ***/
static void DLM_APIENTRY passCopyTexImage1D(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.CopyTexImage1D(target, level, internalFormat, x, y, width, border);
}
static void DLM_APIENTRY executeCopyTexImage1D(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceCopyTexImage1D *instance = (struct instanceCopyTexImage1D *)x;
	dispatchTable->CopyTexImage1D(instance->target, instance->level, instance->internalFormat, instance->x, instance->y, instance->width, instance->border);
}
void DLM_APIENTRY crdlm_compile_CopyTexImage1D( GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceCopyTexImage1D *instance;
	instance = crCalloc(sizeof(struct instanceCopyTexImage1D));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding CopyTexImage1D to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeCopyTexImage1D;
	instance->target = target;
	instance->level = level;
	instance->internalFormat = internalFormat;
	instance->x = x;
	instance->y = y;
	instance->width = width;
	instance->border = border;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** CopyTexImage2D ***/
static void DLM_APIENTRY passCopyTexImage2D(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.CopyTexImage2D(target, level, internalFormat, x, y, width, height, border);
}
static void DLM_APIENTRY executeCopyTexImage2D(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceCopyTexImage2D *instance = (struct instanceCopyTexImage2D *)x;
	dispatchTable->CopyTexImage2D(instance->target, instance->level, instance->internalFormat, instance->x, instance->y, instance->width, instance->height, instance->border);
}
void DLM_APIENTRY crdlm_compile_CopyTexImage2D( GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceCopyTexImage2D *instance;
	instance = crCalloc(sizeof(struct instanceCopyTexImage2D));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding CopyTexImage2D to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeCopyTexImage2D;
	instance->target = target;
	instance->level = level;
	instance->internalFormat = internalFormat;
	instance->x = x;
	instance->y = y;
	instance->width = width;
	instance->height = height;
	instance->border = border;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** CopyTexSubImage1D ***/
static void DLM_APIENTRY passCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.CopyTexSubImage1D(target, level, xoffset, x, y, width);
}
static void DLM_APIENTRY executeCopyTexSubImage1D(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceCopyTexSubImage1D *instance = (struct instanceCopyTexSubImage1D *)x;
	dispatchTable->CopyTexSubImage1D(instance->target, instance->level, instance->xoffset, instance->x, instance->y, instance->width);
}
void DLM_APIENTRY crdlm_compile_CopyTexSubImage1D( GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceCopyTexSubImage1D *instance;
	instance = crCalloc(sizeof(struct instanceCopyTexSubImage1D));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding CopyTexSubImage1D to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeCopyTexSubImage1D;
	instance->target = target;
	instance->level = level;
	instance->xoffset = xoffset;
	instance->x = x;
	instance->y = y;
	instance->width = width;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** CopyTexSubImage2D ***/
static void DLM_APIENTRY passCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.CopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
}
static void DLM_APIENTRY executeCopyTexSubImage2D(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceCopyTexSubImage2D *instance = (struct instanceCopyTexSubImage2D *)x;
	dispatchTable->CopyTexSubImage2D(instance->target, instance->level, instance->xoffset, instance->yoffset, instance->x, instance->y, instance->width, instance->height);
}
void DLM_APIENTRY crdlm_compile_CopyTexSubImage2D( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceCopyTexSubImage2D *instance;
	instance = crCalloc(sizeof(struct instanceCopyTexSubImage2D));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding CopyTexSubImage2D to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeCopyTexSubImage2D;
	instance->target = target;
	instance->level = level;
	instance->xoffset = xoffset;
	instance->yoffset = yoffset;
	instance->x = x;
	instance->y = y;
	instance->width = width;
	instance->height = height;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** CopyTexSubImage3D ***/
static void DLM_APIENTRY passCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.CopyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height);
}
static void DLM_APIENTRY executeCopyTexSubImage3D(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceCopyTexSubImage3D *instance = (struct instanceCopyTexSubImage3D *)x;
	dispatchTable->CopyTexSubImage3D(instance->target, instance->level, instance->xoffset, instance->yoffset, instance->zoffset, instance->x, instance->y, instance->width, instance->height);
}
void DLM_APIENTRY crdlm_compile_CopyTexSubImage3D( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceCopyTexSubImage3D *instance;
	instance = crCalloc(sizeof(struct instanceCopyTexSubImage3D));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding CopyTexSubImage3D to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeCopyTexSubImage3D;
	instance->target = target;
	instance->level = level;
	instance->xoffset = xoffset;
	instance->yoffset = yoffset;
	instance->zoffset = zoffset;
	instance->x = x;
	instance->y = y;
	instance->width = width;
	instance->height = height;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** CreateContext ***/
static GLint DLM_APIENTRY passCreateContext(const char * dpyName, GLint visual)
{
	CRDLMContextState *state = CURRENT_STATE();
	return state->savedDispatchTable.CreateContext(dpyName, visual);
}

/*** CullFace ***/
static void DLM_APIENTRY passCullFace(GLenum mode)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.CullFace(mode);
}
static void DLM_APIENTRY executeCullFace(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceCullFace *instance = (struct instanceCullFace *)x;
	dispatchTable->CullFace(instance->mode);
}
void DLM_APIENTRY crdlm_compile_CullFace( GLenum mode )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceCullFace *instance;
	instance = crCalloc(sizeof(struct instanceCullFace));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding CullFace to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeCullFace;
	instance->mode = mode;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** DeleteBuffersARB ***/
static void DLM_APIENTRY passDeleteBuffersARB(GLsizei n, const GLuint * buffer)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.DeleteBuffersARB(n, buffer);
}

/*** DeleteFencesNV ***/
static void DLM_APIENTRY passDeleteFencesNV(GLsizei n, const GLuint * fences)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.DeleteFencesNV(n, fences);
}

/*** DeleteLists ***/
static void DLM_APIENTRY passDeleteLists(GLuint list, GLsizei range)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.DeleteLists(list, range);
}

/*** DeleteProgramsARB ***/
static void DLM_APIENTRY passDeleteProgramsARB(GLsizei n, const GLuint * programs)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.DeleteProgramsARB(n, programs);
}

/*** DeleteQueriesARB ***/
static void DLM_APIENTRY passDeleteQueriesARB(GLsizei n, const GLuint * ids)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.DeleteQueriesARB(n, ids);
}

/*** DeleteTextures ***/
static void DLM_APIENTRY passDeleteTextures(GLsizei n, const GLuint * textures)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.DeleteTextures(n, textures);
}

/*** DepthFunc ***/
static void DLM_APIENTRY passDepthFunc(GLenum func)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.DepthFunc(func);
}
static void DLM_APIENTRY executeDepthFunc(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceDepthFunc *instance = (struct instanceDepthFunc *)x;
	dispatchTable->DepthFunc(instance->func);
}
void DLM_APIENTRY crdlm_compile_DepthFunc( GLenum func )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceDepthFunc *instance;
	instance = crCalloc(sizeof(struct instanceDepthFunc));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding DepthFunc to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeDepthFunc;
	instance->func = func;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** DepthMask ***/
static void DLM_APIENTRY passDepthMask(GLboolean flag)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.DepthMask(flag);
}
static void DLM_APIENTRY executeDepthMask(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceDepthMask *instance = (struct instanceDepthMask *)x;
	dispatchTable->DepthMask(instance->flag);
}
void DLM_APIENTRY crdlm_compile_DepthMask( GLboolean flag )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceDepthMask *instance;
	instance = crCalloc(sizeof(struct instanceDepthMask));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding DepthMask to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeDepthMask;
	instance->flag = flag;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** DepthRange ***/
static void DLM_APIENTRY passDepthRange(GLclampd zNear, GLclampd zFar)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.DepthRange(zNear, zFar);
}
static void DLM_APIENTRY executeDepthRange(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceDepthRange *instance = (struct instanceDepthRange *)x;
	dispatchTable->DepthRange(instance->zNear, instance->zFar);
}
void DLM_APIENTRY crdlm_compile_DepthRange( GLclampd zNear, GLclampd zFar )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceDepthRange *instance;
	instance = crCalloc(sizeof(struct instanceDepthRange));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding DepthRange to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeDepthRange;
	instance->zNear = zNear;
	instance->zFar = zFar;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** DestroyContext ***/
static void DLM_APIENTRY passDestroyContext(GLint ctx)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.DestroyContext(ctx);
}

/*** Disable ***/
static void DLM_APIENTRY passDisable(GLenum cap)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Disable(cap);
}
static void DLM_APIENTRY executeDisable(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceDisable *instance = (struct instanceDisable *)x;
	dispatchTable->Disable(instance->cap);
}
void DLM_APIENTRY crdlm_compile_Disable( GLenum cap )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceDisable *instance;
	instance = crCalloc(sizeof(struct instanceDisable));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Disable to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeDisable;
	instance->cap = cap;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** DisableClientState ***/
static void DLM_APIENTRY passDisableClientState(GLenum array)
{
	CRDLMContextState *state = CURRENT_STATE();
	crdlmDisableClientState(array, state->clientState);
	state->savedDispatchTable.DisableClientState(array);
}

/*** DisableVertexAttribArrayARB ***/
static void DLM_APIENTRY passDisableVertexAttribArrayARB(GLuint index)
{
	CRDLMContextState *state = CURRENT_STATE();
	crdlmDisableVertexAttribArrayARB(index, state->clientState);
	state->savedDispatchTable.DisableVertexAttribArrayARB(index);
}

/*** DrawArrays ***/
static void DLM_APIENTRY passDrawArrays(GLenum mode, GLint first, GLsizei count)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.DrawArrays(mode, first, count);
}

/*** DrawBuffer ***/
static void DLM_APIENTRY passDrawBuffer(GLenum mode)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.DrawBuffer(mode);
}
static void DLM_APIENTRY executeDrawBuffer(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceDrawBuffer *instance = (struct instanceDrawBuffer *)x;
	dispatchTable->DrawBuffer(instance->mode);
}
void DLM_APIENTRY crdlm_compile_DrawBuffer( GLenum mode )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceDrawBuffer *instance;
	instance = crCalloc(sizeof(struct instanceDrawBuffer));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding DrawBuffer to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeDrawBuffer;
	instance->mode = mode;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** DrawElements ***/
static void DLM_APIENTRY passDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.DrawElements(mode, count, type, indices);
}

/*** DrawPixels ***/
static void DLM_APIENTRY passDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.DrawPixels(width, height, format, type, pixels);
}
static void DLM_APIENTRY executeDrawPixels(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceDrawPixels *instance = (struct instanceDrawPixels *)x;
	dispatchTable->DrawPixels(instance->width, instance->height, instance->format, instance->type, instance->pixels);
}
void DLM_APIENTRY crdlm_compile_DrawPixels( GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceDrawPixels *instance;
	instance = crCalloc(sizeof(struct instanceDrawPixels) + crdlm_pointers_DrawPixels(NULL, width, height, format, type, pixels));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding DrawPixels to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeDrawPixels;
	instance->width = width;
	instance->height = height;
	instance->format = format;
	instance->type = type;
	if (pixels == NULL) {
		instance->pixels = NULL;
	}
	else {
		instance->pixels = instance->pixelsData;
	}
	(void) crdlm_pointers_DrawPixels(instance, width, height, format, type, pixels);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** DrawRangeElements ***/
static void DLM_APIENTRY passDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid * indices)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.DrawRangeElements(mode, start, end, count, type, indices);
}

/*** EdgeFlag ***/
static void DLM_APIENTRY passEdgeFlag(GLboolean flag)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.EdgeFlag(flag);
}
static void DLM_APIENTRY executeEdgeFlag(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceEdgeFlag *instance = (struct instanceEdgeFlag *)x;
	dispatchTable->EdgeFlag(instance->flag);
}
void DLM_APIENTRY crdlm_compile_EdgeFlag( GLboolean flag )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceEdgeFlag *instance;
	instance = crCalloc(sizeof(struct instanceEdgeFlag));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding EdgeFlag to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeEdgeFlag;
	instance->flag = flag;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** EdgeFlagPointer ***/
static void DLM_APIENTRY passEdgeFlagPointer(GLsizei stride, const GLvoid * pointer)
{
	CRDLMContextState *state = CURRENT_STATE();
	crdlmEdgeFlagPointer(stride, pointer, state->clientState);
	state->savedDispatchTable.EdgeFlagPointer(stride, pointer);
}

/*** EdgeFlagv ***/
static void DLM_APIENTRY passEdgeFlagv(const GLboolean * flag)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.EdgeFlagv(flag);
}
static void DLM_APIENTRY executeEdgeFlagv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceEdgeFlagv *instance = (struct instanceEdgeFlagv *)x;
	dispatchTable->EdgeFlagv(instance->flag);
}
void DLM_APIENTRY crdlm_compile_EdgeFlagv( const GLboolean * flag )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceEdgeFlagv *instance;
	instance = crCalloc(sizeof(struct instanceEdgeFlagv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding EdgeFlagv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeEdgeFlagv;
	if (flag == NULL) {
		instance->flag = NULL;
	}
	else {
		instance->flag = instance->flagData;
	}
	crMemcpy((void *)instance->flag, (void *) flag, 1*sizeof(GLboolean));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Enable ***/
static void DLM_APIENTRY passEnable(GLenum cap)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Enable(cap);
}
static void DLM_APIENTRY executeEnable(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceEnable *instance = (struct instanceEnable *)x;
	dispatchTable->Enable(instance->cap);
}
void DLM_APIENTRY crdlm_compile_Enable( GLenum cap )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceEnable *instance;
	instance = crCalloc(sizeof(struct instanceEnable));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Enable to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeEnable;
	instance->cap = cap;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** EnableClientState ***/
static void DLM_APIENTRY passEnableClientState(GLenum array)
{
	CRDLMContextState *state = CURRENT_STATE();
	crdlmEnableClientState(array, state->clientState);
	state->savedDispatchTable.EnableClientState(array);
}

/*** EnableVertexAttribArrayARB ***/
static void DLM_APIENTRY passEnableVertexAttribArrayARB(GLuint index)
{
	CRDLMContextState *state = CURRENT_STATE();
	crdlmEnableVertexAttribArrayARB(index, state->clientState);
	state->savedDispatchTable.EnableVertexAttribArrayARB(index);
}

/*** End ***/
static void DLM_APIENTRY passEnd(void)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.End();
}
static void DLM_APIENTRY executeEnd(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	dispatchTable->End();
}
void DLM_APIENTRY crdlm_compile_End( void )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceEnd *instance;
	instance = crCalloc(sizeof(struct instanceEnd));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding End to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeEnd;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** EndList ***/
static void DLM_APIENTRY passEndList(void)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.EndList();
}

/*** EndQueryARB ***/
static void DLM_APIENTRY passEndQueryARB(GLenum target)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.EndQueryARB(target);
}
static void DLM_APIENTRY executeEndQueryARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceEndQueryARB *instance = (struct instanceEndQueryARB *)x;
	dispatchTable->EndQueryARB(instance->target);
}
void DLM_APIENTRY crdlm_compile_EndQueryARB( GLenum target )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceEndQueryARB *instance;
	instance = crCalloc(sizeof(struct instanceEndQueryARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding EndQueryARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeEndQueryARB;
	instance->target = target;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** EvalCoord1d ***/
static void DLM_APIENTRY passEvalCoord1d(GLdouble u)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.EvalCoord1d(u);
}
static void DLM_APIENTRY executeEvalCoord1d(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceEvalCoord1d *instance = (struct instanceEvalCoord1d *)x;
	dispatchTable->EvalCoord1d(instance->u);
}
void DLM_APIENTRY crdlm_compile_EvalCoord1d( GLdouble u )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceEvalCoord1d *instance;
	instance = crCalloc(sizeof(struct instanceEvalCoord1d));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding EvalCoord1d to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeEvalCoord1d;
	instance->u = u;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** EvalCoord1dv ***/
static void DLM_APIENTRY passEvalCoord1dv(const GLdouble * u)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.EvalCoord1dv(u);
}
static void DLM_APIENTRY executeEvalCoord1dv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceEvalCoord1dv *instance = (struct instanceEvalCoord1dv *)x;
	dispatchTable->EvalCoord1dv(instance->u);
}
void DLM_APIENTRY crdlm_compile_EvalCoord1dv( const GLdouble * u )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceEvalCoord1dv *instance;
	instance = crCalloc(sizeof(struct instanceEvalCoord1dv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding EvalCoord1dv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeEvalCoord1dv;
	if (u == NULL) {
		instance->u = NULL;
	}
	else {
		instance->u = instance->uData;
	}
	crMemcpy((void *)instance->u, (void *) u, 1*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** EvalCoord1f ***/
static void DLM_APIENTRY passEvalCoord1f(GLfloat u)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.EvalCoord1f(u);
}
static void DLM_APIENTRY executeEvalCoord1f(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceEvalCoord1f *instance = (struct instanceEvalCoord1f *)x;
	dispatchTable->EvalCoord1f(instance->u);
}
void DLM_APIENTRY crdlm_compile_EvalCoord1f( GLfloat u )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceEvalCoord1f *instance;
	instance = crCalloc(sizeof(struct instanceEvalCoord1f));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding EvalCoord1f to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeEvalCoord1f;
	instance->u = u;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** EvalCoord1fv ***/
static void DLM_APIENTRY passEvalCoord1fv(const GLfloat * u)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.EvalCoord1fv(u);
}
static void DLM_APIENTRY executeEvalCoord1fv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceEvalCoord1fv *instance = (struct instanceEvalCoord1fv *)x;
	dispatchTable->EvalCoord1fv(instance->u);
}
void DLM_APIENTRY crdlm_compile_EvalCoord1fv( const GLfloat * u )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceEvalCoord1fv *instance;
	instance = crCalloc(sizeof(struct instanceEvalCoord1fv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding EvalCoord1fv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeEvalCoord1fv;
	if (u == NULL) {
		instance->u = NULL;
	}
	else {
		instance->u = instance->uData;
	}
	crMemcpy((void *)instance->u, (void *) u, 1*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** EvalCoord2d ***/
static void DLM_APIENTRY passEvalCoord2d(GLdouble u, GLdouble v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.EvalCoord2d(u, v);
}
static void DLM_APIENTRY executeEvalCoord2d(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceEvalCoord2d *instance = (struct instanceEvalCoord2d *)x;
	dispatchTable->EvalCoord2d(instance->u, instance->v);
}
void DLM_APIENTRY crdlm_compile_EvalCoord2d( GLdouble u, GLdouble v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceEvalCoord2d *instance;
	instance = crCalloc(sizeof(struct instanceEvalCoord2d));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding EvalCoord2d to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeEvalCoord2d;
	instance->u = u;
	instance->v = v;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** EvalCoord2dv ***/
static void DLM_APIENTRY passEvalCoord2dv(const GLdouble * u)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.EvalCoord2dv(u);
}
static void DLM_APIENTRY executeEvalCoord2dv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceEvalCoord2dv *instance = (struct instanceEvalCoord2dv *)x;
	dispatchTable->EvalCoord2dv(instance->u);
}
void DLM_APIENTRY crdlm_compile_EvalCoord2dv( const GLdouble * u )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceEvalCoord2dv *instance;
	instance = crCalloc(sizeof(struct instanceEvalCoord2dv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding EvalCoord2dv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeEvalCoord2dv;
	if (u == NULL) {
		instance->u = NULL;
	}
	else {
		instance->u = instance->uData;
	}
	crMemcpy((void *)instance->u, (void *) u, 2*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** EvalCoord2f ***/
static void DLM_APIENTRY passEvalCoord2f(GLfloat u, GLfloat v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.EvalCoord2f(u, v);
}
static void DLM_APIENTRY executeEvalCoord2f(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceEvalCoord2f *instance = (struct instanceEvalCoord2f *)x;
	dispatchTable->EvalCoord2f(instance->u, instance->v);
}
void DLM_APIENTRY crdlm_compile_EvalCoord2f( GLfloat u, GLfloat v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceEvalCoord2f *instance;
	instance = crCalloc(sizeof(struct instanceEvalCoord2f));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding EvalCoord2f to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeEvalCoord2f;
	instance->u = u;
	instance->v = v;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** EvalCoord2fv ***/
static void DLM_APIENTRY passEvalCoord2fv(const GLfloat * u)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.EvalCoord2fv(u);
}
static void DLM_APIENTRY executeEvalCoord2fv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceEvalCoord2fv *instance = (struct instanceEvalCoord2fv *)x;
	dispatchTable->EvalCoord2fv(instance->u);
}
void DLM_APIENTRY crdlm_compile_EvalCoord2fv( const GLfloat * u )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceEvalCoord2fv *instance;
	instance = crCalloc(sizeof(struct instanceEvalCoord2fv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding EvalCoord2fv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeEvalCoord2fv;
	if (u == NULL) {
		instance->u = NULL;
	}
	else {
		instance->u = instance->uData;
	}
	crMemcpy((void *)instance->u, (void *) u, 2*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** EvalMesh1 ***/
static void DLM_APIENTRY passEvalMesh1(GLenum mode, GLint i1, GLint i2)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.EvalMesh1(mode, i1, i2);
}
static void DLM_APIENTRY executeEvalMesh1(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceEvalMesh1 *instance = (struct instanceEvalMesh1 *)x;
	dispatchTable->EvalMesh1(instance->mode, instance->i1, instance->i2);
}
void DLM_APIENTRY crdlm_compile_EvalMesh1( GLenum mode, GLint i1, GLint i2 )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceEvalMesh1 *instance;
	instance = crCalloc(sizeof(struct instanceEvalMesh1));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding EvalMesh1 to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeEvalMesh1;
	instance->mode = mode;
	instance->i1 = i1;
	instance->i2 = i2;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** EvalMesh2 ***/
static void DLM_APIENTRY passEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.EvalMesh2(mode, i1, i2, j1, j2);
}
static void DLM_APIENTRY executeEvalMesh2(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceEvalMesh2 *instance = (struct instanceEvalMesh2 *)x;
	dispatchTable->EvalMesh2(instance->mode, instance->i1, instance->i2, instance->j1, instance->j2);
}
void DLM_APIENTRY crdlm_compile_EvalMesh2( GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2 )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceEvalMesh2 *instance;
	instance = crCalloc(sizeof(struct instanceEvalMesh2));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding EvalMesh2 to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeEvalMesh2;
	instance->mode = mode;
	instance->i1 = i1;
	instance->i2 = i2;
	instance->j1 = j1;
	instance->j2 = j2;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** EvalPoint1 ***/
static void DLM_APIENTRY passEvalPoint1(GLint i)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.EvalPoint1(i);
}
static void DLM_APIENTRY executeEvalPoint1(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceEvalPoint1 *instance = (struct instanceEvalPoint1 *)x;
	dispatchTable->EvalPoint1(instance->i);
}
void DLM_APIENTRY crdlm_compile_EvalPoint1( GLint i )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceEvalPoint1 *instance;
	instance = crCalloc(sizeof(struct instanceEvalPoint1));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding EvalPoint1 to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeEvalPoint1;
	instance->i = i;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** EvalPoint2 ***/
static void DLM_APIENTRY passEvalPoint2(GLint i, GLint j)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.EvalPoint2(i, j);
}
static void DLM_APIENTRY executeEvalPoint2(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceEvalPoint2 *instance = (struct instanceEvalPoint2 *)x;
	dispatchTable->EvalPoint2(instance->i, instance->j);
}
void DLM_APIENTRY crdlm_compile_EvalPoint2( GLint i, GLint j )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceEvalPoint2 *instance;
	instance = crCalloc(sizeof(struct instanceEvalPoint2));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding EvalPoint2 to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeEvalPoint2;
	instance->i = i;
	instance->j = j;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** ExecuteProgramNV ***/
static void DLM_APIENTRY passExecuteProgramNV(GLenum target, GLuint id, const GLfloat * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ExecuteProgramNV(target, id, params);
}
static void DLM_APIENTRY executeExecuteProgramNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceExecuteProgramNV *instance = (struct instanceExecuteProgramNV *)x;
	dispatchTable->ExecuteProgramNV(instance->target, instance->id, instance->params);
}
void DLM_APIENTRY crdlm_compile_ExecuteProgramNV( GLenum target, GLuint id, const GLfloat * params )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceExecuteProgramNV *instance;
	instance = crCalloc(sizeof(struct instanceExecuteProgramNV) + crdlm_pointers_ExecuteProgramNV(NULL, target, id, params));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding ExecuteProgramNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeExecuteProgramNV;
	instance->target = target;
	instance->id = id;
	if (params == NULL) {
		instance->params = NULL;
	}
	else {
		instance->params = instance->paramsData;
	}
	(void) crdlm_pointers_ExecuteProgramNV(instance, target, id, params);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** FeedbackBuffer ***/
static void DLM_APIENTRY passFeedbackBuffer(GLsizei size, GLenum type, GLfloat * buffer)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.FeedbackBuffer(size, type, buffer);
}

/*** FinalCombinerInputNV ***/
static void DLM_APIENTRY passFinalCombinerInputNV(GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.FinalCombinerInputNV(variable, input, mapping, componentUsage);
}
static void DLM_APIENTRY executeFinalCombinerInputNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceFinalCombinerInputNV *instance = (struct instanceFinalCombinerInputNV *)x;
	dispatchTable->FinalCombinerInputNV(instance->variable, instance->input, instance->mapping, instance->componentUsage);
}
void DLM_APIENTRY crdlm_compile_FinalCombinerInputNV( GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceFinalCombinerInputNV *instance;
	instance = crCalloc(sizeof(struct instanceFinalCombinerInputNV));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding FinalCombinerInputNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeFinalCombinerInputNV;
	instance->variable = variable;
	instance->input = input;
	instance->mapping = mapping;
	instance->componentUsage = componentUsage;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Finish ***/
static void DLM_APIENTRY passFinish(void)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Finish();
}

/*** FinishFenceNV ***/
static void DLM_APIENTRY passFinishFenceNV(GLuint fence)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.FinishFenceNV(fence);
}
static void DLM_APIENTRY executeFinishFenceNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceFinishFenceNV *instance = (struct instanceFinishFenceNV *)x;
	dispatchTable->FinishFenceNV(instance->fence);
}
void DLM_APIENTRY crdlm_compile_FinishFenceNV( GLuint fence )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceFinishFenceNV *instance;
	instance = crCalloc(sizeof(struct instanceFinishFenceNV));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding FinishFenceNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeFinishFenceNV;
	instance->fence = fence;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Flush ***/
static void DLM_APIENTRY passFlush(void)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Flush();
}

/*** FlushVertexArrayRangeNV ***/
static void DLM_APIENTRY passFlushVertexArrayRangeNV(void)
{
	CRDLMContextState *state = CURRENT_STATE();
	crdlmFlushVertexArrayRangeNV(state->clientState);
	state->savedDispatchTable.FlushVertexArrayRangeNV();
}

/*** FogCoordPointerEXT ***/
static void DLM_APIENTRY passFogCoordPointerEXT(GLenum type, GLsizei stride, const GLvoid * pointer)
{
	CRDLMContextState *state = CURRENT_STATE();
	crdlmFogCoordPointerEXT(type, stride, pointer, state->clientState);
	state->savedDispatchTable.FogCoordPointerEXT(type, stride, pointer);
}

/*** FogCoorddEXT ***/
static void DLM_APIENTRY passFogCoorddEXT(GLdouble coord)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.FogCoorddEXT(coord);
}
static void DLM_APIENTRY executeFogCoorddEXT(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceFogCoorddEXT *instance = (struct instanceFogCoorddEXT *)x;
	dispatchTable->FogCoorddEXT(instance->coord);
}
void DLM_APIENTRY crdlm_compile_FogCoorddEXT( GLdouble coord )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceFogCoorddEXT *instance;
	instance = crCalloc(sizeof(struct instanceFogCoorddEXT));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding FogCoorddEXT to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeFogCoorddEXT;
	instance->coord = coord;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** FogCoorddvEXT ***/
static void DLM_APIENTRY passFogCoorddvEXT(const GLdouble * coord)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.FogCoorddvEXT(coord);
}
static void DLM_APIENTRY executeFogCoorddvEXT(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceFogCoorddvEXT *instance = (struct instanceFogCoorddvEXT *)x;
	dispatchTable->FogCoorddvEXT(instance->coord);
}
void DLM_APIENTRY crdlm_compile_FogCoorddvEXT( const GLdouble * coord )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceFogCoorddvEXT *instance;
	instance = crCalloc(sizeof(struct instanceFogCoorddvEXT));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding FogCoorddvEXT to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeFogCoorddvEXT;
	if (coord == NULL) {
		instance->coord = NULL;
	}
	else {
		instance->coord = instance->coordData;
	}
	crMemcpy((void *)instance->coord, (void *) coord, 1*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** FogCoordfEXT ***/
static void DLM_APIENTRY passFogCoordfEXT(GLfloat coord)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.FogCoordfEXT(coord);
}
static void DLM_APIENTRY executeFogCoordfEXT(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceFogCoordfEXT *instance = (struct instanceFogCoordfEXT *)x;
	dispatchTable->FogCoordfEXT(instance->coord);
}
void DLM_APIENTRY crdlm_compile_FogCoordfEXT( GLfloat coord )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceFogCoordfEXT *instance;
	instance = crCalloc(sizeof(struct instanceFogCoordfEXT));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding FogCoordfEXT to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeFogCoordfEXT;
	instance->coord = coord;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** FogCoordfvEXT ***/
static void DLM_APIENTRY passFogCoordfvEXT(const GLfloat * coord)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.FogCoordfvEXT(coord);
}
static void DLM_APIENTRY executeFogCoordfvEXT(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceFogCoordfvEXT *instance = (struct instanceFogCoordfvEXT *)x;
	dispatchTable->FogCoordfvEXT(instance->coord);
}
void DLM_APIENTRY crdlm_compile_FogCoordfvEXT( const GLfloat * coord )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceFogCoordfvEXT *instance;
	instance = crCalloc(sizeof(struct instanceFogCoordfvEXT));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding FogCoordfvEXT to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeFogCoordfvEXT;
	if (coord == NULL) {
		instance->coord = NULL;
	}
	else {
		instance->coord = instance->coordData;
	}
	crMemcpy((void *)instance->coord, (void *) coord, 1*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Fogf ***/
static void DLM_APIENTRY passFogf(GLenum pname, GLfloat param)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Fogf(pname, param);
}
static void DLM_APIENTRY executeFogf(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceFogf *instance = (struct instanceFogf *)x;
	dispatchTable->Fogf(instance->pname, instance->param);
}
void DLM_APIENTRY crdlm_compile_Fogf( GLenum pname, GLfloat param )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceFogf *instance;
	instance = crCalloc(sizeof(struct instanceFogf));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Fogf to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeFogf;
	instance->pname = pname;
	instance->param = param;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Fogfv ***/
static void DLM_APIENTRY passFogfv(GLenum pname, const GLfloat * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Fogfv(pname, params);
}
static void DLM_APIENTRY executeFogfv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceFogfv *instance = (struct instanceFogfv *)x;
	dispatchTable->Fogfv(instance->pname, instance->params);
}
void DLM_APIENTRY crdlm_compile_Fogfv( GLenum pname, const GLfloat * params )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceFogfv *instance;
	instance = crCalloc(sizeof(struct instanceFogfv) + crdlm_pointers_Fogfv(NULL, pname, params));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Fogfv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeFogfv;
	instance->pname = pname;
	if (params == NULL) {
		instance->params = NULL;
	}
	else {
		instance->params = instance->paramsData;
	}
	(void) crdlm_pointers_Fogfv(instance, pname, params);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Fogi ***/
static void DLM_APIENTRY passFogi(GLenum pname, GLint param)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Fogi(pname, param);
}
static void DLM_APIENTRY executeFogi(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceFogi *instance = (struct instanceFogi *)x;
	dispatchTable->Fogi(instance->pname, instance->param);
}
void DLM_APIENTRY crdlm_compile_Fogi( GLenum pname, GLint param )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceFogi *instance;
	instance = crCalloc(sizeof(struct instanceFogi));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Fogi to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeFogi;
	instance->pname = pname;
	instance->param = param;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Fogiv ***/
static void DLM_APIENTRY passFogiv(GLenum pname, const GLint * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Fogiv(pname, params);
}
static void DLM_APIENTRY executeFogiv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceFogiv *instance = (struct instanceFogiv *)x;
	dispatchTable->Fogiv(instance->pname, instance->params);
}
void DLM_APIENTRY crdlm_compile_Fogiv( GLenum pname, const GLint * params )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceFogiv *instance;
	instance = crCalloc(sizeof(struct instanceFogiv) + crdlm_pointers_Fogiv(NULL, pname, params));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Fogiv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeFogiv;
	instance->pname = pname;
	if (params == NULL) {
		instance->params = NULL;
	}
	else {
		instance->params = instance->paramsData;
	}
	(void) crdlm_pointers_Fogiv(instance, pname, params);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** FrontFace ***/
static void DLM_APIENTRY passFrontFace(GLenum mode)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.FrontFace(mode);
}
static void DLM_APIENTRY executeFrontFace(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceFrontFace *instance = (struct instanceFrontFace *)x;
	dispatchTable->FrontFace(instance->mode);
}
void DLM_APIENTRY crdlm_compile_FrontFace( GLenum mode )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceFrontFace *instance;
	instance = crCalloc(sizeof(struct instanceFrontFace));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding FrontFace to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeFrontFace;
	instance->mode = mode;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Frustum ***/
static void DLM_APIENTRY passFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Frustum(left, right, bottom, top, zNear, zFar);
}
static void DLM_APIENTRY executeFrustum(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceFrustum *instance = (struct instanceFrustum *)x;
	dispatchTable->Frustum(instance->left, instance->right, instance->bottom, instance->top, instance->zNear, instance->zFar);
}
void DLM_APIENTRY crdlm_compile_Frustum( GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceFrustum *instance;
	instance = crCalloc(sizeof(struct instanceFrustum));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Frustum to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeFrustum;
	instance->left = left;
	instance->right = right;
	instance->bottom = bottom;
	instance->top = top;
	instance->zNear = zNear;
	instance->zFar = zFar;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** GenBuffersARB ***/
static void DLM_APIENTRY passGenBuffersARB(GLsizei n, GLuint * buffer)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GenBuffersARB(n, buffer);
}

/*** GenFencesNV ***/
static void DLM_APIENTRY passGenFencesNV(GLsizei n, GLuint * fences)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GenFencesNV(n, fences);
}

/*** GenLists ***/
static GLuint DLM_APIENTRY passGenLists(GLsizei range)
{
	CRDLMContextState *state = CURRENT_STATE();
	return state->savedDispatchTable.GenLists(range);
}

/*** GenProgramsARB ***/
static void DLM_APIENTRY passGenProgramsARB(GLsizei n, GLuint * programs)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GenProgramsARB(n, programs);
}

/*** GenProgramsNV ***/
static void DLM_APIENTRY passGenProgramsNV(GLsizei n, GLuint * ids)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GenProgramsNV(n, ids);
}

/*** GenQueriesARB ***/
static void DLM_APIENTRY passGenQueriesARB(GLsizei n, GLuint * ids)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GenQueriesARB(n, ids);
}

/*** GenTextures ***/
static void DLM_APIENTRY passGenTextures(GLsizei n, GLuint * textures)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GenTextures(n, textures);
}

/*** GetBooleanv ***/
static void DLM_APIENTRY passGetBooleanv(GLenum pname, GLboolean * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetBooleanv(pname, params);
}

/*** GetBufferParameterivARB ***/
static void DLM_APIENTRY passGetBufferParameterivARB(GLenum target, GLenum pname, GLint * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetBufferParameterivARB(target, pname, params);
}

/*** GetBufferPointervARB ***/
static void DLM_APIENTRY passGetBufferPointervARB(GLenum target, GLenum pname, GLvoid ** params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetBufferPointervARB(target, pname, params);
}

/*** GetBufferSubDataARB ***/
static void DLM_APIENTRY passGetBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, void * data)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetBufferSubDataARB(target, offset, size, data);
}

/*** GetChromiumParametervCR ***/
static void DLM_APIENTRY passGetChromiumParametervCR(GLenum target, GLuint index, GLenum type, GLsizei count, GLvoid * values)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetChromiumParametervCR(target, index, type, count, values);
}

/*** GetClipPlane ***/
static void DLM_APIENTRY passGetClipPlane(GLenum plane, GLdouble * equation)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetClipPlane(plane, equation);
}

/*** GetCombinerInputParameterfvNV ***/
static void DLM_APIENTRY passGetCombinerInputParameterfvNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetCombinerInputParameterfvNV(stage, portion, variable, pname, params);
}

/*** GetCombinerInputParameterivNV ***/
static void DLM_APIENTRY passGetCombinerInputParameterivNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetCombinerInputParameterivNV(stage, portion, variable, pname, params);
}

/*** GetCombinerOutputParameterfvNV ***/
static void DLM_APIENTRY passGetCombinerOutputParameterfvNV(GLenum stage, GLenum portion, GLenum pname, GLfloat * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetCombinerOutputParameterfvNV(stage, portion, pname, params);
}

/*** GetCombinerOutputParameterivNV ***/
static void DLM_APIENTRY passGetCombinerOutputParameterivNV(GLenum stage, GLenum portion, GLenum pname, GLint * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetCombinerOutputParameterivNV(stage, portion, pname, params);
}

/*** GetCombinerStageParameterfvNV ***/
static void DLM_APIENTRY passGetCombinerStageParameterfvNV(GLenum stage, GLenum pname, GLfloat * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetCombinerStageParameterfvNV(stage, pname, params);
}

/*** GetCompressedTexImageARB ***/
static void DLM_APIENTRY passGetCompressedTexImageARB(GLenum target, GLint level, GLvoid * img)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetCompressedTexImageARB(target, level, img);
}

/*** GetDoublev ***/
static void DLM_APIENTRY passGetDoublev(GLenum pname, GLdouble * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetDoublev(pname, params);
}

/*** GetError ***/
static GLenum DLM_APIENTRY passGetError(void)
{
	CRDLMContextState *state = CURRENT_STATE();
	return state->savedDispatchTable.GetError();
}

/*** GetFenceivNV ***/
static void DLM_APIENTRY passGetFenceivNV(GLuint fence, GLenum pname, GLint * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetFenceivNV(fence, pname, params);
}

/*** GetFinalCombinerInputParameterfvNV ***/
static void DLM_APIENTRY passGetFinalCombinerInputParameterfvNV(GLenum variable, GLenum pname, GLfloat * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetFinalCombinerInputParameterfvNV(variable, pname, params);
}

/*** GetFinalCombinerInputParameterivNV ***/
static void DLM_APIENTRY passGetFinalCombinerInputParameterivNV(GLenum variable, GLenum pname, GLint * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetFinalCombinerInputParameterivNV(variable, pname, params);
}

/*** GetFloatv ***/
static void DLM_APIENTRY passGetFloatv(GLenum pname, GLfloat * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetFloatv(pname, params);
}

/*** GetIntegerv ***/
static void DLM_APIENTRY passGetIntegerv(GLenum pname, GLint * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetIntegerv(pname, params);
}

/*** GetLightfv ***/
static void DLM_APIENTRY passGetLightfv(GLenum light, GLenum pname, GLfloat * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetLightfv(light, pname, params);
}

/*** GetLightiv ***/
static void DLM_APIENTRY passGetLightiv(GLenum light, GLenum pname, GLint * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetLightiv(light, pname, params);
}

/*** GetMapdv ***/
static void DLM_APIENTRY passGetMapdv(GLenum target, GLenum query, GLdouble * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetMapdv(target, query, v);
}

/*** GetMapfv ***/
static void DLM_APIENTRY passGetMapfv(GLenum target, GLenum query, GLfloat * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetMapfv(target, query, v);
}

/*** GetMapiv ***/
static void DLM_APIENTRY passGetMapiv(GLenum target, GLenum query, GLint * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetMapiv(target, query, v);
}

/*** GetMaterialfv ***/
static void DLM_APIENTRY passGetMaterialfv(GLenum face, GLenum pname, GLfloat * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetMaterialfv(face, pname, params);
}

/*** GetMaterialiv ***/
static void DLM_APIENTRY passGetMaterialiv(GLenum face, GLenum pname, GLint * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetMaterialiv(face, pname, params);
}

/*** GetPixelMapfv ***/
static void DLM_APIENTRY passGetPixelMapfv(GLenum map, GLfloat * values)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetPixelMapfv(map, values);
}

/*** GetPixelMapuiv ***/
static void DLM_APIENTRY passGetPixelMapuiv(GLenum map, GLuint * values)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetPixelMapuiv(map, values);
}

/*** GetPixelMapusv ***/
static void DLM_APIENTRY passGetPixelMapusv(GLenum map, GLushort * values)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetPixelMapusv(map, values);
}

/*** GetPointerv ***/
static void DLM_APIENTRY passGetPointerv(GLenum pname, GLvoid ** params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetPointerv(pname, params);
}

/*** GetPolygonStipple ***/
static void DLM_APIENTRY passGetPolygonStipple(GLubyte * mask)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetPolygonStipple(mask);
}

/*** GetProgramEnvParameterdvARB ***/
static void DLM_APIENTRY passGetProgramEnvParameterdvARB(GLenum target, GLuint index, GLdouble * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetProgramEnvParameterdvARB(target, index, params);
}

/*** GetProgramEnvParameterfvARB ***/
static void DLM_APIENTRY passGetProgramEnvParameterfvARB(GLenum target, GLuint index, GLfloat * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetProgramEnvParameterfvARB(target, index, params);
}

/*** GetProgramLocalParameterdvARB ***/
static void DLM_APIENTRY passGetProgramLocalParameterdvARB(GLenum target, GLuint index, GLdouble * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetProgramLocalParameterdvARB(target, index, params);
}

/*** GetProgramLocalParameterfvARB ***/
static void DLM_APIENTRY passGetProgramLocalParameterfvARB(GLenum target, GLuint index, GLfloat * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetProgramLocalParameterfvARB(target, index, params);
}

/*** GetProgramNamedParameterdvNV ***/
static void DLM_APIENTRY passGetProgramNamedParameterdvNV(GLuint id, GLsizei len, const GLubyte * name, GLdouble * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetProgramNamedParameterdvNV(id, len, name, params);
}

/*** GetProgramNamedParameterfvNV ***/
static void DLM_APIENTRY passGetProgramNamedParameterfvNV(GLuint id, GLsizei len, const GLubyte * name, GLfloat * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetProgramNamedParameterfvNV(id, len, name, params);
}

/*** GetProgramParameterdvNV ***/
static void DLM_APIENTRY passGetProgramParameterdvNV(GLenum target, GLuint index, GLenum pname, GLdouble * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetProgramParameterdvNV(target, index, pname, params);
}

/*** GetProgramParameterfvNV ***/
static void DLM_APIENTRY passGetProgramParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetProgramParameterfvNV(target, index, pname, params);
}

/*** GetProgramStringARB ***/
static void DLM_APIENTRY passGetProgramStringARB(GLenum target, GLenum pname, GLvoid * string)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetProgramStringARB(target, pname, string);
}

/*** GetProgramStringNV ***/
static void DLM_APIENTRY passGetProgramStringNV(GLuint id, GLenum pname, GLubyte * program)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetProgramStringNV(id, pname, program);
}

/*** GetProgramivARB ***/
static void DLM_APIENTRY passGetProgramivARB(GLenum target, GLenum pname, GLint * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetProgramivARB(target, pname, params);
}

/*** GetProgramivNV ***/
static void DLM_APIENTRY passGetProgramivNV(GLuint id, GLenum pname, GLint * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetProgramivNV(id, pname, params);
}

/*** GetQueryObjectivARB ***/
static void DLM_APIENTRY passGetQueryObjectivARB(GLuint id, GLenum pname, GLint * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetQueryObjectivARB(id, pname, params);
}

/*** GetQueryObjectuivARB ***/
static void DLM_APIENTRY passGetQueryObjectuivARB(GLuint id, GLenum pname, GLuint * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetQueryObjectuivARB(id, pname, params);
}

/*** GetQueryivARB ***/
static void DLM_APIENTRY passGetQueryivARB(GLenum target, GLenum pname, GLint * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetQueryivARB(target, pname, params);
}

/*** GetString ***/
static const GLubyte * DLM_APIENTRY passGetString(GLenum name)
{
	CRDLMContextState *state = CURRENT_STATE();
	return state->savedDispatchTable.GetString(name);
}

/*** GetTexEnvfv ***/
static void DLM_APIENTRY passGetTexEnvfv(GLenum target, GLenum pname, GLfloat * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetTexEnvfv(target, pname, params);
}

/*** GetTexEnviv ***/
static void DLM_APIENTRY passGetTexEnviv(GLenum target, GLenum pname, GLint * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetTexEnviv(target, pname, params);
}

/*** GetTexGendv ***/
static void DLM_APIENTRY passGetTexGendv(GLenum coord, GLenum pname, GLdouble * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetTexGendv(coord, pname, params);
}

/*** GetTexGenfv ***/
static void DLM_APIENTRY passGetTexGenfv(GLenum coord, GLenum pname, GLfloat * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetTexGenfv(coord, pname, params);
}

/*** GetTexGeniv ***/
static void DLM_APIENTRY passGetTexGeniv(GLenum coord, GLenum pname, GLint * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetTexGeniv(coord, pname, params);
}

/*** GetTexImage ***/
static void DLM_APIENTRY passGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid * pixels)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetTexImage(target, level, format, type, pixels);
}

/*** GetTexLevelParameterfv ***/
static void DLM_APIENTRY passGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetTexLevelParameterfv(target, level, pname, params);
}

/*** GetTexLevelParameteriv ***/
static void DLM_APIENTRY passGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetTexLevelParameteriv(target, level, pname, params);
}

/*** GetTexParameterfv ***/
static void DLM_APIENTRY passGetTexParameterfv(GLenum target, GLenum pname, GLfloat * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetTexParameterfv(target, pname, params);
}

/*** GetTexParameteriv ***/
static void DLM_APIENTRY passGetTexParameteriv(GLenum target, GLenum pname, GLint * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetTexParameteriv(target, pname, params);
}

/*** GetTrackMatrixivNV ***/
static void DLM_APIENTRY passGetTrackMatrixivNV(GLenum target, GLuint address, GLenum pname, GLint * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetTrackMatrixivNV(target, address, pname, params);
}

/*** GetVertexAttribPointervARB ***/
static void DLM_APIENTRY passGetVertexAttribPointervARB(GLuint index, GLenum pname, GLvoid ** pointer)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetVertexAttribPointervARB(index, pname, pointer);
}

/*** GetVertexAttribPointervNV ***/
static void DLM_APIENTRY passGetVertexAttribPointervNV(GLuint index, GLenum pname, GLvoid ** pointer)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetVertexAttribPointervNV(index, pname, pointer);
}

/*** GetVertexAttribdvARB ***/
static void DLM_APIENTRY passGetVertexAttribdvARB(GLuint index, GLenum pname, GLdouble * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetVertexAttribdvARB(index, pname, params);
}

/*** GetVertexAttribdvNV ***/
static void DLM_APIENTRY passGetVertexAttribdvNV(GLuint index, GLenum pname, GLdouble * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetVertexAttribdvNV(index, pname, params);
}

/*** GetVertexAttribfvARB ***/
static void DLM_APIENTRY passGetVertexAttribfvARB(GLuint index, GLenum pname, GLfloat * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetVertexAttribfvARB(index, pname, params);
}

/*** GetVertexAttribfvNV ***/
static void DLM_APIENTRY passGetVertexAttribfvNV(GLuint index, GLenum pname, GLfloat * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetVertexAttribfvNV(index, pname, params);
}

/*** GetVertexAttribivARB ***/
static void DLM_APIENTRY passGetVertexAttribivARB(GLuint index, GLenum pname, GLint * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetVertexAttribivARB(index, pname, params);
}

/*** GetVertexAttribivNV ***/
static void DLM_APIENTRY passGetVertexAttribivNV(GLuint index, GLenum pname, GLint * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.GetVertexAttribivNV(index, pname, params);
}

/*** Hint ***/
static void DLM_APIENTRY passHint(GLenum target, GLenum mode)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Hint(target, mode);
}
static void DLM_APIENTRY executeHint(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceHint *instance = (struct instanceHint *)x;
	dispatchTable->Hint(instance->target, instance->mode);
}
void DLM_APIENTRY crdlm_compile_Hint( GLenum target, GLenum mode )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceHint *instance;
	instance = crCalloc(sizeof(struct instanceHint));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Hint to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeHint;
	instance->target = target;
	instance->mode = mode;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** IndexMask ***/
static void DLM_APIENTRY passIndexMask(GLuint mask)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.IndexMask(mask);
}
static void DLM_APIENTRY executeIndexMask(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceIndexMask *instance = (struct instanceIndexMask *)x;
	dispatchTable->IndexMask(instance->mask);
}
void DLM_APIENTRY crdlm_compile_IndexMask( GLuint mask )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceIndexMask *instance;
	instance = crCalloc(sizeof(struct instanceIndexMask));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding IndexMask to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeIndexMask;
	instance->mask = mask;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** IndexPointer ***/
static void DLM_APIENTRY passIndexPointer(GLenum type, GLsizei stride, const GLvoid * pointer)
{
	CRDLMContextState *state = CURRENT_STATE();
	crdlmIndexPointer(type, stride, pointer, state->clientState);
	state->savedDispatchTable.IndexPointer(type, stride, pointer);
}

/*** Indexd ***/
static void DLM_APIENTRY passIndexd(GLdouble c)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Indexd(c);
}
static void DLM_APIENTRY executeIndexd(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceIndexd *instance = (struct instanceIndexd *)x;
	dispatchTable->Indexd(instance->c);
}
void DLM_APIENTRY crdlm_compile_Indexd( GLdouble c )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceIndexd *instance;
	instance = crCalloc(sizeof(struct instanceIndexd));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Indexd to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeIndexd;
	instance->c = c;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Indexdv ***/
static void DLM_APIENTRY passIndexdv(const GLdouble * c)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Indexdv(c);
}
static void DLM_APIENTRY executeIndexdv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceIndexdv *instance = (struct instanceIndexdv *)x;
	dispatchTable->Indexdv(instance->c);
}
void DLM_APIENTRY crdlm_compile_Indexdv( const GLdouble * c )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceIndexdv *instance;
	instance = crCalloc(sizeof(struct instanceIndexdv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Indexdv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeIndexdv;
	if (c == NULL) {
		instance->c = NULL;
	}
	else {
		instance->c = instance->cData;
	}
	crMemcpy((void *)instance->c, (void *) c, 1*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Indexf ***/
static void DLM_APIENTRY passIndexf(GLfloat c)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Indexf(c);
}
static void DLM_APIENTRY executeIndexf(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceIndexf *instance = (struct instanceIndexf *)x;
	dispatchTable->Indexf(instance->c);
}
void DLM_APIENTRY crdlm_compile_Indexf( GLfloat c )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceIndexf *instance;
	instance = crCalloc(sizeof(struct instanceIndexf));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Indexf to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeIndexf;
	instance->c = c;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Indexfv ***/
static void DLM_APIENTRY passIndexfv(const GLfloat * c)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Indexfv(c);
}
static void DLM_APIENTRY executeIndexfv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceIndexfv *instance = (struct instanceIndexfv *)x;
	dispatchTable->Indexfv(instance->c);
}
void DLM_APIENTRY crdlm_compile_Indexfv( const GLfloat * c )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceIndexfv *instance;
	instance = crCalloc(sizeof(struct instanceIndexfv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Indexfv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeIndexfv;
	if (c == NULL) {
		instance->c = NULL;
	}
	else {
		instance->c = instance->cData;
	}
	crMemcpy((void *)instance->c, (void *) c, 1*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Indexi ***/
static void DLM_APIENTRY passIndexi(GLint c)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Indexi(c);
}
static void DLM_APIENTRY executeIndexi(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceIndexi *instance = (struct instanceIndexi *)x;
	dispatchTable->Indexi(instance->c);
}
void DLM_APIENTRY crdlm_compile_Indexi( GLint c )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceIndexi *instance;
	instance = crCalloc(sizeof(struct instanceIndexi));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Indexi to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeIndexi;
	instance->c = c;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Indexiv ***/
static void DLM_APIENTRY passIndexiv(const GLint * c)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Indexiv(c);
}
static void DLM_APIENTRY executeIndexiv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceIndexiv *instance = (struct instanceIndexiv *)x;
	dispatchTable->Indexiv(instance->c);
}
void DLM_APIENTRY crdlm_compile_Indexiv( const GLint * c )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceIndexiv *instance;
	instance = crCalloc(sizeof(struct instanceIndexiv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Indexiv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeIndexiv;
	if (c == NULL) {
		instance->c = NULL;
	}
	else {
		instance->c = instance->cData;
	}
	crMemcpy((void *)instance->c, (void *) c, 1*sizeof(GLint));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Indexs ***/
static void DLM_APIENTRY passIndexs(GLshort c)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Indexs(c);
}
static void DLM_APIENTRY executeIndexs(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceIndexs *instance = (struct instanceIndexs *)x;
	dispatchTable->Indexs(instance->c);
}
void DLM_APIENTRY crdlm_compile_Indexs( GLshort c )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceIndexs *instance;
	instance = crCalloc(sizeof(struct instanceIndexs));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Indexs to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeIndexs;
	instance->c = c;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Indexsv ***/
static void DLM_APIENTRY passIndexsv(const GLshort * c)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Indexsv(c);
}
static void DLM_APIENTRY executeIndexsv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceIndexsv *instance = (struct instanceIndexsv *)x;
	dispatchTable->Indexsv(instance->c);
}
void DLM_APIENTRY crdlm_compile_Indexsv( const GLshort * c )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceIndexsv *instance;
	instance = crCalloc(sizeof(struct instanceIndexsv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Indexsv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeIndexsv;
	if (c == NULL) {
		instance->c = NULL;
	}
	else {
		instance->c = instance->cData;
	}
	crMemcpy((void *)instance->c, (void *) c, 1*sizeof(GLshort));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Indexub ***/
static void DLM_APIENTRY passIndexub(GLubyte c)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Indexub(c);
}
static void DLM_APIENTRY executeIndexub(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceIndexub *instance = (struct instanceIndexub *)x;
	dispatchTable->Indexub(instance->c);
}
void DLM_APIENTRY crdlm_compile_Indexub( GLubyte c )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceIndexub *instance;
	instance = crCalloc(sizeof(struct instanceIndexub));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Indexub to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeIndexub;
	instance->c = c;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Indexubv ***/
static void DLM_APIENTRY passIndexubv(const GLubyte * c)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Indexubv(c);
}
static void DLM_APIENTRY executeIndexubv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceIndexubv *instance = (struct instanceIndexubv *)x;
	dispatchTable->Indexubv(instance->c);
}
void DLM_APIENTRY crdlm_compile_Indexubv( const GLubyte * c )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceIndexubv *instance;
	instance = crCalloc(sizeof(struct instanceIndexubv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Indexubv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeIndexubv;
	if (c == NULL) {
		instance->c = NULL;
	}
	else {
		instance->c = instance->cData;
	}
	crMemcpy((void *)instance->c, (void *) c, 1*sizeof(GLubyte));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** InitNames ***/
static void DLM_APIENTRY passInitNames(void)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.InitNames();
}
static void DLM_APIENTRY executeInitNames(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	dispatchTable->InitNames();
}
void DLM_APIENTRY crdlm_compile_InitNames( void )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceInitNames *instance;
	instance = crCalloc(sizeof(struct instanceInitNames));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding InitNames to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeInitNames;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** InterleavedArrays ***/
static void DLM_APIENTRY passInterleavedArrays(GLenum format, GLsizei stride, const GLvoid * pointer)
{
	CRDLMContextState *state = CURRENT_STATE();
	crdlmInterleavedArrays(format, stride, pointer, state->clientState);
	state->savedDispatchTable.InterleavedArrays(format, stride, pointer);
}

/*** IsBufferARB ***/
static GLboolean DLM_APIENTRY passIsBufferARB(GLuint buffer)
{
	CRDLMContextState *state = CURRENT_STATE();
	return state->savedDispatchTable.IsBufferARB(buffer);
}

/*** IsEnabled ***/
static GLboolean DLM_APIENTRY passIsEnabled(GLenum cap)
{
	CRDLMContextState *state = CURRENT_STATE();
	return state->savedDispatchTable.IsEnabled(cap);
}

/*** IsFenceNV ***/
static GLboolean DLM_APIENTRY passIsFenceNV(GLuint fence)
{
	CRDLMContextState *state = CURRENT_STATE();
	return state->savedDispatchTable.IsFenceNV(fence);
}

/*** IsList ***/
static GLboolean DLM_APIENTRY passIsList(GLuint list)
{
	CRDLMContextState *state = CURRENT_STATE();
	return state->savedDispatchTable.IsList(list);
}

/*** IsProgramARB ***/
static GLboolean DLM_APIENTRY passIsProgramARB(GLuint program)
{
	CRDLMContextState *state = CURRENT_STATE();
	return state->savedDispatchTable.IsProgramARB(program);
}

/*** IsQueryARB ***/
static GLboolean DLM_APIENTRY passIsQueryARB(GLuint id)
{
	CRDLMContextState *state = CURRENT_STATE();
	return state->savedDispatchTable.IsQueryARB(id);
}

/*** IsTexture ***/
static GLboolean DLM_APIENTRY passIsTexture(GLuint texture)
{
	CRDLMContextState *state = CURRENT_STATE();
	return state->savedDispatchTable.IsTexture(texture);
}

/*** LightModelf ***/
static void DLM_APIENTRY passLightModelf(GLenum pname, GLfloat param)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.LightModelf(pname, param);
}
static void DLM_APIENTRY executeLightModelf(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceLightModelf *instance = (struct instanceLightModelf *)x;
	dispatchTable->LightModelf(instance->pname, instance->param);
}
void DLM_APIENTRY crdlm_compile_LightModelf( GLenum pname, GLfloat param )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceLightModelf *instance;
	instance = crCalloc(sizeof(struct instanceLightModelf));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding LightModelf to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeLightModelf;
	instance->pname = pname;
	instance->param = param;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** LightModelfv ***/
static void DLM_APIENTRY passLightModelfv(GLenum pname, const GLfloat * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.LightModelfv(pname, params);
}
static void DLM_APIENTRY executeLightModelfv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceLightModelfv *instance = (struct instanceLightModelfv *)x;
	dispatchTable->LightModelfv(instance->pname, instance->params);
}
void DLM_APIENTRY crdlm_compile_LightModelfv( GLenum pname, const GLfloat * params )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceLightModelfv *instance;
	instance = crCalloc(sizeof(struct instanceLightModelfv) + crdlm_pointers_LightModelfv(NULL, pname, params));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding LightModelfv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeLightModelfv;
	instance->pname = pname;
	if (params == NULL) {
		instance->params = NULL;
	}
	else {
		instance->params = instance->paramsData;
	}
	(void) crdlm_pointers_LightModelfv(instance, pname, params);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** LightModeli ***/
static void DLM_APIENTRY passLightModeli(GLenum pname, GLint param)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.LightModeli(pname, param);
}
static void DLM_APIENTRY executeLightModeli(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceLightModeli *instance = (struct instanceLightModeli *)x;
	dispatchTable->LightModeli(instance->pname, instance->param);
}
void DLM_APIENTRY crdlm_compile_LightModeli( GLenum pname, GLint param )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceLightModeli *instance;
	instance = crCalloc(sizeof(struct instanceLightModeli));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding LightModeli to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeLightModeli;
	instance->pname = pname;
	instance->param = param;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** LightModeliv ***/
static void DLM_APIENTRY passLightModeliv(GLenum pname, const GLint * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.LightModeliv(pname, params);
}
static void DLM_APIENTRY executeLightModeliv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceLightModeliv *instance = (struct instanceLightModeliv *)x;
	dispatchTable->LightModeliv(instance->pname, instance->params);
}
void DLM_APIENTRY crdlm_compile_LightModeliv( GLenum pname, const GLint * params )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceLightModeliv *instance;
	instance = crCalloc(sizeof(struct instanceLightModeliv) + crdlm_pointers_LightModeliv(NULL, pname, params));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding LightModeliv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeLightModeliv;
	instance->pname = pname;
	if (params == NULL) {
		instance->params = NULL;
	}
	else {
		instance->params = instance->paramsData;
	}
	(void) crdlm_pointers_LightModeliv(instance, pname, params);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Lightf ***/
static void DLM_APIENTRY passLightf(GLenum light, GLenum pname, GLfloat param)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Lightf(light, pname, param);
}
static void DLM_APIENTRY executeLightf(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceLightf *instance = (struct instanceLightf *)x;
	dispatchTable->Lightf(instance->light, instance->pname, instance->param);
}
void DLM_APIENTRY crdlm_compile_Lightf( GLenum light, GLenum pname, GLfloat param )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceLightf *instance;
	instance = crCalloc(sizeof(struct instanceLightf));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Lightf to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeLightf;
	instance->light = light;
	instance->pname = pname;
	instance->param = param;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Lightfv ***/
static void DLM_APIENTRY passLightfv(GLenum light, GLenum pname, const GLfloat * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Lightfv(light, pname, params);
}
static void DLM_APIENTRY executeLightfv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceLightfv *instance = (struct instanceLightfv *)x;
	dispatchTable->Lightfv(instance->light, instance->pname, instance->params);
}
void DLM_APIENTRY crdlm_compile_Lightfv( GLenum light, GLenum pname, const GLfloat * params )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceLightfv *instance;
	instance = crCalloc(sizeof(struct instanceLightfv) + crdlm_pointers_Lightfv(NULL, light, pname, params));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Lightfv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeLightfv;
	instance->light = light;
	instance->pname = pname;
	if (params == NULL) {
		instance->params = NULL;
	}
	else {
		instance->params = instance->paramsData;
	}
	(void) crdlm_pointers_Lightfv(instance, light, pname, params);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Lighti ***/
static void DLM_APIENTRY passLighti(GLenum light, GLenum pname, GLint param)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Lighti(light, pname, param);
}
static void DLM_APIENTRY executeLighti(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceLighti *instance = (struct instanceLighti *)x;
	dispatchTable->Lighti(instance->light, instance->pname, instance->param);
}
void DLM_APIENTRY crdlm_compile_Lighti( GLenum light, GLenum pname, GLint param )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceLighti *instance;
	instance = crCalloc(sizeof(struct instanceLighti));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Lighti to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeLighti;
	instance->light = light;
	instance->pname = pname;
	instance->param = param;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Lightiv ***/
static void DLM_APIENTRY passLightiv(GLenum light, GLenum pname, const GLint * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Lightiv(light, pname, params);
}
static void DLM_APIENTRY executeLightiv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceLightiv *instance = (struct instanceLightiv *)x;
	dispatchTable->Lightiv(instance->light, instance->pname, instance->params);
}
void DLM_APIENTRY crdlm_compile_Lightiv( GLenum light, GLenum pname, const GLint * params )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceLightiv *instance;
	instance = crCalloc(sizeof(struct instanceLightiv) + crdlm_pointers_Lightiv(NULL, light, pname, params));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Lightiv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeLightiv;
	instance->light = light;
	instance->pname = pname;
	if (params == NULL) {
		instance->params = NULL;
	}
	else {
		instance->params = instance->paramsData;
	}
	(void) crdlm_pointers_Lightiv(instance, light, pname, params);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** LineStipple ***/
static void DLM_APIENTRY passLineStipple(GLint factor, GLushort pattern)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.LineStipple(factor, pattern);
}
static void DLM_APIENTRY executeLineStipple(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceLineStipple *instance = (struct instanceLineStipple *)x;
	dispatchTable->LineStipple(instance->factor, instance->pattern);
}
void DLM_APIENTRY crdlm_compile_LineStipple( GLint factor, GLushort pattern )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceLineStipple *instance;
	instance = crCalloc(sizeof(struct instanceLineStipple));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding LineStipple to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeLineStipple;
	instance->factor = factor;
	instance->pattern = pattern;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** LineWidth ***/
static void DLM_APIENTRY passLineWidth(GLfloat width)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.LineWidth(width);
}
static void DLM_APIENTRY executeLineWidth(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceLineWidth *instance = (struct instanceLineWidth *)x;
	dispatchTable->LineWidth(instance->width);
}
void DLM_APIENTRY crdlm_compile_LineWidth( GLfloat width )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceLineWidth *instance;
	instance = crCalloc(sizeof(struct instanceLineWidth));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding LineWidth to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeLineWidth;
	instance->width = width;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** ListBase ***/
static void DLM_APIENTRY passListBase(GLuint base)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ListBase(base);
}
static void DLM_APIENTRY executeListBase(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceListBase *instance = (struct instanceListBase *)x;
	dispatchTable->ListBase(instance->base);
}
void DLM_APIENTRY crdlm_compile_ListBase( GLuint base )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceListBase *instance;
	instance = crCalloc(sizeof(struct instanceListBase));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding ListBase to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeListBase;
	instance->base = base;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** LoadIdentity ***/
static void DLM_APIENTRY passLoadIdentity(void)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.LoadIdentity();
}
static void DLM_APIENTRY executeLoadIdentity(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	dispatchTable->LoadIdentity();
}
void DLM_APIENTRY crdlm_compile_LoadIdentity( void )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceLoadIdentity *instance;
	instance = crCalloc(sizeof(struct instanceLoadIdentity));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding LoadIdentity to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeLoadIdentity;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** LoadMatrixd ***/
static void DLM_APIENTRY passLoadMatrixd(const GLdouble * m)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.LoadMatrixd(m);
}
static void DLM_APIENTRY executeLoadMatrixd(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceLoadMatrixd *instance = (struct instanceLoadMatrixd *)x;
	dispatchTable->LoadMatrixd(instance->m);
}
void DLM_APIENTRY crdlm_compile_LoadMatrixd( const GLdouble * m )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceLoadMatrixd *instance;
	instance = crCalloc(sizeof(struct instanceLoadMatrixd));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding LoadMatrixd to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeLoadMatrixd;
	if (m == NULL) {
		instance->m = NULL;
	}
	else {
		instance->m = instance->mData;
	}
	crMemcpy((void *)instance->m, (void *) m, 16*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** LoadMatrixf ***/
static void DLM_APIENTRY passLoadMatrixf(const GLfloat * m)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.LoadMatrixf(m);
}
static void DLM_APIENTRY executeLoadMatrixf(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceLoadMatrixf *instance = (struct instanceLoadMatrixf *)x;
	dispatchTable->LoadMatrixf(instance->m);
}
void DLM_APIENTRY crdlm_compile_LoadMatrixf( const GLfloat * m )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceLoadMatrixf *instance;
	instance = crCalloc(sizeof(struct instanceLoadMatrixf));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding LoadMatrixf to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeLoadMatrixf;
	if (m == NULL) {
		instance->m = NULL;
	}
	else {
		instance->m = instance->mData;
	}
	crMemcpy((void *)instance->m, (void *) m, 16*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** LoadName ***/
static void DLM_APIENTRY passLoadName(GLuint name)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.LoadName(name);
}
static void DLM_APIENTRY executeLoadName(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceLoadName *instance = (struct instanceLoadName *)x;
	dispatchTable->LoadName(instance->name);
}
void DLM_APIENTRY crdlm_compile_LoadName( GLuint name )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceLoadName *instance;
	instance = crCalloc(sizeof(struct instanceLoadName));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding LoadName to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeLoadName;
	instance->name = name;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** LoadProgramNV ***/
static void DLM_APIENTRY passLoadProgramNV(GLenum target, GLuint id, GLsizei len, const GLubyte * program)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.LoadProgramNV(target, id, len, program);
}
static void DLM_APIENTRY executeLoadProgramNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceLoadProgramNV *instance = (struct instanceLoadProgramNV *)x;
	dispatchTable->LoadProgramNV(instance->target, instance->id, instance->len, instance->program);
}
void DLM_APIENTRY crdlm_compile_LoadProgramNV( GLenum target, GLuint id, GLsizei len, const GLubyte * program )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceLoadProgramNV *instance;
	instance = crCalloc(sizeof(struct instanceLoadProgramNV) + crdlm_pointers_LoadProgramNV(NULL, target, id, len, program));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding LoadProgramNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeLoadProgramNV;
	instance->target = target;
	instance->id = id;
	instance->len = len;
	if (program == NULL) {
		instance->program = NULL;
	}
	else {
		instance->program = instance->programData;
	}
	(void) crdlm_pointers_LoadProgramNV(instance, target, id, len, program);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** LoadTransposeMatrixdARB ***/
static void DLM_APIENTRY passLoadTransposeMatrixdARB(const GLdouble * m)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.LoadTransposeMatrixdARB(m);
}
static void DLM_APIENTRY executeLoadTransposeMatrixdARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceLoadTransposeMatrixdARB *instance = (struct instanceLoadTransposeMatrixdARB *)x;
	dispatchTable->LoadTransposeMatrixdARB(instance->m);
}
void DLM_APIENTRY crdlm_compile_LoadTransposeMatrixdARB( const GLdouble * m )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceLoadTransposeMatrixdARB *instance;
	instance = crCalloc(sizeof(struct instanceLoadTransposeMatrixdARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding LoadTransposeMatrixdARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeLoadTransposeMatrixdARB;
	if (m == NULL) {
		instance->m = NULL;
	}
	else {
		instance->m = instance->mData;
	}
	crMemcpy((void *)instance->m, (void *) m, 16*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** LoadTransposeMatrixfARB ***/
static void DLM_APIENTRY passLoadTransposeMatrixfARB(const GLfloat * m)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.LoadTransposeMatrixfARB(m);
}
static void DLM_APIENTRY executeLoadTransposeMatrixfARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceLoadTransposeMatrixfARB *instance = (struct instanceLoadTransposeMatrixfARB *)x;
	dispatchTable->LoadTransposeMatrixfARB(instance->m);
}
void DLM_APIENTRY crdlm_compile_LoadTransposeMatrixfARB( const GLfloat * m )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceLoadTransposeMatrixfARB *instance;
	instance = crCalloc(sizeof(struct instanceLoadTransposeMatrixfARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding LoadTransposeMatrixfARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeLoadTransposeMatrixfARB;
	if (m == NULL) {
		instance->m = NULL;
	}
	else {
		instance->m = instance->mData;
	}
	crMemcpy((void *)instance->m, (void *) m, 16*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** LogicOp ***/
static void DLM_APIENTRY passLogicOp(GLenum opcode)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.LogicOp(opcode);
}
static void DLM_APIENTRY executeLogicOp(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceLogicOp *instance = (struct instanceLogicOp *)x;
	dispatchTable->LogicOp(instance->opcode);
}
void DLM_APIENTRY crdlm_compile_LogicOp( GLenum opcode )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceLogicOp *instance;
	instance = crCalloc(sizeof(struct instanceLogicOp));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding LogicOp to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeLogicOp;
	instance->opcode = opcode;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MakeCurrent ***/
static void DLM_APIENTRY passMakeCurrent(GLint window, GLint nativeWindow, GLint ctx)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MakeCurrent(window, nativeWindow, ctx);
}

/*** Map1d ***/
static void DLM_APIENTRY passMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble * points)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Map1d(target, u1, u2, stride, order, points);
}
static void DLM_APIENTRY executeMap1d(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMap1d *instance = (struct instanceMap1d *)x;
	dispatchTable->Map1d(instance->target, instance->u1, instance->u2, instance->stride, instance->order, instance->points);
}
void DLM_APIENTRY crdlm_compile_Map1d( GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble * points )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMap1d *instance;
	instance = crCalloc(sizeof(struct instanceMap1d) + crdlm_pointers_Map1d(NULL, target, u1, u2, stride, order, points));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Map1d to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMap1d;
	instance->target = target;
	instance->u1 = u1;
	instance->u2 = u2;
	instance->stride = stride;
	instance->order = order;
	if (points == NULL) {
		instance->points = NULL;
	}
	else {
		instance->points = instance->pointsData;
	}
	(void) crdlm_pointers_Map1d(instance, target, u1, u2, stride, order, points);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Map1f ***/
static void DLM_APIENTRY passMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat * points)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Map1f(target, u1, u2, stride, order, points);
}
static void DLM_APIENTRY executeMap1f(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMap1f *instance = (struct instanceMap1f *)x;
	dispatchTable->Map1f(instance->target, instance->u1, instance->u2, instance->stride, instance->order, instance->points);
}
void DLM_APIENTRY crdlm_compile_Map1f( GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat * points )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMap1f *instance;
	instance = crCalloc(sizeof(struct instanceMap1f) + crdlm_pointers_Map1f(NULL, target, u1, u2, stride, order, points));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Map1f to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMap1f;
	instance->target = target;
	instance->u1 = u1;
	instance->u2 = u2;
	instance->stride = stride;
	instance->order = order;
	if (points == NULL) {
		instance->points = NULL;
	}
	else {
		instance->points = instance->pointsData;
	}
	(void) crdlm_pointers_Map1f(instance, target, u1, u2, stride, order, points);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Map2d ***/
static void DLM_APIENTRY passMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble * points)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Map2d(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
}
static void DLM_APIENTRY executeMap2d(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMap2d *instance = (struct instanceMap2d *)x;
	dispatchTable->Map2d(instance->target, instance->u1, instance->u2, instance->ustride, instance->uorder, instance->v1, instance->v2, instance->vstride, instance->vorder, instance->points);
}
void DLM_APIENTRY crdlm_compile_Map2d( GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble * points )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMap2d *instance;
	instance = crCalloc(sizeof(struct instanceMap2d) + crdlm_pointers_Map2d(NULL, target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Map2d to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMap2d;
	instance->target = target;
	instance->u1 = u1;
	instance->u2 = u2;
	instance->ustride = ustride;
	instance->uorder = uorder;
	instance->v1 = v1;
	instance->v2 = v2;
	instance->vstride = vstride;
	instance->vorder = vorder;
	if (points == NULL) {
		instance->points = NULL;
	}
	else {
		instance->points = instance->pointsData;
	}
	(void) crdlm_pointers_Map2d(instance, target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Map2f ***/
static void DLM_APIENTRY passMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat * points)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Map2f(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
}
static void DLM_APIENTRY executeMap2f(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMap2f *instance = (struct instanceMap2f *)x;
	dispatchTable->Map2f(instance->target, instance->u1, instance->u2, instance->ustride, instance->uorder, instance->v1, instance->v2, instance->vstride, instance->vorder, instance->points);
}
void DLM_APIENTRY crdlm_compile_Map2f( GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat * points )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMap2f *instance;
	instance = crCalloc(sizeof(struct instanceMap2f) + crdlm_pointers_Map2f(NULL, target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Map2f to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMap2f;
	instance->target = target;
	instance->u1 = u1;
	instance->u2 = u2;
	instance->ustride = ustride;
	instance->uorder = uorder;
	instance->v1 = v1;
	instance->v2 = v2;
	instance->vstride = vstride;
	instance->vorder = vorder;
	if (points == NULL) {
		instance->points = NULL;
	}
	else {
		instance->points = instance->pointsData;
	}
	(void) crdlm_pointers_Map2f(instance, target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MapBufferARB ***/
static void * DLM_APIENTRY passMapBufferARB(GLenum target, GLenum access)
{
	CRDLMContextState *state = CURRENT_STATE();
	return state->savedDispatchTable.MapBufferARB(target, access);
}

/*** MapGrid1d ***/
static void DLM_APIENTRY passMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MapGrid1d(un, u1, u2);
}
static void DLM_APIENTRY executeMapGrid1d(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMapGrid1d *instance = (struct instanceMapGrid1d *)x;
	dispatchTable->MapGrid1d(instance->un, instance->u1, instance->u2);
}
void DLM_APIENTRY crdlm_compile_MapGrid1d( GLint un, GLdouble u1, GLdouble u2 )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMapGrid1d *instance;
	instance = crCalloc(sizeof(struct instanceMapGrid1d));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MapGrid1d to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMapGrid1d;
	instance->un = un;
	instance->u1 = u1;
	instance->u2 = u2;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MapGrid1f ***/
static void DLM_APIENTRY passMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MapGrid1f(un, u1, u2);
}
static void DLM_APIENTRY executeMapGrid1f(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMapGrid1f *instance = (struct instanceMapGrid1f *)x;
	dispatchTable->MapGrid1f(instance->un, instance->u1, instance->u2);
}
void DLM_APIENTRY crdlm_compile_MapGrid1f( GLint un, GLfloat u1, GLfloat u2 )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMapGrid1f *instance;
	instance = crCalloc(sizeof(struct instanceMapGrid1f));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MapGrid1f to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMapGrid1f;
	instance->un = un;
	instance->u1 = u1;
	instance->u2 = u2;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MapGrid2d ***/
static void DLM_APIENTRY passMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MapGrid2d(un, u1, u2, vn, v1, v2);
}
static void DLM_APIENTRY executeMapGrid2d(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMapGrid2d *instance = (struct instanceMapGrid2d *)x;
	dispatchTable->MapGrid2d(instance->un, instance->u1, instance->u2, instance->vn, instance->v1, instance->v2);
}
void DLM_APIENTRY crdlm_compile_MapGrid2d( GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2 )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMapGrid2d *instance;
	instance = crCalloc(sizeof(struct instanceMapGrid2d));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MapGrid2d to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMapGrid2d;
	instance->un = un;
	instance->u1 = u1;
	instance->u2 = u2;
	instance->vn = vn;
	instance->v1 = v1;
	instance->v2 = v2;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MapGrid2f ***/
static void DLM_APIENTRY passMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MapGrid2f(un, u1, u2, vn, v1, v2);
}
static void DLM_APIENTRY executeMapGrid2f(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMapGrid2f *instance = (struct instanceMapGrid2f *)x;
	dispatchTable->MapGrid2f(instance->un, instance->u1, instance->u2, instance->vn, instance->v1, instance->v2);
}
void DLM_APIENTRY crdlm_compile_MapGrid2f( GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2 )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMapGrid2f *instance;
	instance = crCalloc(sizeof(struct instanceMapGrid2f));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MapGrid2f to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMapGrid2f;
	instance->un = un;
	instance->u1 = u1;
	instance->u2 = u2;
	instance->vn = vn;
	instance->v1 = v1;
	instance->v2 = v2;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Materialf ***/
static void DLM_APIENTRY passMaterialf(GLenum face, GLenum pname, GLfloat param)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Materialf(face, pname, param);
}
static void DLM_APIENTRY executeMaterialf(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMaterialf *instance = (struct instanceMaterialf *)x;
	dispatchTable->Materialf(instance->face, instance->pname, instance->param);
}
void DLM_APIENTRY crdlm_compile_Materialf( GLenum face, GLenum pname, GLfloat param )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMaterialf *instance;
	instance = crCalloc(sizeof(struct instanceMaterialf));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Materialf to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMaterialf;
	instance->face = face;
	instance->pname = pname;
	instance->param = param;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Materialfv ***/
static void DLM_APIENTRY passMaterialfv(GLenum face, GLenum pname, const GLfloat * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Materialfv(face, pname, params);
}
static void DLM_APIENTRY executeMaterialfv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMaterialfv *instance = (struct instanceMaterialfv *)x;
	dispatchTable->Materialfv(instance->face, instance->pname, instance->params);
}
void DLM_APIENTRY crdlm_compile_Materialfv( GLenum face, GLenum pname, const GLfloat * params )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMaterialfv *instance;
	instance = crCalloc(sizeof(struct instanceMaterialfv) + crdlm_pointers_Materialfv(NULL, face, pname, params));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Materialfv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMaterialfv;
	instance->face = face;
	instance->pname = pname;
	if (params == NULL) {
		instance->params = NULL;
	}
	else {
		instance->params = instance->paramsData;
	}
	(void) crdlm_pointers_Materialfv(instance, face, pname, params);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Materiali ***/
static void DLM_APIENTRY passMateriali(GLenum face, GLenum pname, GLint param)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Materiali(face, pname, param);
}
static void DLM_APIENTRY executeMateriali(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMateriali *instance = (struct instanceMateriali *)x;
	dispatchTable->Materiali(instance->face, instance->pname, instance->param);
}
void DLM_APIENTRY crdlm_compile_Materiali( GLenum face, GLenum pname, GLint param )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMateriali *instance;
	instance = crCalloc(sizeof(struct instanceMateriali));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Materiali to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMateriali;
	instance->face = face;
	instance->pname = pname;
	instance->param = param;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Materialiv ***/
static void DLM_APIENTRY passMaterialiv(GLenum face, GLenum pname, const GLint * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Materialiv(face, pname, params);
}
static void DLM_APIENTRY executeMaterialiv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMaterialiv *instance = (struct instanceMaterialiv *)x;
	dispatchTable->Materialiv(instance->face, instance->pname, instance->params);
}
void DLM_APIENTRY crdlm_compile_Materialiv( GLenum face, GLenum pname, const GLint * params )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMaterialiv *instance;
	instance = crCalloc(sizeof(struct instanceMaterialiv) + crdlm_pointers_Materialiv(NULL, face, pname, params));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Materialiv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMaterialiv;
	instance->face = face;
	instance->pname = pname;
	if (params == NULL) {
		instance->params = NULL;
	}
	else {
		instance->params = instance->paramsData;
	}
	(void) crdlm_pointers_Materialiv(instance, face, pname, params);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MatrixMode ***/
static void DLM_APIENTRY passMatrixMode(GLenum mode)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MatrixMode(mode);
}
static void DLM_APIENTRY executeMatrixMode(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMatrixMode *instance = (struct instanceMatrixMode *)x;
	dispatchTable->MatrixMode(instance->mode);
}
void DLM_APIENTRY crdlm_compile_MatrixMode( GLenum mode )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMatrixMode *instance;
	instance = crCalloc(sizeof(struct instanceMatrixMode));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MatrixMode to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMatrixMode;
	instance->mode = mode;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultMatrixd ***/
static void DLM_APIENTRY passMultMatrixd(const GLdouble * m)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultMatrixd(m);
}
static void DLM_APIENTRY executeMultMatrixd(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultMatrixd *instance = (struct instanceMultMatrixd *)x;
	dispatchTable->MultMatrixd(instance->m);
}
void DLM_APIENTRY crdlm_compile_MultMatrixd( const GLdouble * m )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultMatrixd *instance;
	instance = crCalloc(sizeof(struct instanceMultMatrixd));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultMatrixd to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultMatrixd;
	if (m == NULL) {
		instance->m = NULL;
	}
	else {
		instance->m = instance->mData;
	}
	crMemcpy((void *)instance->m, (void *) m, 16*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultMatrixf ***/
static void DLM_APIENTRY passMultMatrixf(const GLfloat * m)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultMatrixf(m);
}
static void DLM_APIENTRY executeMultMatrixf(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultMatrixf *instance = (struct instanceMultMatrixf *)x;
	dispatchTable->MultMatrixf(instance->m);
}
void DLM_APIENTRY crdlm_compile_MultMatrixf( const GLfloat * m )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultMatrixf *instance;
	instance = crCalloc(sizeof(struct instanceMultMatrixf));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultMatrixf to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultMatrixf;
	if (m == NULL) {
		instance->m = NULL;
	}
	else {
		instance->m = instance->mData;
	}
	crMemcpy((void *)instance->m, (void *) m, 16*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultTransposeMatrixdARB ***/
static void DLM_APIENTRY passMultTransposeMatrixdARB(const GLdouble * m)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultTransposeMatrixdARB(m);
}
static void DLM_APIENTRY executeMultTransposeMatrixdARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultTransposeMatrixdARB *instance = (struct instanceMultTransposeMatrixdARB *)x;
	dispatchTable->MultTransposeMatrixdARB(instance->m);
}
void DLM_APIENTRY crdlm_compile_MultTransposeMatrixdARB( const GLdouble * m )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultTransposeMatrixdARB *instance;
	instance = crCalloc(sizeof(struct instanceMultTransposeMatrixdARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultTransposeMatrixdARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultTransposeMatrixdARB;
	if (m == NULL) {
		instance->m = NULL;
	}
	else {
		instance->m = instance->mData;
	}
	crMemcpy((void *)instance->m, (void *) m, 16*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultTransposeMatrixfARB ***/
static void DLM_APIENTRY passMultTransposeMatrixfARB(const GLfloat * m)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultTransposeMatrixfARB(m);
}
static void DLM_APIENTRY executeMultTransposeMatrixfARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultTransposeMatrixfARB *instance = (struct instanceMultTransposeMatrixfARB *)x;
	dispatchTable->MultTransposeMatrixfARB(instance->m);
}
void DLM_APIENTRY crdlm_compile_MultTransposeMatrixfARB( const GLfloat * m )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultTransposeMatrixfARB *instance;
	instance = crCalloc(sizeof(struct instanceMultTransposeMatrixfARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultTransposeMatrixfARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultTransposeMatrixfARB;
	if (m == NULL) {
		instance->m = NULL;
	}
	else {
		instance->m = instance->mData;
	}
	crMemcpy((void *)instance->m, (void *) m, 16*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultiDrawArraysEXT ***/
static void DLM_APIENTRY passMultiDrawArraysEXT(GLenum mode, GLint * first, GLsizei * count, GLsizei primcount)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultiDrawArraysEXT(mode, first, count, primcount);
}

/*** MultiDrawElementsEXT ***/
static void DLM_APIENTRY passMultiDrawElementsEXT(GLenum mode, const GLsizei * count, GLenum type, const GLvoid ** indices, GLsizei primcount)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultiDrawElementsEXT(mode, count, type, indices, primcount);
}

/*** MultiTexCoord1dARB ***/
static void DLM_APIENTRY passMultiTexCoord1dARB(GLenum texture, GLdouble s)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultiTexCoord1dARB(texture, s);
}
static void DLM_APIENTRY executeMultiTexCoord1dARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultiTexCoord1dARB *instance = (struct instanceMultiTexCoord1dARB *)x;
	dispatchTable->MultiTexCoord1dARB(instance->texture, instance->s);
}
void DLM_APIENTRY crdlm_compile_MultiTexCoord1dARB( GLenum texture, GLdouble s )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultiTexCoord1dARB *instance;
	instance = crCalloc(sizeof(struct instanceMultiTexCoord1dARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultiTexCoord1dARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultiTexCoord1dARB;
	instance->texture = texture;
	instance->s = s;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultiTexCoord1dvARB ***/
static void DLM_APIENTRY passMultiTexCoord1dvARB(GLenum texture, const GLdouble * t)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultiTexCoord1dvARB(texture, t);
}
static void DLM_APIENTRY executeMultiTexCoord1dvARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultiTexCoord1dvARB *instance = (struct instanceMultiTexCoord1dvARB *)x;
	dispatchTable->MultiTexCoord1dvARB(instance->texture, instance->t);
}
void DLM_APIENTRY crdlm_compile_MultiTexCoord1dvARB( GLenum texture, const GLdouble * t )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultiTexCoord1dvARB *instance;
	instance = crCalloc(sizeof(struct instanceMultiTexCoord1dvARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultiTexCoord1dvARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultiTexCoord1dvARB;
	instance->texture = texture;
	if (t == NULL) {
		instance->t = NULL;
	}
	else {
		instance->t = instance->tData;
	}
	crMemcpy((void *)instance->t, (void *) t, 1*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultiTexCoord1fARB ***/
static void DLM_APIENTRY passMultiTexCoord1fARB(GLenum texture, GLfloat s)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultiTexCoord1fARB(texture, s);
}
static void DLM_APIENTRY executeMultiTexCoord1fARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultiTexCoord1fARB *instance = (struct instanceMultiTexCoord1fARB *)x;
	dispatchTable->MultiTexCoord1fARB(instance->texture, instance->s);
}
void DLM_APIENTRY crdlm_compile_MultiTexCoord1fARB( GLenum texture, GLfloat s )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultiTexCoord1fARB *instance;
	instance = crCalloc(sizeof(struct instanceMultiTexCoord1fARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultiTexCoord1fARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultiTexCoord1fARB;
	instance->texture = texture;
	instance->s = s;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultiTexCoord1fvARB ***/
static void DLM_APIENTRY passMultiTexCoord1fvARB(GLenum texture, const GLfloat * t)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultiTexCoord1fvARB(texture, t);
}
static void DLM_APIENTRY executeMultiTexCoord1fvARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultiTexCoord1fvARB *instance = (struct instanceMultiTexCoord1fvARB *)x;
	dispatchTable->MultiTexCoord1fvARB(instance->texture, instance->t);
}
void DLM_APIENTRY crdlm_compile_MultiTexCoord1fvARB( GLenum texture, const GLfloat * t )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultiTexCoord1fvARB *instance;
	instance = crCalloc(sizeof(struct instanceMultiTexCoord1fvARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultiTexCoord1fvARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultiTexCoord1fvARB;
	instance->texture = texture;
	if (t == NULL) {
		instance->t = NULL;
	}
	else {
		instance->t = instance->tData;
	}
	crMemcpy((void *)instance->t, (void *) t, 1*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultiTexCoord1iARB ***/
static void DLM_APIENTRY passMultiTexCoord1iARB(GLenum texture, GLint s)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultiTexCoord1iARB(texture, s);
}
static void DLM_APIENTRY executeMultiTexCoord1iARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultiTexCoord1iARB *instance = (struct instanceMultiTexCoord1iARB *)x;
	dispatchTable->MultiTexCoord1iARB(instance->texture, instance->s);
}
void DLM_APIENTRY crdlm_compile_MultiTexCoord1iARB( GLenum texture, GLint s )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultiTexCoord1iARB *instance;
	instance = crCalloc(sizeof(struct instanceMultiTexCoord1iARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultiTexCoord1iARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultiTexCoord1iARB;
	instance->texture = texture;
	instance->s = s;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultiTexCoord1ivARB ***/
static void DLM_APIENTRY passMultiTexCoord1ivARB(GLenum texture, const GLint * t)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultiTexCoord1ivARB(texture, t);
}
static void DLM_APIENTRY executeMultiTexCoord1ivARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultiTexCoord1ivARB *instance = (struct instanceMultiTexCoord1ivARB *)x;
	dispatchTable->MultiTexCoord1ivARB(instance->texture, instance->t);
}
void DLM_APIENTRY crdlm_compile_MultiTexCoord1ivARB( GLenum texture, const GLint * t )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultiTexCoord1ivARB *instance;
	instance = crCalloc(sizeof(struct instanceMultiTexCoord1ivARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultiTexCoord1ivARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultiTexCoord1ivARB;
	instance->texture = texture;
	if (t == NULL) {
		instance->t = NULL;
	}
	else {
		instance->t = instance->tData;
	}
	crMemcpy((void *)instance->t, (void *) t, 1*sizeof(GLint));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultiTexCoord1sARB ***/
static void DLM_APIENTRY passMultiTexCoord1sARB(GLenum texture, GLshort s)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultiTexCoord1sARB(texture, s);
}
static void DLM_APIENTRY executeMultiTexCoord1sARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultiTexCoord1sARB *instance = (struct instanceMultiTexCoord1sARB *)x;
	dispatchTable->MultiTexCoord1sARB(instance->texture, instance->s);
}
void DLM_APIENTRY crdlm_compile_MultiTexCoord1sARB( GLenum texture, GLshort s )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultiTexCoord1sARB *instance;
	instance = crCalloc(sizeof(struct instanceMultiTexCoord1sARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultiTexCoord1sARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultiTexCoord1sARB;
	instance->texture = texture;
	instance->s = s;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultiTexCoord1svARB ***/
static void DLM_APIENTRY passMultiTexCoord1svARB(GLenum texture, const GLshort * t)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultiTexCoord1svARB(texture, t);
}
static void DLM_APIENTRY executeMultiTexCoord1svARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultiTexCoord1svARB *instance = (struct instanceMultiTexCoord1svARB *)x;
	dispatchTable->MultiTexCoord1svARB(instance->texture, instance->t);
}
void DLM_APIENTRY crdlm_compile_MultiTexCoord1svARB( GLenum texture, const GLshort * t )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultiTexCoord1svARB *instance;
	instance = crCalloc(sizeof(struct instanceMultiTexCoord1svARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultiTexCoord1svARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultiTexCoord1svARB;
	instance->texture = texture;
	if (t == NULL) {
		instance->t = NULL;
	}
	else {
		instance->t = instance->tData;
	}
	crMemcpy((void *)instance->t, (void *) t, 1*sizeof(GLshort));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultiTexCoord2dARB ***/
static void DLM_APIENTRY passMultiTexCoord2dARB(GLenum texture, GLdouble s, GLdouble t)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultiTexCoord2dARB(texture, s, t);
}
static void DLM_APIENTRY executeMultiTexCoord2dARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultiTexCoord2dARB *instance = (struct instanceMultiTexCoord2dARB *)x;
	dispatchTable->MultiTexCoord2dARB(instance->texture, instance->s, instance->t);
}
void DLM_APIENTRY crdlm_compile_MultiTexCoord2dARB( GLenum texture, GLdouble s, GLdouble t )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultiTexCoord2dARB *instance;
	instance = crCalloc(sizeof(struct instanceMultiTexCoord2dARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultiTexCoord2dARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultiTexCoord2dARB;
	instance->texture = texture;
	instance->s = s;
	instance->t = t;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultiTexCoord2dvARB ***/
static void DLM_APIENTRY passMultiTexCoord2dvARB(GLenum texture, const GLdouble * t)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultiTexCoord2dvARB(texture, t);
}
static void DLM_APIENTRY executeMultiTexCoord2dvARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultiTexCoord2dvARB *instance = (struct instanceMultiTexCoord2dvARB *)x;
	dispatchTable->MultiTexCoord2dvARB(instance->texture, instance->t);
}
void DLM_APIENTRY crdlm_compile_MultiTexCoord2dvARB( GLenum texture, const GLdouble * t )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultiTexCoord2dvARB *instance;
	instance = crCalloc(sizeof(struct instanceMultiTexCoord2dvARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultiTexCoord2dvARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultiTexCoord2dvARB;
	instance->texture = texture;
	if (t == NULL) {
		instance->t = NULL;
	}
	else {
		instance->t = instance->tData;
	}
	crMemcpy((void *)instance->t, (void *) t, 2*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultiTexCoord2fARB ***/
static void DLM_APIENTRY passMultiTexCoord2fARB(GLenum texture, GLfloat s, GLfloat t)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultiTexCoord2fARB(texture, s, t);
}
static void DLM_APIENTRY executeMultiTexCoord2fARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultiTexCoord2fARB *instance = (struct instanceMultiTexCoord2fARB *)x;
	dispatchTable->MultiTexCoord2fARB(instance->texture, instance->s, instance->t);
}
void DLM_APIENTRY crdlm_compile_MultiTexCoord2fARB( GLenum texture, GLfloat s, GLfloat t )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultiTexCoord2fARB *instance;
	instance = crCalloc(sizeof(struct instanceMultiTexCoord2fARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultiTexCoord2fARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultiTexCoord2fARB;
	instance->texture = texture;
	instance->s = s;
	instance->t = t;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultiTexCoord2fvARB ***/
static void DLM_APIENTRY passMultiTexCoord2fvARB(GLenum texture, const GLfloat * t)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultiTexCoord2fvARB(texture, t);
}
static void DLM_APIENTRY executeMultiTexCoord2fvARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultiTexCoord2fvARB *instance = (struct instanceMultiTexCoord2fvARB *)x;
	dispatchTable->MultiTexCoord2fvARB(instance->texture, instance->t);
}
void DLM_APIENTRY crdlm_compile_MultiTexCoord2fvARB( GLenum texture, const GLfloat * t )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultiTexCoord2fvARB *instance;
	instance = crCalloc(sizeof(struct instanceMultiTexCoord2fvARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultiTexCoord2fvARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultiTexCoord2fvARB;
	instance->texture = texture;
	if (t == NULL) {
		instance->t = NULL;
	}
	else {
		instance->t = instance->tData;
	}
	crMemcpy((void *)instance->t, (void *) t, 2*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultiTexCoord2iARB ***/
static void DLM_APIENTRY passMultiTexCoord2iARB(GLenum texture, GLint s, GLint t)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultiTexCoord2iARB(texture, s, t);
}
static void DLM_APIENTRY executeMultiTexCoord2iARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultiTexCoord2iARB *instance = (struct instanceMultiTexCoord2iARB *)x;
	dispatchTable->MultiTexCoord2iARB(instance->texture, instance->s, instance->t);
}
void DLM_APIENTRY crdlm_compile_MultiTexCoord2iARB( GLenum texture, GLint s, GLint t )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultiTexCoord2iARB *instance;
	instance = crCalloc(sizeof(struct instanceMultiTexCoord2iARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultiTexCoord2iARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultiTexCoord2iARB;
	instance->texture = texture;
	instance->s = s;
	instance->t = t;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultiTexCoord2ivARB ***/
static void DLM_APIENTRY passMultiTexCoord2ivARB(GLenum texture, const GLint * t)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultiTexCoord2ivARB(texture, t);
}
static void DLM_APIENTRY executeMultiTexCoord2ivARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultiTexCoord2ivARB *instance = (struct instanceMultiTexCoord2ivARB *)x;
	dispatchTable->MultiTexCoord2ivARB(instance->texture, instance->t);
}
void DLM_APIENTRY crdlm_compile_MultiTexCoord2ivARB( GLenum texture, const GLint * t )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultiTexCoord2ivARB *instance;
	instance = crCalloc(sizeof(struct instanceMultiTexCoord2ivARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultiTexCoord2ivARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultiTexCoord2ivARB;
	instance->texture = texture;
	if (t == NULL) {
		instance->t = NULL;
	}
	else {
		instance->t = instance->tData;
	}
	crMemcpy((void *)instance->t, (void *) t, 2*sizeof(GLint));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultiTexCoord2sARB ***/
static void DLM_APIENTRY passMultiTexCoord2sARB(GLenum texture, GLshort s, GLshort t)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultiTexCoord2sARB(texture, s, t);
}
static void DLM_APIENTRY executeMultiTexCoord2sARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultiTexCoord2sARB *instance = (struct instanceMultiTexCoord2sARB *)x;
	dispatchTable->MultiTexCoord2sARB(instance->texture, instance->s, instance->t);
}
void DLM_APIENTRY crdlm_compile_MultiTexCoord2sARB( GLenum texture, GLshort s, GLshort t )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultiTexCoord2sARB *instance;
	instance = crCalloc(sizeof(struct instanceMultiTexCoord2sARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultiTexCoord2sARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultiTexCoord2sARB;
	instance->texture = texture;
	instance->s = s;
	instance->t = t;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultiTexCoord2svARB ***/
static void DLM_APIENTRY passMultiTexCoord2svARB(GLenum texture, const GLshort * t)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultiTexCoord2svARB(texture, t);
}
static void DLM_APIENTRY executeMultiTexCoord2svARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultiTexCoord2svARB *instance = (struct instanceMultiTexCoord2svARB *)x;
	dispatchTable->MultiTexCoord2svARB(instance->texture, instance->t);
}
void DLM_APIENTRY crdlm_compile_MultiTexCoord2svARB( GLenum texture, const GLshort * t )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultiTexCoord2svARB *instance;
	instance = crCalloc(sizeof(struct instanceMultiTexCoord2svARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultiTexCoord2svARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultiTexCoord2svARB;
	instance->texture = texture;
	if (t == NULL) {
		instance->t = NULL;
	}
	else {
		instance->t = instance->tData;
	}
	crMemcpy((void *)instance->t, (void *) t, 2*sizeof(GLshort));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultiTexCoord3dARB ***/
static void DLM_APIENTRY passMultiTexCoord3dARB(GLenum texture, GLdouble s, GLdouble t, GLdouble r)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultiTexCoord3dARB(texture, s, t, r);
}
static void DLM_APIENTRY executeMultiTexCoord3dARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultiTexCoord3dARB *instance = (struct instanceMultiTexCoord3dARB *)x;
	dispatchTable->MultiTexCoord3dARB(instance->texture, instance->s, instance->t, instance->r);
}
void DLM_APIENTRY crdlm_compile_MultiTexCoord3dARB( GLenum texture, GLdouble s, GLdouble t, GLdouble r )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultiTexCoord3dARB *instance;
	instance = crCalloc(sizeof(struct instanceMultiTexCoord3dARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultiTexCoord3dARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultiTexCoord3dARB;
	instance->texture = texture;
	instance->s = s;
	instance->t = t;
	instance->r = r;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultiTexCoord3dvARB ***/
static void DLM_APIENTRY passMultiTexCoord3dvARB(GLenum texture, const GLdouble * t)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultiTexCoord3dvARB(texture, t);
}
static void DLM_APIENTRY executeMultiTexCoord3dvARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultiTexCoord3dvARB *instance = (struct instanceMultiTexCoord3dvARB *)x;
	dispatchTable->MultiTexCoord3dvARB(instance->texture, instance->t);
}
void DLM_APIENTRY crdlm_compile_MultiTexCoord3dvARB( GLenum texture, const GLdouble * t )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultiTexCoord3dvARB *instance;
	instance = crCalloc(sizeof(struct instanceMultiTexCoord3dvARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultiTexCoord3dvARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultiTexCoord3dvARB;
	instance->texture = texture;
	if (t == NULL) {
		instance->t = NULL;
	}
	else {
		instance->t = instance->tData;
	}
	crMemcpy((void *)instance->t, (void *) t, 3*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultiTexCoord3fARB ***/
static void DLM_APIENTRY passMultiTexCoord3fARB(GLenum texture, GLfloat s, GLfloat t, GLfloat r)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultiTexCoord3fARB(texture, s, t, r);
}
static void DLM_APIENTRY executeMultiTexCoord3fARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultiTexCoord3fARB *instance = (struct instanceMultiTexCoord3fARB *)x;
	dispatchTable->MultiTexCoord3fARB(instance->texture, instance->s, instance->t, instance->r);
}
void DLM_APIENTRY crdlm_compile_MultiTexCoord3fARB( GLenum texture, GLfloat s, GLfloat t, GLfloat r )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultiTexCoord3fARB *instance;
	instance = crCalloc(sizeof(struct instanceMultiTexCoord3fARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultiTexCoord3fARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultiTexCoord3fARB;
	instance->texture = texture;
	instance->s = s;
	instance->t = t;
	instance->r = r;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultiTexCoord3fvARB ***/
static void DLM_APIENTRY passMultiTexCoord3fvARB(GLenum texture, const GLfloat * t)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultiTexCoord3fvARB(texture, t);
}
static void DLM_APIENTRY executeMultiTexCoord3fvARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultiTexCoord3fvARB *instance = (struct instanceMultiTexCoord3fvARB *)x;
	dispatchTable->MultiTexCoord3fvARB(instance->texture, instance->t);
}
void DLM_APIENTRY crdlm_compile_MultiTexCoord3fvARB( GLenum texture, const GLfloat * t )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultiTexCoord3fvARB *instance;
	instance = crCalloc(sizeof(struct instanceMultiTexCoord3fvARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultiTexCoord3fvARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultiTexCoord3fvARB;
	instance->texture = texture;
	if (t == NULL) {
		instance->t = NULL;
	}
	else {
		instance->t = instance->tData;
	}
	crMemcpy((void *)instance->t, (void *) t, 3*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultiTexCoord3iARB ***/
static void DLM_APIENTRY passMultiTexCoord3iARB(GLenum texture, GLint s, GLint t, GLint r)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultiTexCoord3iARB(texture, s, t, r);
}
static void DLM_APIENTRY executeMultiTexCoord3iARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultiTexCoord3iARB *instance = (struct instanceMultiTexCoord3iARB *)x;
	dispatchTable->MultiTexCoord3iARB(instance->texture, instance->s, instance->t, instance->r);
}
void DLM_APIENTRY crdlm_compile_MultiTexCoord3iARB( GLenum texture, GLint s, GLint t, GLint r )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultiTexCoord3iARB *instance;
	instance = crCalloc(sizeof(struct instanceMultiTexCoord3iARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultiTexCoord3iARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultiTexCoord3iARB;
	instance->texture = texture;
	instance->s = s;
	instance->t = t;
	instance->r = r;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultiTexCoord3ivARB ***/
static void DLM_APIENTRY passMultiTexCoord3ivARB(GLenum texture, const GLint * t)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultiTexCoord3ivARB(texture, t);
}
static void DLM_APIENTRY executeMultiTexCoord3ivARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultiTexCoord3ivARB *instance = (struct instanceMultiTexCoord3ivARB *)x;
	dispatchTable->MultiTexCoord3ivARB(instance->texture, instance->t);
}
void DLM_APIENTRY crdlm_compile_MultiTexCoord3ivARB( GLenum texture, const GLint * t )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultiTexCoord3ivARB *instance;
	instance = crCalloc(sizeof(struct instanceMultiTexCoord3ivARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultiTexCoord3ivARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultiTexCoord3ivARB;
	instance->texture = texture;
	if (t == NULL) {
		instance->t = NULL;
	}
	else {
		instance->t = instance->tData;
	}
	crMemcpy((void *)instance->t, (void *) t, 3*sizeof(GLint));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultiTexCoord3sARB ***/
static void DLM_APIENTRY passMultiTexCoord3sARB(GLenum texture, GLshort s, GLshort t, GLshort r)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultiTexCoord3sARB(texture, s, t, r);
}
static void DLM_APIENTRY executeMultiTexCoord3sARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultiTexCoord3sARB *instance = (struct instanceMultiTexCoord3sARB *)x;
	dispatchTable->MultiTexCoord3sARB(instance->texture, instance->s, instance->t, instance->r);
}
void DLM_APIENTRY crdlm_compile_MultiTexCoord3sARB( GLenum texture, GLshort s, GLshort t, GLshort r )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultiTexCoord3sARB *instance;
	instance = crCalloc(sizeof(struct instanceMultiTexCoord3sARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultiTexCoord3sARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultiTexCoord3sARB;
	instance->texture = texture;
	instance->s = s;
	instance->t = t;
	instance->r = r;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultiTexCoord3svARB ***/
static void DLM_APIENTRY passMultiTexCoord3svARB(GLenum texture, const GLshort * t)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultiTexCoord3svARB(texture, t);
}
static void DLM_APIENTRY executeMultiTexCoord3svARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultiTexCoord3svARB *instance = (struct instanceMultiTexCoord3svARB *)x;
	dispatchTable->MultiTexCoord3svARB(instance->texture, instance->t);
}
void DLM_APIENTRY crdlm_compile_MultiTexCoord3svARB( GLenum texture, const GLshort * t )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultiTexCoord3svARB *instance;
	instance = crCalloc(sizeof(struct instanceMultiTexCoord3svARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultiTexCoord3svARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultiTexCoord3svARB;
	instance->texture = texture;
	if (t == NULL) {
		instance->t = NULL;
	}
	else {
		instance->t = instance->tData;
	}
	crMemcpy((void *)instance->t, (void *) t, 3*sizeof(GLshort));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultiTexCoord4dARB ***/
static void DLM_APIENTRY passMultiTexCoord4dARB(GLenum texture, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultiTexCoord4dARB(texture, s, t, r, q);
}
static void DLM_APIENTRY executeMultiTexCoord4dARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultiTexCoord4dARB *instance = (struct instanceMultiTexCoord4dARB *)x;
	dispatchTable->MultiTexCoord4dARB(instance->texture, instance->s, instance->t, instance->r, instance->q);
}
void DLM_APIENTRY crdlm_compile_MultiTexCoord4dARB( GLenum texture, GLdouble s, GLdouble t, GLdouble r, GLdouble q )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultiTexCoord4dARB *instance;
	instance = crCalloc(sizeof(struct instanceMultiTexCoord4dARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultiTexCoord4dARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultiTexCoord4dARB;
	instance->texture = texture;
	instance->s = s;
	instance->t = t;
	instance->r = r;
	instance->q = q;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultiTexCoord4dvARB ***/
static void DLM_APIENTRY passMultiTexCoord4dvARB(GLenum texture, const GLdouble * t)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultiTexCoord4dvARB(texture, t);
}
static void DLM_APIENTRY executeMultiTexCoord4dvARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultiTexCoord4dvARB *instance = (struct instanceMultiTexCoord4dvARB *)x;
	dispatchTable->MultiTexCoord4dvARB(instance->texture, instance->t);
}
void DLM_APIENTRY crdlm_compile_MultiTexCoord4dvARB( GLenum texture, const GLdouble * t )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultiTexCoord4dvARB *instance;
	instance = crCalloc(sizeof(struct instanceMultiTexCoord4dvARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultiTexCoord4dvARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultiTexCoord4dvARB;
	instance->texture = texture;
	if (t == NULL) {
		instance->t = NULL;
	}
	else {
		instance->t = instance->tData;
	}
	crMemcpy((void *)instance->t, (void *) t, 4*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultiTexCoord4fARB ***/
static void DLM_APIENTRY passMultiTexCoord4fARB(GLenum texture, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultiTexCoord4fARB(texture, s, t, r, q);
}
static void DLM_APIENTRY executeMultiTexCoord4fARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultiTexCoord4fARB *instance = (struct instanceMultiTexCoord4fARB *)x;
	dispatchTable->MultiTexCoord4fARB(instance->texture, instance->s, instance->t, instance->r, instance->q);
}
void DLM_APIENTRY crdlm_compile_MultiTexCoord4fARB( GLenum texture, GLfloat s, GLfloat t, GLfloat r, GLfloat q )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultiTexCoord4fARB *instance;
	instance = crCalloc(sizeof(struct instanceMultiTexCoord4fARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultiTexCoord4fARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultiTexCoord4fARB;
	instance->texture = texture;
	instance->s = s;
	instance->t = t;
	instance->r = r;
	instance->q = q;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultiTexCoord4fvARB ***/
static void DLM_APIENTRY passMultiTexCoord4fvARB(GLenum texture, const GLfloat * t)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultiTexCoord4fvARB(texture, t);
}
static void DLM_APIENTRY executeMultiTexCoord4fvARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultiTexCoord4fvARB *instance = (struct instanceMultiTexCoord4fvARB *)x;
	dispatchTable->MultiTexCoord4fvARB(instance->texture, instance->t);
}
void DLM_APIENTRY crdlm_compile_MultiTexCoord4fvARB( GLenum texture, const GLfloat * t )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultiTexCoord4fvARB *instance;
	instance = crCalloc(sizeof(struct instanceMultiTexCoord4fvARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultiTexCoord4fvARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultiTexCoord4fvARB;
	instance->texture = texture;
	if (t == NULL) {
		instance->t = NULL;
	}
	else {
		instance->t = instance->tData;
	}
	crMemcpy((void *)instance->t, (void *) t, 4*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultiTexCoord4iARB ***/
static void DLM_APIENTRY passMultiTexCoord4iARB(GLenum texture, GLint s, GLint t, GLint r, GLint q)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultiTexCoord4iARB(texture, s, t, r, q);
}
static void DLM_APIENTRY executeMultiTexCoord4iARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultiTexCoord4iARB *instance = (struct instanceMultiTexCoord4iARB *)x;
	dispatchTable->MultiTexCoord4iARB(instance->texture, instance->s, instance->t, instance->r, instance->q);
}
void DLM_APIENTRY crdlm_compile_MultiTexCoord4iARB( GLenum texture, GLint s, GLint t, GLint r, GLint q )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultiTexCoord4iARB *instance;
	instance = crCalloc(sizeof(struct instanceMultiTexCoord4iARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultiTexCoord4iARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultiTexCoord4iARB;
	instance->texture = texture;
	instance->s = s;
	instance->t = t;
	instance->r = r;
	instance->q = q;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultiTexCoord4ivARB ***/
static void DLM_APIENTRY passMultiTexCoord4ivARB(GLenum texture, const GLint * t)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultiTexCoord4ivARB(texture, t);
}
static void DLM_APIENTRY executeMultiTexCoord4ivARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultiTexCoord4ivARB *instance = (struct instanceMultiTexCoord4ivARB *)x;
	dispatchTable->MultiTexCoord4ivARB(instance->texture, instance->t);
}
void DLM_APIENTRY crdlm_compile_MultiTexCoord4ivARB( GLenum texture, const GLint * t )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultiTexCoord4ivARB *instance;
	instance = crCalloc(sizeof(struct instanceMultiTexCoord4ivARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultiTexCoord4ivARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultiTexCoord4ivARB;
	instance->texture = texture;
	if (t == NULL) {
		instance->t = NULL;
	}
	else {
		instance->t = instance->tData;
	}
	crMemcpy((void *)instance->t, (void *) t, 4*sizeof(GLint));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultiTexCoord4sARB ***/
static void DLM_APIENTRY passMultiTexCoord4sARB(GLenum texture, GLshort s, GLshort t, GLshort r, GLshort q)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultiTexCoord4sARB(texture, s, t, r, q);
}
static void DLM_APIENTRY executeMultiTexCoord4sARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultiTexCoord4sARB *instance = (struct instanceMultiTexCoord4sARB *)x;
	dispatchTable->MultiTexCoord4sARB(instance->texture, instance->s, instance->t, instance->r, instance->q);
}
void DLM_APIENTRY crdlm_compile_MultiTexCoord4sARB( GLenum texture, GLshort s, GLshort t, GLshort r, GLshort q )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultiTexCoord4sARB *instance;
	instance = crCalloc(sizeof(struct instanceMultiTexCoord4sARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultiTexCoord4sARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultiTexCoord4sARB;
	instance->texture = texture;
	instance->s = s;
	instance->t = t;
	instance->r = r;
	instance->q = q;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** MultiTexCoord4svARB ***/
static void DLM_APIENTRY passMultiTexCoord4svARB(GLenum texture, const GLshort * t)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.MultiTexCoord4svARB(texture, t);
}
static void DLM_APIENTRY executeMultiTexCoord4svARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceMultiTexCoord4svARB *instance = (struct instanceMultiTexCoord4svARB *)x;
	dispatchTable->MultiTexCoord4svARB(instance->texture, instance->t);
}
void DLM_APIENTRY crdlm_compile_MultiTexCoord4svARB( GLenum texture, const GLshort * t )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceMultiTexCoord4svARB *instance;
	instance = crCalloc(sizeof(struct instanceMultiTexCoord4svARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding MultiTexCoord4svARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeMultiTexCoord4svARB;
	instance->texture = texture;
	if (t == NULL) {
		instance->t = NULL;
	}
	else {
		instance->t = instance->tData;
	}
	crMemcpy((void *)instance->t, (void *) t, 4*sizeof(GLshort));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** NewList ***/
static void DLM_APIENTRY passNewList(GLuint list, GLenum mode)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.NewList(list, mode);
}

/*** Normal3b ***/
static void DLM_APIENTRY passNormal3b(GLbyte nx, GLbyte ny, GLbyte nz)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Normal3b(nx, ny, nz);
}
static void DLM_APIENTRY executeNormal3b(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceNormal3b *instance = (struct instanceNormal3b *)x;
	dispatchTable->Normal3b(instance->nx, instance->ny, instance->nz);
}
void DLM_APIENTRY crdlm_compile_Normal3b( GLbyte nx, GLbyte ny, GLbyte nz )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceNormal3b *instance;
	instance = crCalloc(sizeof(struct instanceNormal3b));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Normal3b to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeNormal3b;
	instance->nx = nx;
	instance->ny = ny;
	instance->nz = nz;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Normal3bv ***/
static void DLM_APIENTRY passNormal3bv(const GLbyte * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Normal3bv(v);
}
static void DLM_APIENTRY executeNormal3bv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceNormal3bv *instance = (struct instanceNormal3bv *)x;
	dispatchTable->Normal3bv(instance->v);
}
void DLM_APIENTRY crdlm_compile_Normal3bv( const GLbyte * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceNormal3bv *instance;
	instance = crCalloc(sizeof(struct instanceNormal3bv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Normal3bv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeNormal3bv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLbyte));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Normal3d ***/
static void DLM_APIENTRY passNormal3d(GLdouble nx, GLdouble ny, GLdouble nz)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Normal3d(nx, ny, nz);
}
static void DLM_APIENTRY executeNormal3d(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceNormal3d *instance = (struct instanceNormal3d *)x;
	dispatchTable->Normal3d(instance->nx, instance->ny, instance->nz);
}
void DLM_APIENTRY crdlm_compile_Normal3d( GLdouble nx, GLdouble ny, GLdouble nz )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceNormal3d *instance;
	instance = crCalloc(sizeof(struct instanceNormal3d));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Normal3d to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeNormal3d;
	instance->nx = nx;
	instance->ny = ny;
	instance->nz = nz;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Normal3dv ***/
static void DLM_APIENTRY passNormal3dv(const GLdouble * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Normal3dv(v);
}
static void DLM_APIENTRY executeNormal3dv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceNormal3dv *instance = (struct instanceNormal3dv *)x;
	dispatchTable->Normal3dv(instance->v);
}
void DLM_APIENTRY crdlm_compile_Normal3dv( const GLdouble * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceNormal3dv *instance;
	instance = crCalloc(sizeof(struct instanceNormal3dv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Normal3dv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeNormal3dv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Normal3f ***/
static void DLM_APIENTRY passNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Normal3f(nx, ny, nz);
}
static void DLM_APIENTRY executeNormal3f(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceNormal3f *instance = (struct instanceNormal3f *)x;
	dispatchTable->Normal3f(instance->nx, instance->ny, instance->nz);
}
void DLM_APIENTRY crdlm_compile_Normal3f( GLfloat nx, GLfloat ny, GLfloat nz )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceNormal3f *instance;
	instance = crCalloc(sizeof(struct instanceNormal3f));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Normal3f to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeNormal3f;
	instance->nx = nx;
	instance->ny = ny;
	instance->nz = nz;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Normal3fv ***/
static void DLM_APIENTRY passNormal3fv(const GLfloat * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Normal3fv(v);
}
static void DLM_APIENTRY executeNormal3fv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceNormal3fv *instance = (struct instanceNormal3fv *)x;
	dispatchTable->Normal3fv(instance->v);
}
void DLM_APIENTRY crdlm_compile_Normal3fv( const GLfloat * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceNormal3fv *instance;
	instance = crCalloc(sizeof(struct instanceNormal3fv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Normal3fv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeNormal3fv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Normal3i ***/
static void DLM_APIENTRY passNormal3i(GLint nx, GLint ny, GLint nz)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Normal3i(nx, ny, nz);
}
static void DLM_APIENTRY executeNormal3i(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceNormal3i *instance = (struct instanceNormal3i *)x;
	dispatchTable->Normal3i(instance->nx, instance->ny, instance->nz);
}
void DLM_APIENTRY crdlm_compile_Normal3i( GLint nx, GLint ny, GLint nz )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceNormal3i *instance;
	instance = crCalloc(sizeof(struct instanceNormal3i));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Normal3i to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeNormal3i;
	instance->nx = nx;
	instance->ny = ny;
	instance->nz = nz;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Normal3iv ***/
static void DLM_APIENTRY passNormal3iv(const GLint * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Normal3iv(v);
}
static void DLM_APIENTRY executeNormal3iv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceNormal3iv *instance = (struct instanceNormal3iv *)x;
	dispatchTable->Normal3iv(instance->v);
}
void DLM_APIENTRY crdlm_compile_Normal3iv( const GLint * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceNormal3iv *instance;
	instance = crCalloc(sizeof(struct instanceNormal3iv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Normal3iv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeNormal3iv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLint));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Normal3s ***/
static void DLM_APIENTRY passNormal3s(GLshort nx, GLshort ny, GLshort nz)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Normal3s(nx, ny, nz);
}
static void DLM_APIENTRY executeNormal3s(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceNormal3s *instance = (struct instanceNormal3s *)x;
	dispatchTable->Normal3s(instance->nx, instance->ny, instance->nz);
}
void DLM_APIENTRY crdlm_compile_Normal3s( GLshort nx, GLshort ny, GLshort nz )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceNormal3s *instance;
	instance = crCalloc(sizeof(struct instanceNormal3s));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Normal3s to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeNormal3s;
	instance->nx = nx;
	instance->ny = ny;
	instance->nz = nz;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Normal3sv ***/
static void DLM_APIENTRY passNormal3sv(const GLshort * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Normal3sv(v);
}
static void DLM_APIENTRY executeNormal3sv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceNormal3sv *instance = (struct instanceNormal3sv *)x;
	dispatchTable->Normal3sv(instance->v);
}
void DLM_APIENTRY crdlm_compile_Normal3sv( const GLshort * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceNormal3sv *instance;
	instance = crCalloc(sizeof(struct instanceNormal3sv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Normal3sv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeNormal3sv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLshort));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** NormalPointer ***/
static void DLM_APIENTRY passNormalPointer(GLenum type, GLsizei stride, const GLvoid * pointer)
{
	CRDLMContextState *state = CURRENT_STATE();
	crdlmNormalPointer(type, stride, pointer, state->clientState);
	state->savedDispatchTable.NormalPointer(type, stride, pointer);
}

/*** Ortho ***/
static void DLM_APIENTRY passOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Ortho(left, right, bottom, top, zNear, zFar);
}
static void DLM_APIENTRY executeOrtho(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceOrtho *instance = (struct instanceOrtho *)x;
	dispatchTable->Ortho(instance->left, instance->right, instance->bottom, instance->top, instance->zNear, instance->zFar);
}
void DLM_APIENTRY crdlm_compile_Ortho( GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceOrtho *instance;
	instance = crCalloc(sizeof(struct instanceOrtho));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Ortho to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeOrtho;
	instance->left = left;
	instance->right = right;
	instance->bottom = bottom;
	instance->top = top;
	instance->zNear = zNear;
	instance->zFar = zFar;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** PassThrough ***/
static void DLM_APIENTRY passPassThrough(GLfloat token)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.PassThrough(token);
}
static void DLM_APIENTRY executePassThrough(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instancePassThrough *instance = (struct instancePassThrough *)x;
	dispatchTable->PassThrough(instance->token);
}
void DLM_APIENTRY crdlm_compile_PassThrough( GLfloat token )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instancePassThrough *instance;
	instance = crCalloc(sizeof(struct instancePassThrough));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding PassThrough to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executePassThrough;
	instance->token = token;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** PixelMapfv ***/
static void DLM_APIENTRY passPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat * values)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.PixelMapfv(map, mapsize, values);
}
static void DLM_APIENTRY executePixelMapfv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instancePixelMapfv *instance = (struct instancePixelMapfv *)x;
	dispatchTable->PixelMapfv(instance->map, instance->mapsize, instance->values);
}
void DLM_APIENTRY crdlm_compile_PixelMapfv( GLenum map, GLsizei mapsize, const GLfloat * values )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instancePixelMapfv *instance;
	instance = crCalloc(sizeof(struct instancePixelMapfv) + crdlm_pointers_PixelMapfv(NULL, map, mapsize, values));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding PixelMapfv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executePixelMapfv;
	instance->map = map;
	instance->mapsize = mapsize;
	if (values == NULL) {
		instance->values = NULL;
	}
	else {
		instance->values = instance->valuesData;
	}
	(void) crdlm_pointers_PixelMapfv(instance, map, mapsize, values);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** PixelMapuiv ***/
static void DLM_APIENTRY passPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint * values)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.PixelMapuiv(map, mapsize, values);
}
static void DLM_APIENTRY executePixelMapuiv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instancePixelMapuiv *instance = (struct instancePixelMapuiv *)x;
	dispatchTable->PixelMapuiv(instance->map, instance->mapsize, instance->values);
}
void DLM_APIENTRY crdlm_compile_PixelMapuiv( GLenum map, GLsizei mapsize, const GLuint * values )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instancePixelMapuiv *instance;
	instance = crCalloc(sizeof(struct instancePixelMapuiv) + crdlm_pointers_PixelMapuiv(NULL, map, mapsize, values));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding PixelMapuiv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executePixelMapuiv;
	instance->map = map;
	instance->mapsize = mapsize;
	if (values == NULL) {
		instance->values = NULL;
	}
	else {
		instance->values = instance->valuesData;
	}
	(void) crdlm_pointers_PixelMapuiv(instance, map, mapsize, values);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** PixelMapusv ***/
static void DLM_APIENTRY passPixelMapusv(GLenum map, GLsizei mapsize, const GLushort * values)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.PixelMapusv(map, mapsize, values);
}
static void DLM_APIENTRY executePixelMapusv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instancePixelMapusv *instance = (struct instancePixelMapusv *)x;
	dispatchTable->PixelMapusv(instance->map, instance->mapsize, instance->values);
}
void DLM_APIENTRY crdlm_compile_PixelMapusv( GLenum map, GLsizei mapsize, const GLushort * values )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instancePixelMapusv *instance;
	instance = crCalloc(sizeof(struct instancePixelMapusv) + crdlm_pointers_PixelMapusv(NULL, map, mapsize, values));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding PixelMapusv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executePixelMapusv;
	instance->map = map;
	instance->mapsize = mapsize;
	if (values == NULL) {
		instance->values = NULL;
	}
	else {
		instance->values = instance->valuesData;
	}
	(void) crdlm_pointers_PixelMapusv(instance, map, mapsize, values);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** PixelStoref ***/
static void DLM_APIENTRY passPixelStoref(GLenum pname, GLfloat param)
{
	CRDLMContextState *state = CURRENT_STATE();
	crdlmPixelStoref(pname, param, state->clientState);
	state->savedDispatchTable.PixelStoref(pname, param);
}

/*** PixelStorei ***/
static void DLM_APIENTRY passPixelStorei(GLenum pname, GLint param)
{
	CRDLMContextState *state = CURRENT_STATE();
	crdlmPixelStorei(pname, param, state->clientState);
	state->savedDispatchTable.PixelStorei(pname, param);
}

/*** PixelTransferf ***/
static void DLM_APIENTRY passPixelTransferf(GLenum pname, GLfloat param)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.PixelTransferf(pname, param);
}
static void DLM_APIENTRY executePixelTransferf(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instancePixelTransferf *instance = (struct instancePixelTransferf *)x;
	dispatchTable->PixelTransferf(instance->pname, instance->param);
}
void DLM_APIENTRY crdlm_compile_PixelTransferf( GLenum pname, GLfloat param )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instancePixelTransferf *instance;
	instance = crCalloc(sizeof(struct instancePixelTransferf));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding PixelTransferf to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executePixelTransferf;
	instance->pname = pname;
	instance->param = param;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** PixelTransferi ***/
static void DLM_APIENTRY passPixelTransferi(GLenum pname, GLint param)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.PixelTransferi(pname, param);
}
static void DLM_APIENTRY executePixelTransferi(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instancePixelTransferi *instance = (struct instancePixelTransferi *)x;
	dispatchTable->PixelTransferi(instance->pname, instance->param);
}
void DLM_APIENTRY crdlm_compile_PixelTransferi( GLenum pname, GLint param )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instancePixelTransferi *instance;
	instance = crCalloc(sizeof(struct instancePixelTransferi));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding PixelTransferi to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executePixelTransferi;
	instance->pname = pname;
	instance->param = param;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** PixelZoom ***/
static void DLM_APIENTRY passPixelZoom(GLfloat xfactor, GLfloat yfactor)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.PixelZoom(xfactor, yfactor);
}
static void DLM_APIENTRY executePixelZoom(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instancePixelZoom *instance = (struct instancePixelZoom *)x;
	dispatchTable->PixelZoom(instance->xfactor, instance->yfactor);
}
void DLM_APIENTRY crdlm_compile_PixelZoom( GLfloat xfactor, GLfloat yfactor )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instancePixelZoom *instance;
	instance = crCalloc(sizeof(struct instancePixelZoom));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding PixelZoom to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executePixelZoom;
	instance->xfactor = xfactor;
	instance->yfactor = yfactor;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** PointParameterfARB ***/
static void DLM_APIENTRY passPointParameterfARB(GLenum pname, GLfloat param)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.PointParameterfARB(pname, param);
}
static void DLM_APIENTRY executePointParameterfARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instancePointParameterfARB *instance = (struct instancePointParameterfARB *)x;
	dispatchTable->PointParameterfARB(instance->pname, instance->param);
}
void DLM_APIENTRY crdlm_compile_PointParameterfARB( GLenum pname, GLfloat param )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instancePointParameterfARB *instance;
	instance = crCalloc(sizeof(struct instancePointParameterfARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding PointParameterfARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executePointParameterfARB;
	instance->pname = pname;
	instance->param = param;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** PointParameterfvARB ***/
static void DLM_APIENTRY passPointParameterfvARB(GLenum pname, const GLfloat * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.PointParameterfvARB(pname, params);
}
static void DLM_APIENTRY executePointParameterfvARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instancePointParameterfvARB *instance = (struct instancePointParameterfvARB *)x;
	dispatchTable->PointParameterfvARB(instance->pname, instance->params);
}
void DLM_APIENTRY crdlm_compile_PointParameterfvARB( GLenum pname, const GLfloat * params )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instancePointParameterfvARB *instance;
	instance = crCalloc(sizeof(struct instancePointParameterfvARB) + crdlm_pointers_PointParameterfvARB(NULL, pname, params));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding PointParameterfvARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executePointParameterfvARB;
	instance->pname = pname;
	if (params == NULL) {
		instance->params = NULL;
	}
	else {
		instance->params = instance->paramsData;
	}
	(void) crdlm_pointers_PointParameterfvARB(instance, pname, params);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** PointParameteri ***/
static void DLM_APIENTRY passPointParameteri(GLenum pname, GLint param)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.PointParameteri(pname, param);
}
static void DLM_APIENTRY executePointParameteri(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instancePointParameteri *instance = (struct instancePointParameteri *)x;
	dispatchTable->PointParameteri(instance->pname, instance->param);
}
void DLM_APIENTRY crdlm_compile_PointParameteri( GLenum pname, GLint param )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instancePointParameteri *instance;
	instance = crCalloc(sizeof(struct instancePointParameteri));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding PointParameteri to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executePointParameteri;
	instance->pname = pname;
	instance->param = param;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** PointParameteriv ***/
static void DLM_APIENTRY passPointParameteriv(GLenum pname, const GLint * param)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.PointParameteriv(pname, param);
}
static void DLM_APIENTRY executePointParameteriv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instancePointParameteriv *instance = (struct instancePointParameteriv *)x;
	dispatchTable->PointParameteriv(instance->pname, instance->param);
}
void DLM_APIENTRY crdlm_compile_PointParameteriv( GLenum pname, const GLint * param )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instancePointParameteriv *instance;
	instance = crCalloc(sizeof(struct instancePointParameteriv) + crdlm_pointers_PointParameteriv(NULL, pname, param));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding PointParameteriv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executePointParameteriv;
	instance->pname = pname;
	if (param == NULL) {
		instance->param = NULL;
	}
	else {
		instance->param = instance->paramData;
	}
	(void) crdlm_pointers_PointParameteriv(instance, pname, param);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** PointSize ***/
static void DLM_APIENTRY passPointSize(GLfloat size)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.PointSize(size);
}
static void DLM_APIENTRY executePointSize(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instancePointSize *instance = (struct instancePointSize *)x;
	dispatchTable->PointSize(instance->size);
}
void DLM_APIENTRY crdlm_compile_PointSize( GLfloat size )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instancePointSize *instance;
	instance = crCalloc(sizeof(struct instancePointSize));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding PointSize to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executePointSize;
	instance->size = size;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** PolygonMode ***/
static void DLM_APIENTRY passPolygonMode(GLenum face, GLenum mode)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.PolygonMode(face, mode);
}
static void DLM_APIENTRY executePolygonMode(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instancePolygonMode *instance = (struct instancePolygonMode *)x;
	dispatchTable->PolygonMode(instance->face, instance->mode);
}
void DLM_APIENTRY crdlm_compile_PolygonMode( GLenum face, GLenum mode )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instancePolygonMode *instance;
	instance = crCalloc(sizeof(struct instancePolygonMode));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding PolygonMode to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executePolygonMode;
	instance->face = face;
	instance->mode = mode;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** PolygonOffset ***/
static void DLM_APIENTRY passPolygonOffset(GLfloat factor, GLfloat units)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.PolygonOffset(factor, units);
}
static void DLM_APIENTRY executePolygonOffset(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instancePolygonOffset *instance = (struct instancePolygonOffset *)x;
	dispatchTable->PolygonOffset(instance->factor, instance->units);
}
void DLM_APIENTRY crdlm_compile_PolygonOffset( GLfloat factor, GLfloat units )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instancePolygonOffset *instance;
	instance = crCalloc(sizeof(struct instancePolygonOffset));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding PolygonOffset to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executePolygonOffset;
	instance->factor = factor;
	instance->units = units;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** PolygonStipple ***/
static void DLM_APIENTRY passPolygonStipple(const GLubyte * mask)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.PolygonStipple(mask);
}
static void DLM_APIENTRY executePolygonStipple(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instancePolygonStipple *instance = (struct instancePolygonStipple *)x;
	dispatchTable->PolygonStipple(instance->mask);
}
void DLM_APIENTRY crdlm_compile_PolygonStipple( const GLubyte * mask )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instancePolygonStipple *instance;
	instance = crCalloc(sizeof(struct instancePolygonStipple));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding PolygonStipple to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executePolygonStipple;
	if (mask == NULL) {
		instance->mask = NULL;
	}
	else {
		instance->mask = instance->maskData;
	}
	crMemcpy((void *)instance->mask, (void *) mask, 128*sizeof(GLubyte));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** PopAttrib ***/
static void DLM_APIENTRY passPopAttrib(void)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.PopAttrib();
}
static void DLM_APIENTRY executePopAttrib(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	dispatchTable->PopAttrib();
}
void DLM_APIENTRY crdlm_compile_PopAttrib( void )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instancePopAttrib *instance;
	instance = crCalloc(sizeof(struct instancePopAttrib));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding PopAttrib to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executePopAttrib;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** PopClientAttrib ***/
static void DLM_APIENTRY passPopClientAttrib(void)
{
	CRDLMContextState *state = CURRENT_STATE();
	crdlmPopClientAttrib(state->clientState);
	state->savedDispatchTable.PopClientAttrib();
}

/*** PopMatrix ***/
static void DLM_APIENTRY passPopMatrix(void)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.PopMatrix();
}
static void DLM_APIENTRY executePopMatrix(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	dispatchTable->PopMatrix();
}
void DLM_APIENTRY crdlm_compile_PopMatrix( void )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instancePopMatrix *instance;
	instance = crCalloc(sizeof(struct instancePopMatrix));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding PopMatrix to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executePopMatrix;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** PopName ***/
static void DLM_APIENTRY passPopName(void)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.PopName();
}
static void DLM_APIENTRY executePopName(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	dispatchTable->PopName();
}
void DLM_APIENTRY crdlm_compile_PopName( void )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instancePopName *instance;
	instance = crCalloc(sizeof(struct instancePopName));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding PopName to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executePopName;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** PrioritizeTextures ***/
static void DLM_APIENTRY passPrioritizeTextures(GLsizei n, const GLuint * textures, const GLclampf * priorities)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.PrioritizeTextures(n, textures, priorities);
}
static void DLM_APIENTRY executePrioritizeTextures(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instancePrioritizeTextures *instance = (struct instancePrioritizeTextures *)x;
	dispatchTable->PrioritizeTextures(instance->n, instance->textures, instance->priorities);
}
void DLM_APIENTRY crdlm_compile_PrioritizeTextures( GLsizei n, const GLuint * textures, const GLclampf * priorities )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instancePrioritizeTextures *instance;
	instance = crCalloc(sizeof(struct instancePrioritizeTextures) + crdlm_pointers_PrioritizeTextures(NULL, n, textures, priorities));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding PrioritizeTextures to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executePrioritizeTextures;
	instance->n = n;
	(void) crdlm_pointers_PrioritizeTextures(instance, n, textures, priorities);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** ProgramEnvParameter4dARB ***/
static void DLM_APIENTRY passProgramEnvParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ProgramEnvParameter4dARB(target, index, x, y, z, w);
}
static void DLM_APIENTRY executeProgramEnvParameter4dARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceProgramEnvParameter4dARB *instance = (struct instanceProgramEnvParameter4dARB *)x;
	dispatchTable->ProgramEnvParameter4dARB(instance->target, instance->index, instance->x, instance->y, instance->z, instance->w);
}
void DLM_APIENTRY crdlm_compile_ProgramEnvParameter4dARB( GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceProgramEnvParameter4dARB *instance;
	instance = crCalloc(sizeof(struct instanceProgramEnvParameter4dARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding ProgramEnvParameter4dARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeProgramEnvParameter4dARB;
	instance->target = target;
	instance->index = index;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	instance->w = w;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** ProgramEnvParameter4dvARB ***/
static void DLM_APIENTRY passProgramEnvParameter4dvARB(GLenum target, GLuint index, const GLdouble * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ProgramEnvParameter4dvARB(target, index, params);
}
static void DLM_APIENTRY executeProgramEnvParameter4dvARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceProgramEnvParameter4dvARB *instance = (struct instanceProgramEnvParameter4dvARB *)x;
	dispatchTable->ProgramEnvParameter4dvARB(instance->target, instance->index, instance->params);
}
void DLM_APIENTRY crdlm_compile_ProgramEnvParameter4dvARB( GLenum target, GLuint index, const GLdouble * params )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceProgramEnvParameter4dvARB *instance;
	instance = crCalloc(sizeof(struct instanceProgramEnvParameter4dvARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding ProgramEnvParameter4dvARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeProgramEnvParameter4dvARB;
	instance->target = target;
	instance->index = index;
	if (params == NULL) {
		instance->params = NULL;
	}
	else {
		instance->params = instance->paramsData;
	}
	crMemcpy((void *)instance->params, (void *) params, 4*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** ProgramEnvParameter4fARB ***/
static void DLM_APIENTRY passProgramEnvParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ProgramEnvParameter4fARB(target, index, x, y, z, w);
}
static void DLM_APIENTRY executeProgramEnvParameter4fARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceProgramEnvParameter4fARB *instance = (struct instanceProgramEnvParameter4fARB *)x;
	dispatchTable->ProgramEnvParameter4fARB(instance->target, instance->index, instance->x, instance->y, instance->z, instance->w);
}
void DLM_APIENTRY crdlm_compile_ProgramEnvParameter4fARB( GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceProgramEnvParameter4fARB *instance;
	instance = crCalloc(sizeof(struct instanceProgramEnvParameter4fARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding ProgramEnvParameter4fARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeProgramEnvParameter4fARB;
	instance->target = target;
	instance->index = index;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	instance->w = w;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** ProgramEnvParameter4fvARB ***/
static void DLM_APIENTRY passProgramEnvParameter4fvARB(GLenum target, GLuint index, const GLfloat * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ProgramEnvParameter4fvARB(target, index, params);
}
static void DLM_APIENTRY executeProgramEnvParameter4fvARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceProgramEnvParameter4fvARB *instance = (struct instanceProgramEnvParameter4fvARB *)x;
	dispatchTable->ProgramEnvParameter4fvARB(instance->target, instance->index, instance->params);
}
void DLM_APIENTRY crdlm_compile_ProgramEnvParameter4fvARB( GLenum target, GLuint index, const GLfloat * params )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceProgramEnvParameter4fvARB *instance;
	instance = crCalloc(sizeof(struct instanceProgramEnvParameter4fvARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding ProgramEnvParameter4fvARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeProgramEnvParameter4fvARB;
	instance->target = target;
	instance->index = index;
	if (params == NULL) {
		instance->params = NULL;
	}
	else {
		instance->params = instance->paramsData;
	}
	crMemcpy((void *)instance->params, (void *) params, 4*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** ProgramLocalParameter4dARB ***/
static void DLM_APIENTRY passProgramLocalParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ProgramLocalParameter4dARB(target, index, x, y, z, w);
}
static void DLM_APIENTRY executeProgramLocalParameter4dARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceProgramLocalParameter4dARB *instance = (struct instanceProgramLocalParameter4dARB *)x;
	dispatchTable->ProgramLocalParameter4dARB(instance->target, instance->index, instance->x, instance->y, instance->z, instance->w);
}
void DLM_APIENTRY crdlm_compile_ProgramLocalParameter4dARB( GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceProgramLocalParameter4dARB *instance;
	instance = crCalloc(sizeof(struct instanceProgramLocalParameter4dARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding ProgramLocalParameter4dARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeProgramLocalParameter4dARB;
	instance->target = target;
	instance->index = index;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	instance->w = w;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** ProgramLocalParameter4dvARB ***/
static void DLM_APIENTRY passProgramLocalParameter4dvARB(GLenum target, GLuint index, const GLdouble * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ProgramLocalParameter4dvARB(target, index, params);
}
static void DLM_APIENTRY executeProgramLocalParameter4dvARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceProgramLocalParameter4dvARB *instance = (struct instanceProgramLocalParameter4dvARB *)x;
	dispatchTable->ProgramLocalParameter4dvARB(instance->target, instance->index, instance->params);
}
void DLM_APIENTRY crdlm_compile_ProgramLocalParameter4dvARB( GLenum target, GLuint index, const GLdouble * params )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceProgramLocalParameter4dvARB *instance;
	instance = crCalloc(sizeof(struct instanceProgramLocalParameter4dvARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding ProgramLocalParameter4dvARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeProgramLocalParameter4dvARB;
	instance->target = target;
	instance->index = index;
	if (params == NULL) {
		instance->params = NULL;
	}
	else {
		instance->params = instance->paramsData;
	}
	crMemcpy((void *)instance->params, (void *) params, 4*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** ProgramLocalParameter4fARB ***/
static void DLM_APIENTRY passProgramLocalParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ProgramLocalParameter4fARB(target, index, x, y, z, w);
}
static void DLM_APIENTRY executeProgramLocalParameter4fARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceProgramLocalParameter4fARB *instance = (struct instanceProgramLocalParameter4fARB *)x;
	dispatchTable->ProgramLocalParameter4fARB(instance->target, instance->index, instance->x, instance->y, instance->z, instance->w);
}
void DLM_APIENTRY crdlm_compile_ProgramLocalParameter4fARB( GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceProgramLocalParameter4fARB *instance;
	instance = crCalloc(sizeof(struct instanceProgramLocalParameter4fARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding ProgramLocalParameter4fARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeProgramLocalParameter4fARB;
	instance->target = target;
	instance->index = index;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	instance->w = w;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** ProgramLocalParameter4fvARB ***/
static void DLM_APIENTRY passProgramLocalParameter4fvARB(GLenum target, GLuint index, const GLfloat * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ProgramLocalParameter4fvARB(target, index, params);
}
static void DLM_APIENTRY executeProgramLocalParameter4fvARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceProgramLocalParameter4fvARB *instance = (struct instanceProgramLocalParameter4fvARB *)x;
	dispatchTable->ProgramLocalParameter4fvARB(instance->target, instance->index, instance->params);
}
void DLM_APIENTRY crdlm_compile_ProgramLocalParameter4fvARB( GLenum target, GLuint index, const GLfloat * params )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceProgramLocalParameter4fvARB *instance;
	instance = crCalloc(sizeof(struct instanceProgramLocalParameter4fvARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding ProgramLocalParameter4fvARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeProgramLocalParameter4fvARB;
	instance->target = target;
	instance->index = index;
	if (params == NULL) {
		instance->params = NULL;
	}
	else {
		instance->params = instance->paramsData;
	}
	crMemcpy((void *)instance->params, (void *) params, 4*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** ProgramNamedParameter4dNV ***/
static void DLM_APIENTRY passProgramNamedParameter4dNV(GLuint id, GLsizei len, const GLubyte * name, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ProgramNamedParameter4dNV(id, len, name, x, y, z, w);
}
static void DLM_APIENTRY executeProgramNamedParameter4dNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceProgramNamedParameter4dNV *instance = (struct instanceProgramNamedParameter4dNV *)x;
	dispatchTable->ProgramNamedParameter4dNV(instance->id, instance->len, instance->name, instance->x, instance->y, instance->z, instance->w);
}
void DLM_APIENTRY crdlm_compile_ProgramNamedParameter4dNV( GLuint id, GLsizei len, const GLubyte * name, GLdouble x, GLdouble y, GLdouble z, GLdouble w )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceProgramNamedParameter4dNV *instance;
	instance = crCalloc(sizeof(struct instanceProgramNamedParameter4dNV) + crdlm_pointers_ProgramNamedParameter4dNV(NULL, id, len, name, x, y, z, w));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding ProgramNamedParameter4dNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeProgramNamedParameter4dNV;
	instance->id = id;
	instance->len = len;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	instance->w = w;
	if (name == NULL) {
		instance->name = NULL;
	}
	else {
		instance->name = instance->nameData;
	}
	(void) crdlm_pointers_ProgramNamedParameter4dNV(instance, id, len, name, x, y, z, w);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** ProgramNamedParameter4dvNV ***/
static void DLM_APIENTRY passProgramNamedParameter4dvNV(GLuint id, GLsizei len, const GLubyte * name, const GLdouble * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ProgramNamedParameter4dvNV(id, len, name, v);
}
static void DLM_APIENTRY executeProgramNamedParameter4dvNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceProgramNamedParameter4dvNV *instance = (struct instanceProgramNamedParameter4dvNV *)x;
	dispatchTable->ProgramNamedParameter4dvNV(instance->id, instance->len, instance->name, instance->v);
}
void DLM_APIENTRY crdlm_compile_ProgramNamedParameter4dvNV( GLuint id, GLsizei len, const GLubyte * name, const GLdouble * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceProgramNamedParameter4dvNV *instance;
	instance = crCalloc(sizeof(struct instanceProgramNamedParameter4dvNV) + crdlm_pointers_ProgramNamedParameter4dvNV(NULL, id, len, name, v));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding ProgramNamedParameter4dvNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeProgramNamedParameter4dvNV;
	instance->id = id;
	instance->len = len;
	(void) crdlm_pointers_ProgramNamedParameter4dvNV(instance, id, len, name, v);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** ProgramNamedParameter4fNV ***/
static void DLM_APIENTRY passProgramNamedParameter4fNV(GLuint id, GLsizei len, const GLubyte * name, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ProgramNamedParameter4fNV(id, len, name, x, y, z, w);
}
static void DLM_APIENTRY executeProgramNamedParameter4fNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceProgramNamedParameter4fNV *instance = (struct instanceProgramNamedParameter4fNV *)x;
	dispatchTable->ProgramNamedParameter4fNV(instance->id, instance->len, instance->name, instance->x, instance->y, instance->z, instance->w);
}
void DLM_APIENTRY crdlm_compile_ProgramNamedParameter4fNV( GLuint id, GLsizei len, const GLubyte * name, GLfloat x, GLfloat y, GLfloat z, GLfloat w )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceProgramNamedParameter4fNV *instance;
	instance = crCalloc(sizeof(struct instanceProgramNamedParameter4fNV) + crdlm_pointers_ProgramNamedParameter4fNV(NULL, id, len, name, x, y, z, w));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding ProgramNamedParameter4fNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeProgramNamedParameter4fNV;
	instance->id = id;
	instance->len = len;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	instance->w = w;
	if (name == NULL) {
		instance->name = NULL;
	}
	else {
		instance->name = instance->nameData;
	}
	(void) crdlm_pointers_ProgramNamedParameter4fNV(instance, id, len, name, x, y, z, w);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** ProgramNamedParameter4fvNV ***/
static void DLM_APIENTRY passProgramNamedParameter4fvNV(GLuint id, GLsizei len, const GLubyte * name, const GLfloat * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ProgramNamedParameter4fvNV(id, len, name, v);
}
static void DLM_APIENTRY executeProgramNamedParameter4fvNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceProgramNamedParameter4fvNV *instance = (struct instanceProgramNamedParameter4fvNV *)x;
	dispatchTable->ProgramNamedParameter4fvNV(instance->id, instance->len, instance->name, instance->v);
}
void DLM_APIENTRY crdlm_compile_ProgramNamedParameter4fvNV( GLuint id, GLsizei len, const GLubyte * name, const GLfloat * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceProgramNamedParameter4fvNV *instance;
	instance = crCalloc(sizeof(struct instanceProgramNamedParameter4fvNV) + crdlm_pointers_ProgramNamedParameter4fvNV(NULL, id, len, name, v));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding ProgramNamedParameter4fvNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeProgramNamedParameter4fvNV;
	instance->id = id;
	instance->len = len;
	(void) crdlm_pointers_ProgramNamedParameter4fvNV(instance, id, len, name, v);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** ProgramParameter4dNV ***/
static void DLM_APIENTRY passProgramParameter4dNV(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ProgramParameter4dNV(target, index, x, y, z, w);
}
static void DLM_APIENTRY executeProgramParameter4dNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceProgramParameter4dNV *instance = (struct instanceProgramParameter4dNV *)x;
	dispatchTable->ProgramParameter4dNV(instance->target, instance->index, instance->x, instance->y, instance->z, instance->w);
}
void DLM_APIENTRY crdlm_compile_ProgramParameter4dNV( GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceProgramParameter4dNV *instance;
	instance = crCalloc(sizeof(struct instanceProgramParameter4dNV));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding ProgramParameter4dNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeProgramParameter4dNV;
	instance->target = target;
	instance->index = index;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	instance->w = w;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** ProgramParameter4dvNV ***/
static void DLM_APIENTRY passProgramParameter4dvNV(GLenum target, GLuint index, const GLdouble * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ProgramParameter4dvNV(target, index, params);
}
static void DLM_APIENTRY executeProgramParameter4dvNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceProgramParameter4dvNV *instance = (struct instanceProgramParameter4dvNV *)x;
	dispatchTable->ProgramParameter4dvNV(instance->target, instance->index, instance->params);
}
void DLM_APIENTRY crdlm_compile_ProgramParameter4dvNV( GLenum target, GLuint index, const GLdouble * params )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceProgramParameter4dvNV *instance;
	instance = crCalloc(sizeof(struct instanceProgramParameter4dvNV));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding ProgramParameter4dvNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeProgramParameter4dvNV;
	instance->target = target;
	instance->index = index;
	if (params == NULL) {
		instance->params = NULL;
	}
	else {
		instance->params = instance->paramsData;
	}
	crMemcpy((void *)instance->params, (void *) params, 4*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** ProgramParameter4fNV ***/
static void DLM_APIENTRY passProgramParameter4fNV(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ProgramParameter4fNV(target, index, x, y, z, w);
}
static void DLM_APIENTRY executeProgramParameter4fNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceProgramParameter4fNV *instance = (struct instanceProgramParameter4fNV *)x;
	dispatchTable->ProgramParameter4fNV(instance->target, instance->index, instance->x, instance->y, instance->z, instance->w);
}
void DLM_APIENTRY crdlm_compile_ProgramParameter4fNV( GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceProgramParameter4fNV *instance;
	instance = crCalloc(sizeof(struct instanceProgramParameter4fNV));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding ProgramParameter4fNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeProgramParameter4fNV;
	instance->target = target;
	instance->index = index;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	instance->w = w;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** ProgramParameter4fvNV ***/
static void DLM_APIENTRY passProgramParameter4fvNV(GLenum target, GLuint index, const GLfloat * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ProgramParameter4fvNV(target, index, params);
}
static void DLM_APIENTRY executeProgramParameter4fvNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceProgramParameter4fvNV *instance = (struct instanceProgramParameter4fvNV *)x;
	dispatchTable->ProgramParameter4fvNV(instance->target, instance->index, instance->params);
}
void DLM_APIENTRY crdlm_compile_ProgramParameter4fvNV( GLenum target, GLuint index, const GLfloat * params )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceProgramParameter4fvNV *instance;
	instance = crCalloc(sizeof(struct instanceProgramParameter4fvNV));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding ProgramParameter4fvNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeProgramParameter4fvNV;
	instance->target = target;
	instance->index = index;
	if (params == NULL) {
		instance->params = NULL;
	}
	else {
		instance->params = instance->paramsData;
	}
	crMemcpy((void *)instance->params, (void *) params, 4*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** ProgramParameters4dvNV ***/
static void DLM_APIENTRY passProgramParameters4dvNV(GLenum target, GLuint index, GLuint num, const GLdouble * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ProgramParameters4dvNV(target, index, num, params);
}
static void DLM_APIENTRY executeProgramParameters4dvNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceProgramParameters4dvNV *instance = (struct instanceProgramParameters4dvNV *)x;
	dispatchTable->ProgramParameters4dvNV(instance->target, instance->index, instance->num, instance->params);
}
void DLM_APIENTRY crdlm_compile_ProgramParameters4dvNV( GLenum target, GLuint index, GLuint num, const GLdouble * params )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceProgramParameters4dvNV *instance;
	instance = crCalloc(sizeof(struct instanceProgramParameters4dvNV));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding ProgramParameters4dvNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeProgramParameters4dvNV;
	instance->target = target;
	instance->index = index;
	instance->num = num;
	if (params == NULL) {
		instance->params = NULL;
	}
	else {
		instance->params = instance->paramsData;
	}
	crMemcpy((void *)instance->params, (void *) params, 4*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** ProgramParameters4fvNV ***/
static void DLM_APIENTRY passProgramParameters4fvNV(GLenum target, GLuint index, GLuint num, const GLfloat * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ProgramParameters4fvNV(target, index, num, params);
}
static void DLM_APIENTRY executeProgramParameters4fvNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceProgramParameters4fvNV *instance = (struct instanceProgramParameters4fvNV *)x;
	dispatchTable->ProgramParameters4fvNV(instance->target, instance->index, instance->num, instance->params);
}
void DLM_APIENTRY crdlm_compile_ProgramParameters4fvNV( GLenum target, GLuint index, GLuint num, const GLfloat * params )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceProgramParameters4fvNV *instance;
	instance = crCalloc(sizeof(struct instanceProgramParameters4fvNV));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding ProgramParameters4fvNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeProgramParameters4fvNV;
	instance->target = target;
	instance->index = index;
	instance->num = num;
	if (params == NULL) {
		instance->params = NULL;
	}
	else {
		instance->params = instance->paramsData;
	}
	crMemcpy((void *)instance->params, (void *) params, 4*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** ProgramStringARB ***/
static void DLM_APIENTRY passProgramStringARB(GLenum target, GLenum format, GLsizei len, const GLvoid * string)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ProgramStringARB(target, format, len, string);
}
static void DLM_APIENTRY executeProgramStringARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceProgramStringARB *instance = (struct instanceProgramStringARB *)x;
	dispatchTable->ProgramStringARB(instance->target, instance->format, instance->len, instance->string);
}
void DLM_APIENTRY crdlm_compile_ProgramStringARB( GLenum target, GLenum format, GLsizei len, const GLvoid * string )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceProgramStringARB *instance;
	instance = crCalloc(sizeof(struct instanceProgramStringARB) + crdlm_pointers_ProgramStringARB(NULL, target, format, len, string));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding ProgramStringARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeProgramStringARB;
	instance->target = target;
	instance->format = format;
	instance->len = len;
	if (string == NULL) {
		instance->string = NULL;
	}
	else {
		instance->string = instance->stringData;
	}
	(void) crdlm_pointers_ProgramStringARB(instance, target, format, len, string);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** PushAttrib ***/
static void DLM_APIENTRY passPushAttrib(GLbitfield mask)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.PushAttrib(mask);
}
static void DLM_APIENTRY executePushAttrib(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instancePushAttrib *instance = (struct instancePushAttrib *)x;
	dispatchTable->PushAttrib(instance->mask);
}
void DLM_APIENTRY crdlm_compile_PushAttrib( GLbitfield mask )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instancePushAttrib *instance;
	instance = crCalloc(sizeof(struct instancePushAttrib));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding PushAttrib to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executePushAttrib;
	instance->mask = mask;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** PushClientAttrib ***/
static void DLM_APIENTRY passPushClientAttrib(GLbitfield mask)
{
	CRDLMContextState *state = CURRENT_STATE();
	crdlmPushClientAttrib(mask, state->clientState);
	state->savedDispatchTable.PushClientAttrib(mask);
}

/*** PushMatrix ***/
static void DLM_APIENTRY passPushMatrix(void)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.PushMatrix();
}
static void DLM_APIENTRY executePushMatrix(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	dispatchTable->PushMatrix();
}
void DLM_APIENTRY crdlm_compile_PushMatrix( void )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instancePushMatrix *instance;
	instance = crCalloc(sizeof(struct instancePushMatrix));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding PushMatrix to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executePushMatrix;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** PushName ***/
static void DLM_APIENTRY passPushName(GLuint name)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.PushName(name);
}
static void DLM_APIENTRY executePushName(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instancePushName *instance = (struct instancePushName *)x;
	dispatchTable->PushName(instance->name);
}
void DLM_APIENTRY crdlm_compile_PushName( GLuint name )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instancePushName *instance;
	instance = crCalloc(sizeof(struct instancePushName));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding PushName to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executePushName;
	instance->name = name;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** RasterPos2d ***/
static void DLM_APIENTRY passRasterPos2d(GLdouble x, GLdouble y)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.RasterPos2d(x, y);
}
static void DLM_APIENTRY executeRasterPos2d(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceRasterPos2d *instance = (struct instanceRasterPos2d *)x;
	dispatchTable->RasterPos2d(instance->x, instance->y);
}
void DLM_APIENTRY crdlm_compile_RasterPos2d( GLdouble x, GLdouble y )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceRasterPos2d *instance;
	instance = crCalloc(sizeof(struct instanceRasterPos2d));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding RasterPos2d to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeRasterPos2d;
	instance->x = x;
	instance->y = y;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** RasterPos2dv ***/
static void DLM_APIENTRY passRasterPos2dv(const GLdouble * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.RasterPos2dv(v);
}
static void DLM_APIENTRY executeRasterPos2dv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceRasterPos2dv *instance = (struct instanceRasterPos2dv *)x;
	dispatchTable->RasterPos2dv(instance->v);
}
void DLM_APIENTRY crdlm_compile_RasterPos2dv( const GLdouble * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceRasterPos2dv *instance;
	instance = crCalloc(sizeof(struct instanceRasterPos2dv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding RasterPos2dv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeRasterPos2dv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 2*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** RasterPos2f ***/
static void DLM_APIENTRY passRasterPos2f(GLfloat x, GLfloat y)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.RasterPos2f(x, y);
}
static void DLM_APIENTRY executeRasterPos2f(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceRasterPos2f *instance = (struct instanceRasterPos2f *)x;
	dispatchTable->RasterPos2f(instance->x, instance->y);
}
void DLM_APIENTRY crdlm_compile_RasterPos2f( GLfloat x, GLfloat y )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceRasterPos2f *instance;
	instance = crCalloc(sizeof(struct instanceRasterPos2f));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding RasterPos2f to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeRasterPos2f;
	instance->x = x;
	instance->y = y;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** RasterPos2fv ***/
static void DLM_APIENTRY passRasterPos2fv(const GLfloat * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.RasterPos2fv(v);
}
static void DLM_APIENTRY executeRasterPos2fv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceRasterPos2fv *instance = (struct instanceRasterPos2fv *)x;
	dispatchTable->RasterPos2fv(instance->v);
}
void DLM_APIENTRY crdlm_compile_RasterPos2fv( const GLfloat * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceRasterPos2fv *instance;
	instance = crCalloc(sizeof(struct instanceRasterPos2fv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding RasterPos2fv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeRasterPos2fv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 2*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** RasterPos2i ***/
static void DLM_APIENTRY passRasterPos2i(GLint x, GLint y)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.RasterPos2i(x, y);
}
static void DLM_APIENTRY executeRasterPos2i(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceRasterPos2i *instance = (struct instanceRasterPos2i *)x;
	dispatchTable->RasterPos2i(instance->x, instance->y);
}
void DLM_APIENTRY crdlm_compile_RasterPos2i( GLint x, GLint y )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceRasterPos2i *instance;
	instance = crCalloc(sizeof(struct instanceRasterPos2i));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding RasterPos2i to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeRasterPos2i;
	instance->x = x;
	instance->y = y;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** RasterPos2iv ***/
static void DLM_APIENTRY passRasterPos2iv(const GLint * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.RasterPos2iv(v);
}
static void DLM_APIENTRY executeRasterPos2iv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceRasterPos2iv *instance = (struct instanceRasterPos2iv *)x;
	dispatchTable->RasterPos2iv(instance->v);
}
void DLM_APIENTRY crdlm_compile_RasterPos2iv( const GLint * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceRasterPos2iv *instance;
	instance = crCalloc(sizeof(struct instanceRasterPos2iv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding RasterPos2iv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeRasterPos2iv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 2*sizeof(GLint));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** RasterPos2s ***/
static void DLM_APIENTRY passRasterPos2s(GLshort x, GLshort y)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.RasterPos2s(x, y);
}
static void DLM_APIENTRY executeRasterPos2s(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceRasterPos2s *instance = (struct instanceRasterPos2s *)x;
	dispatchTable->RasterPos2s(instance->x, instance->y);
}
void DLM_APIENTRY crdlm_compile_RasterPos2s( GLshort x, GLshort y )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceRasterPos2s *instance;
	instance = crCalloc(sizeof(struct instanceRasterPos2s));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding RasterPos2s to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeRasterPos2s;
	instance->x = x;
	instance->y = y;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** RasterPos2sv ***/
static void DLM_APIENTRY passRasterPos2sv(const GLshort * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.RasterPos2sv(v);
}
static void DLM_APIENTRY executeRasterPos2sv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceRasterPos2sv *instance = (struct instanceRasterPos2sv *)x;
	dispatchTable->RasterPos2sv(instance->v);
}
void DLM_APIENTRY crdlm_compile_RasterPos2sv( const GLshort * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceRasterPos2sv *instance;
	instance = crCalloc(sizeof(struct instanceRasterPos2sv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding RasterPos2sv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeRasterPos2sv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 2*sizeof(GLshort));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** RasterPos3d ***/
static void DLM_APIENTRY passRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.RasterPos3d(x, y, z);
}
static void DLM_APIENTRY executeRasterPos3d(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceRasterPos3d *instance = (struct instanceRasterPos3d *)x;
	dispatchTable->RasterPos3d(instance->x, instance->y, instance->z);
}
void DLM_APIENTRY crdlm_compile_RasterPos3d( GLdouble x, GLdouble y, GLdouble z )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceRasterPos3d *instance;
	instance = crCalloc(sizeof(struct instanceRasterPos3d));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding RasterPos3d to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeRasterPos3d;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** RasterPos3dv ***/
static void DLM_APIENTRY passRasterPos3dv(const GLdouble * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.RasterPos3dv(v);
}
static void DLM_APIENTRY executeRasterPos3dv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceRasterPos3dv *instance = (struct instanceRasterPos3dv *)x;
	dispatchTable->RasterPos3dv(instance->v);
}
void DLM_APIENTRY crdlm_compile_RasterPos3dv( const GLdouble * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceRasterPos3dv *instance;
	instance = crCalloc(sizeof(struct instanceRasterPos3dv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding RasterPos3dv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeRasterPos3dv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** RasterPos3f ***/
static void DLM_APIENTRY passRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.RasterPos3f(x, y, z);
}
static void DLM_APIENTRY executeRasterPos3f(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceRasterPos3f *instance = (struct instanceRasterPos3f *)x;
	dispatchTable->RasterPos3f(instance->x, instance->y, instance->z);
}
void DLM_APIENTRY crdlm_compile_RasterPos3f( GLfloat x, GLfloat y, GLfloat z )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceRasterPos3f *instance;
	instance = crCalloc(sizeof(struct instanceRasterPos3f));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding RasterPos3f to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeRasterPos3f;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** RasterPos3fv ***/
static void DLM_APIENTRY passRasterPos3fv(const GLfloat * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.RasterPos3fv(v);
}
static void DLM_APIENTRY executeRasterPos3fv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceRasterPos3fv *instance = (struct instanceRasterPos3fv *)x;
	dispatchTable->RasterPos3fv(instance->v);
}
void DLM_APIENTRY crdlm_compile_RasterPos3fv( const GLfloat * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceRasterPos3fv *instance;
	instance = crCalloc(sizeof(struct instanceRasterPos3fv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding RasterPos3fv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeRasterPos3fv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** RasterPos3i ***/
static void DLM_APIENTRY passRasterPos3i(GLint x, GLint y, GLint z)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.RasterPos3i(x, y, z);
}
static void DLM_APIENTRY executeRasterPos3i(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceRasterPos3i *instance = (struct instanceRasterPos3i *)x;
	dispatchTable->RasterPos3i(instance->x, instance->y, instance->z);
}
void DLM_APIENTRY crdlm_compile_RasterPos3i( GLint x, GLint y, GLint z )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceRasterPos3i *instance;
	instance = crCalloc(sizeof(struct instanceRasterPos3i));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding RasterPos3i to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeRasterPos3i;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** RasterPos3iv ***/
static void DLM_APIENTRY passRasterPos3iv(const GLint * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.RasterPos3iv(v);
}
static void DLM_APIENTRY executeRasterPos3iv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceRasterPos3iv *instance = (struct instanceRasterPos3iv *)x;
	dispatchTable->RasterPos3iv(instance->v);
}
void DLM_APIENTRY crdlm_compile_RasterPos3iv( const GLint * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceRasterPos3iv *instance;
	instance = crCalloc(sizeof(struct instanceRasterPos3iv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding RasterPos3iv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeRasterPos3iv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLint));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** RasterPos3s ***/
static void DLM_APIENTRY passRasterPos3s(GLshort x, GLshort y, GLshort z)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.RasterPos3s(x, y, z);
}
static void DLM_APIENTRY executeRasterPos3s(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceRasterPos3s *instance = (struct instanceRasterPos3s *)x;
	dispatchTable->RasterPos3s(instance->x, instance->y, instance->z);
}
void DLM_APIENTRY crdlm_compile_RasterPos3s( GLshort x, GLshort y, GLshort z )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceRasterPos3s *instance;
	instance = crCalloc(sizeof(struct instanceRasterPos3s));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding RasterPos3s to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeRasterPos3s;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** RasterPos3sv ***/
static void DLM_APIENTRY passRasterPos3sv(const GLshort * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.RasterPos3sv(v);
}
static void DLM_APIENTRY executeRasterPos3sv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceRasterPos3sv *instance = (struct instanceRasterPos3sv *)x;
	dispatchTable->RasterPos3sv(instance->v);
}
void DLM_APIENTRY crdlm_compile_RasterPos3sv( const GLshort * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceRasterPos3sv *instance;
	instance = crCalloc(sizeof(struct instanceRasterPos3sv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding RasterPos3sv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeRasterPos3sv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLshort));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** RasterPos4d ***/
static void DLM_APIENTRY passRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.RasterPos4d(x, y, z, w);
}
static void DLM_APIENTRY executeRasterPos4d(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceRasterPos4d *instance = (struct instanceRasterPos4d *)x;
	dispatchTable->RasterPos4d(instance->x, instance->y, instance->z, instance->w);
}
void DLM_APIENTRY crdlm_compile_RasterPos4d( GLdouble x, GLdouble y, GLdouble z, GLdouble w )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceRasterPos4d *instance;
	instance = crCalloc(sizeof(struct instanceRasterPos4d));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding RasterPos4d to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeRasterPos4d;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	instance->w = w;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** RasterPos4dv ***/
static void DLM_APIENTRY passRasterPos4dv(const GLdouble * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.RasterPos4dv(v);
}
static void DLM_APIENTRY executeRasterPos4dv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceRasterPos4dv *instance = (struct instanceRasterPos4dv *)x;
	dispatchTable->RasterPos4dv(instance->v);
}
void DLM_APIENTRY crdlm_compile_RasterPos4dv( const GLdouble * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceRasterPos4dv *instance;
	instance = crCalloc(sizeof(struct instanceRasterPos4dv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding RasterPos4dv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeRasterPos4dv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 4*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** RasterPos4f ***/
static void DLM_APIENTRY passRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.RasterPos4f(x, y, z, w);
}
static void DLM_APIENTRY executeRasterPos4f(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceRasterPos4f *instance = (struct instanceRasterPos4f *)x;
	dispatchTable->RasterPos4f(instance->x, instance->y, instance->z, instance->w);
}
void DLM_APIENTRY crdlm_compile_RasterPos4f( GLfloat x, GLfloat y, GLfloat z, GLfloat w )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceRasterPos4f *instance;
	instance = crCalloc(sizeof(struct instanceRasterPos4f));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding RasterPos4f to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeRasterPos4f;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	instance->w = w;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** RasterPos4fv ***/
static void DLM_APIENTRY passRasterPos4fv(const GLfloat * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.RasterPos4fv(v);
}
static void DLM_APIENTRY executeRasterPos4fv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceRasterPos4fv *instance = (struct instanceRasterPos4fv *)x;
	dispatchTable->RasterPos4fv(instance->v);
}
void DLM_APIENTRY crdlm_compile_RasterPos4fv( const GLfloat * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceRasterPos4fv *instance;
	instance = crCalloc(sizeof(struct instanceRasterPos4fv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding RasterPos4fv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeRasterPos4fv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 4*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** RasterPos4i ***/
static void DLM_APIENTRY passRasterPos4i(GLint x, GLint y, GLint z, GLint w)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.RasterPos4i(x, y, z, w);
}
static void DLM_APIENTRY executeRasterPos4i(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceRasterPos4i *instance = (struct instanceRasterPos4i *)x;
	dispatchTable->RasterPos4i(instance->x, instance->y, instance->z, instance->w);
}
void DLM_APIENTRY crdlm_compile_RasterPos4i( GLint x, GLint y, GLint z, GLint w )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceRasterPos4i *instance;
	instance = crCalloc(sizeof(struct instanceRasterPos4i));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding RasterPos4i to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeRasterPos4i;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	instance->w = w;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** RasterPos4iv ***/
static void DLM_APIENTRY passRasterPos4iv(const GLint * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.RasterPos4iv(v);
}
static void DLM_APIENTRY executeRasterPos4iv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceRasterPos4iv *instance = (struct instanceRasterPos4iv *)x;
	dispatchTable->RasterPos4iv(instance->v);
}
void DLM_APIENTRY crdlm_compile_RasterPos4iv( const GLint * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceRasterPos4iv *instance;
	instance = crCalloc(sizeof(struct instanceRasterPos4iv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding RasterPos4iv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeRasterPos4iv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 4*sizeof(GLint));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** RasterPos4s ***/
static void DLM_APIENTRY passRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.RasterPos4s(x, y, z, w);
}
static void DLM_APIENTRY executeRasterPos4s(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceRasterPos4s *instance = (struct instanceRasterPos4s *)x;
	dispatchTable->RasterPos4s(instance->x, instance->y, instance->z, instance->w);
}
void DLM_APIENTRY crdlm_compile_RasterPos4s( GLshort x, GLshort y, GLshort z, GLshort w )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceRasterPos4s *instance;
	instance = crCalloc(sizeof(struct instanceRasterPos4s));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding RasterPos4s to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeRasterPos4s;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	instance->w = w;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** RasterPos4sv ***/
static void DLM_APIENTRY passRasterPos4sv(const GLshort * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.RasterPos4sv(v);
}
static void DLM_APIENTRY executeRasterPos4sv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceRasterPos4sv *instance = (struct instanceRasterPos4sv *)x;
	dispatchTable->RasterPos4sv(instance->v);
}
void DLM_APIENTRY crdlm_compile_RasterPos4sv( const GLshort * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceRasterPos4sv *instance;
	instance = crCalloc(sizeof(struct instanceRasterPos4sv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding RasterPos4sv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeRasterPos4sv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 4*sizeof(GLshort));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** ReadBuffer ***/
static void DLM_APIENTRY passReadBuffer(GLenum mode)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ReadBuffer(mode);
}
static void DLM_APIENTRY executeReadBuffer(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceReadBuffer *instance = (struct instanceReadBuffer *)x;
	dispatchTable->ReadBuffer(instance->mode);
}
void DLM_APIENTRY crdlm_compile_ReadBuffer( GLenum mode )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceReadBuffer *instance;
	instance = crCalloc(sizeof(struct instanceReadBuffer));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding ReadBuffer to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeReadBuffer;
	instance->mode = mode;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** ReadPixels ***/
static void DLM_APIENTRY passReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid * pixels)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ReadPixels(x, y, width, height, format, type, pixels);
}

/*** Rectd ***/
static void DLM_APIENTRY passRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Rectd(x1, y1, x2, y2);
}
static void DLM_APIENTRY executeRectd(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceRectd *instance = (struct instanceRectd *)x;
	dispatchTable->Rectd(instance->x1, instance->y1, instance->x2, instance->y2);
}
void DLM_APIENTRY crdlm_compile_Rectd( GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2 )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceRectd *instance;
	instance = crCalloc(sizeof(struct instanceRectd));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Rectd to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeRectd;
	instance->x1 = x1;
	instance->y1 = y1;
	instance->x2 = x2;
	instance->y2 = y2;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Rectdv ***/
static void DLM_APIENTRY passRectdv(const GLdouble * v1, const GLdouble * v2)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Rectdv(v1, v2);
}
static void DLM_APIENTRY executeRectdv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceRectdv *instance = (struct instanceRectdv *)x;
	dispatchTable->Rectdv(instance->v1, instance->v2);
}
void DLM_APIENTRY crdlm_compile_Rectdv( const GLdouble * v1, const GLdouble * v2 )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceRectdv *instance;
	instance = crCalloc(sizeof(struct instanceRectdv) + crdlm_pointers_Rectdv(NULL, v1, v2));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Rectdv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeRectdv;
	(void) crdlm_pointers_Rectdv(instance, v1, v2);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Rectf ***/
static void DLM_APIENTRY passRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Rectf(x1, y1, x2, y2);
}
static void DLM_APIENTRY executeRectf(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceRectf *instance = (struct instanceRectf *)x;
	dispatchTable->Rectf(instance->x1, instance->y1, instance->x2, instance->y2);
}
void DLM_APIENTRY crdlm_compile_Rectf( GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2 )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceRectf *instance;
	instance = crCalloc(sizeof(struct instanceRectf));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Rectf to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeRectf;
	instance->x1 = x1;
	instance->y1 = y1;
	instance->x2 = x2;
	instance->y2 = y2;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Rectfv ***/
static void DLM_APIENTRY passRectfv(const GLfloat * v1, const GLfloat * v2)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Rectfv(v1, v2);
}
static void DLM_APIENTRY executeRectfv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceRectfv *instance = (struct instanceRectfv *)x;
	dispatchTable->Rectfv(instance->v1, instance->v2);
}
void DLM_APIENTRY crdlm_compile_Rectfv( const GLfloat * v1, const GLfloat * v2 )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceRectfv *instance;
	instance = crCalloc(sizeof(struct instanceRectfv) + crdlm_pointers_Rectfv(NULL, v1, v2));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Rectfv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeRectfv;
	(void) crdlm_pointers_Rectfv(instance, v1, v2);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Recti ***/
static void DLM_APIENTRY passRecti(GLint x1, GLint y1, GLint x2, GLint y2)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Recti(x1, y1, x2, y2);
}
static void DLM_APIENTRY executeRecti(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceRecti *instance = (struct instanceRecti *)x;
	dispatchTable->Recti(instance->x1, instance->y1, instance->x2, instance->y2);
}
void DLM_APIENTRY crdlm_compile_Recti( GLint x1, GLint y1, GLint x2, GLint y2 )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceRecti *instance;
	instance = crCalloc(sizeof(struct instanceRecti));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Recti to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeRecti;
	instance->x1 = x1;
	instance->y1 = y1;
	instance->x2 = x2;
	instance->y2 = y2;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Rectiv ***/
static void DLM_APIENTRY passRectiv(const GLint * v1, const GLint * v2)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Rectiv(v1, v2);
}
static void DLM_APIENTRY executeRectiv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceRectiv *instance = (struct instanceRectiv *)x;
	dispatchTable->Rectiv(instance->v1, instance->v2);
}
void DLM_APIENTRY crdlm_compile_Rectiv( const GLint * v1, const GLint * v2 )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceRectiv *instance;
	instance = crCalloc(sizeof(struct instanceRectiv) + crdlm_pointers_Rectiv(NULL, v1, v2));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Rectiv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeRectiv;
	(void) crdlm_pointers_Rectiv(instance, v1, v2);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Rects ***/
static void DLM_APIENTRY passRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Rects(x1, y1, x2, y2);
}
static void DLM_APIENTRY executeRects(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceRects *instance = (struct instanceRects *)x;
	dispatchTable->Rects(instance->x1, instance->y1, instance->x2, instance->y2);
}
void DLM_APIENTRY crdlm_compile_Rects( GLshort x1, GLshort y1, GLshort x2, GLshort y2 )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceRects *instance;
	instance = crCalloc(sizeof(struct instanceRects));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Rects to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeRects;
	instance->x1 = x1;
	instance->y1 = y1;
	instance->x2 = x2;
	instance->y2 = y2;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Rectsv ***/
static void DLM_APIENTRY passRectsv(const GLshort * v1, const GLshort * v2)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Rectsv(v1, v2);
}
static void DLM_APIENTRY executeRectsv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceRectsv *instance = (struct instanceRectsv *)x;
	dispatchTable->Rectsv(instance->v1, instance->v2);
}
void DLM_APIENTRY crdlm_compile_Rectsv( const GLshort * v1, const GLshort * v2 )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceRectsv *instance;
	instance = crCalloc(sizeof(struct instanceRectsv) + crdlm_pointers_Rectsv(NULL, v1, v2));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Rectsv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeRectsv;
	(void) crdlm_pointers_Rectsv(instance, v1, v2);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** RenderMode ***/
static GLint DLM_APIENTRY passRenderMode(GLenum mode)
{
	CRDLMContextState *state = CURRENT_STATE();
	return state->savedDispatchTable.RenderMode(mode);
}

/*** RequestResidentProgramsNV ***/
static void DLM_APIENTRY passRequestResidentProgramsNV(GLsizei n, const GLuint * ids)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.RequestResidentProgramsNV(n, ids);
}
static void DLM_APIENTRY executeRequestResidentProgramsNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceRequestResidentProgramsNV *instance = (struct instanceRequestResidentProgramsNV *)x;
	dispatchTable->RequestResidentProgramsNV(instance->n, instance->ids);
}
void DLM_APIENTRY crdlm_compile_RequestResidentProgramsNV( GLsizei n, const GLuint * ids )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceRequestResidentProgramsNV *instance;
	instance = crCalloc(sizeof(struct instanceRequestResidentProgramsNV) + crdlm_pointers_RequestResidentProgramsNV(NULL, n, ids));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding RequestResidentProgramsNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeRequestResidentProgramsNV;
	instance->n = n;
	if (ids == NULL) {
		instance->ids = NULL;
	}
	else {
		instance->ids = instance->idsData;
	}
	(void) crdlm_pointers_RequestResidentProgramsNV(instance, n, ids);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Rotated ***/
static void DLM_APIENTRY passRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Rotated(angle, x, y, z);
}
static void DLM_APIENTRY executeRotated(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceRotated *instance = (struct instanceRotated *)x;
	dispatchTable->Rotated(instance->angle, instance->x, instance->y, instance->z);
}
void DLM_APIENTRY crdlm_compile_Rotated( GLdouble angle, GLdouble x, GLdouble y, GLdouble z )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceRotated *instance;
	instance = crCalloc(sizeof(struct instanceRotated));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Rotated to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeRotated;
	instance->angle = angle;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Rotatef ***/
static void DLM_APIENTRY passRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Rotatef(angle, x, y, z);
}
static void DLM_APIENTRY executeRotatef(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceRotatef *instance = (struct instanceRotatef *)x;
	dispatchTable->Rotatef(instance->angle, instance->x, instance->y, instance->z);
}
void DLM_APIENTRY crdlm_compile_Rotatef( GLfloat angle, GLfloat x, GLfloat y, GLfloat z )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceRotatef *instance;
	instance = crCalloc(sizeof(struct instanceRotatef));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Rotatef to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeRotatef;
	instance->angle = angle;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** SampleCoverageARB ***/
static void DLM_APIENTRY passSampleCoverageARB(GLclampf value, GLboolean invert)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.SampleCoverageARB(value, invert);
}
static void DLM_APIENTRY executeSampleCoverageARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceSampleCoverageARB *instance = (struct instanceSampleCoverageARB *)x;
	dispatchTable->SampleCoverageARB(instance->value, instance->invert);
}
void DLM_APIENTRY crdlm_compile_SampleCoverageARB( GLclampf value, GLboolean invert )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceSampleCoverageARB *instance;
	instance = crCalloc(sizeof(struct instanceSampleCoverageARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding SampleCoverageARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeSampleCoverageARB;
	instance->value = value;
	instance->invert = invert;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Scaled ***/
static void DLM_APIENTRY passScaled(GLdouble x, GLdouble y, GLdouble z)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Scaled(x, y, z);
}
static void DLM_APIENTRY executeScaled(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceScaled *instance = (struct instanceScaled *)x;
	dispatchTable->Scaled(instance->x, instance->y, instance->z);
}
void DLM_APIENTRY crdlm_compile_Scaled( GLdouble x, GLdouble y, GLdouble z )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceScaled *instance;
	instance = crCalloc(sizeof(struct instanceScaled));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Scaled to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeScaled;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Scalef ***/
static void DLM_APIENTRY passScalef(GLfloat x, GLfloat y, GLfloat z)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Scalef(x, y, z);
}
static void DLM_APIENTRY executeScalef(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceScalef *instance = (struct instanceScalef *)x;
	dispatchTable->Scalef(instance->x, instance->y, instance->z);
}
void DLM_APIENTRY crdlm_compile_Scalef( GLfloat x, GLfloat y, GLfloat z )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceScalef *instance;
	instance = crCalloc(sizeof(struct instanceScalef));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Scalef to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeScalef;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Scissor ***/
static void DLM_APIENTRY passScissor(GLint x, GLint y, GLsizei width, GLsizei height)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Scissor(x, y, width, height);
}
static void DLM_APIENTRY executeScissor(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceScissor *instance = (struct instanceScissor *)x;
	dispatchTable->Scissor(instance->x, instance->y, instance->width, instance->height);
}
void DLM_APIENTRY crdlm_compile_Scissor( GLint x, GLint y, GLsizei width, GLsizei height )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceScissor *instance;
	instance = crCalloc(sizeof(struct instanceScissor));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Scissor to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeScissor;
	instance->x = x;
	instance->y = y;
	instance->width = width;
	instance->height = height;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** SecondaryColor3bEXT ***/
static void DLM_APIENTRY passSecondaryColor3bEXT(GLbyte red, GLbyte green, GLbyte blue)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.SecondaryColor3bEXT(red, green, blue);
}
static void DLM_APIENTRY executeSecondaryColor3bEXT(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceSecondaryColor3bEXT *instance = (struct instanceSecondaryColor3bEXT *)x;
	dispatchTable->SecondaryColor3bEXT(instance->red, instance->green, instance->blue);
}
void DLM_APIENTRY crdlm_compile_SecondaryColor3bEXT( GLbyte red, GLbyte green, GLbyte blue )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceSecondaryColor3bEXT *instance;
	instance = crCalloc(sizeof(struct instanceSecondaryColor3bEXT));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding SecondaryColor3bEXT to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeSecondaryColor3bEXT;
	instance->red = red;
	instance->green = green;
	instance->blue = blue;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** SecondaryColor3bvEXT ***/
static void DLM_APIENTRY passSecondaryColor3bvEXT(const GLbyte * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.SecondaryColor3bvEXT(v);
}
static void DLM_APIENTRY executeSecondaryColor3bvEXT(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceSecondaryColor3bvEXT *instance = (struct instanceSecondaryColor3bvEXT *)x;
	dispatchTable->SecondaryColor3bvEXT(instance->v);
}
void DLM_APIENTRY crdlm_compile_SecondaryColor3bvEXT( const GLbyte * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceSecondaryColor3bvEXT *instance;
	instance = crCalloc(sizeof(struct instanceSecondaryColor3bvEXT));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding SecondaryColor3bvEXT to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeSecondaryColor3bvEXT;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLbyte));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** SecondaryColor3dEXT ***/
static void DLM_APIENTRY passSecondaryColor3dEXT(GLdouble red, GLdouble green, GLdouble blue)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.SecondaryColor3dEXT(red, green, blue);
}
static void DLM_APIENTRY executeSecondaryColor3dEXT(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceSecondaryColor3dEXT *instance = (struct instanceSecondaryColor3dEXT *)x;
	dispatchTable->SecondaryColor3dEXT(instance->red, instance->green, instance->blue);
}
void DLM_APIENTRY crdlm_compile_SecondaryColor3dEXT( GLdouble red, GLdouble green, GLdouble blue )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceSecondaryColor3dEXT *instance;
	instance = crCalloc(sizeof(struct instanceSecondaryColor3dEXT));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding SecondaryColor3dEXT to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeSecondaryColor3dEXT;
	instance->red = red;
	instance->green = green;
	instance->blue = blue;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** SecondaryColor3dvEXT ***/
static void DLM_APIENTRY passSecondaryColor3dvEXT(const GLdouble * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.SecondaryColor3dvEXT(v);
}
static void DLM_APIENTRY executeSecondaryColor3dvEXT(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceSecondaryColor3dvEXT *instance = (struct instanceSecondaryColor3dvEXT *)x;
	dispatchTable->SecondaryColor3dvEXT(instance->v);
}
void DLM_APIENTRY crdlm_compile_SecondaryColor3dvEXT( const GLdouble * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceSecondaryColor3dvEXT *instance;
	instance = crCalloc(sizeof(struct instanceSecondaryColor3dvEXT));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding SecondaryColor3dvEXT to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeSecondaryColor3dvEXT;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** SecondaryColor3fEXT ***/
static void DLM_APIENTRY passSecondaryColor3fEXT(GLfloat red, GLfloat green, GLfloat blue)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.SecondaryColor3fEXT(red, green, blue);
}
static void DLM_APIENTRY executeSecondaryColor3fEXT(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceSecondaryColor3fEXT *instance = (struct instanceSecondaryColor3fEXT *)x;
	dispatchTable->SecondaryColor3fEXT(instance->red, instance->green, instance->blue);
}
void DLM_APIENTRY crdlm_compile_SecondaryColor3fEXT( GLfloat red, GLfloat green, GLfloat blue )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceSecondaryColor3fEXT *instance;
	instance = crCalloc(sizeof(struct instanceSecondaryColor3fEXT));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding SecondaryColor3fEXT to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeSecondaryColor3fEXT;
	instance->red = red;
	instance->green = green;
	instance->blue = blue;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** SecondaryColor3fvEXT ***/
static void DLM_APIENTRY passSecondaryColor3fvEXT(const GLfloat * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.SecondaryColor3fvEXT(v);
}
static void DLM_APIENTRY executeSecondaryColor3fvEXT(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceSecondaryColor3fvEXT *instance = (struct instanceSecondaryColor3fvEXT *)x;
	dispatchTable->SecondaryColor3fvEXT(instance->v);
}
void DLM_APIENTRY crdlm_compile_SecondaryColor3fvEXT( const GLfloat * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceSecondaryColor3fvEXT *instance;
	instance = crCalloc(sizeof(struct instanceSecondaryColor3fvEXT));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding SecondaryColor3fvEXT to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeSecondaryColor3fvEXT;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** SecondaryColor3iEXT ***/
static void DLM_APIENTRY passSecondaryColor3iEXT(GLint red, GLint green, GLint blue)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.SecondaryColor3iEXT(red, green, blue);
}
static void DLM_APIENTRY executeSecondaryColor3iEXT(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceSecondaryColor3iEXT *instance = (struct instanceSecondaryColor3iEXT *)x;
	dispatchTable->SecondaryColor3iEXT(instance->red, instance->green, instance->blue);
}
void DLM_APIENTRY crdlm_compile_SecondaryColor3iEXT( GLint red, GLint green, GLint blue )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceSecondaryColor3iEXT *instance;
	instance = crCalloc(sizeof(struct instanceSecondaryColor3iEXT));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding SecondaryColor3iEXT to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeSecondaryColor3iEXT;
	instance->red = red;
	instance->green = green;
	instance->blue = blue;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** SecondaryColor3ivEXT ***/
static void DLM_APIENTRY passSecondaryColor3ivEXT(const GLint * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.SecondaryColor3ivEXT(v);
}
static void DLM_APIENTRY executeSecondaryColor3ivEXT(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceSecondaryColor3ivEXT *instance = (struct instanceSecondaryColor3ivEXT *)x;
	dispatchTable->SecondaryColor3ivEXT(instance->v);
}
void DLM_APIENTRY crdlm_compile_SecondaryColor3ivEXT( const GLint * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceSecondaryColor3ivEXT *instance;
	instance = crCalloc(sizeof(struct instanceSecondaryColor3ivEXT));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding SecondaryColor3ivEXT to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeSecondaryColor3ivEXT;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLint));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** SecondaryColor3sEXT ***/
static void DLM_APIENTRY passSecondaryColor3sEXT(GLshort red, GLshort green, GLshort blue)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.SecondaryColor3sEXT(red, green, blue);
}
static void DLM_APIENTRY executeSecondaryColor3sEXT(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceSecondaryColor3sEXT *instance = (struct instanceSecondaryColor3sEXT *)x;
	dispatchTable->SecondaryColor3sEXT(instance->red, instance->green, instance->blue);
}
void DLM_APIENTRY crdlm_compile_SecondaryColor3sEXT( GLshort red, GLshort green, GLshort blue )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceSecondaryColor3sEXT *instance;
	instance = crCalloc(sizeof(struct instanceSecondaryColor3sEXT));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding SecondaryColor3sEXT to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeSecondaryColor3sEXT;
	instance->red = red;
	instance->green = green;
	instance->blue = blue;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** SecondaryColor3svEXT ***/
static void DLM_APIENTRY passSecondaryColor3svEXT(const GLshort * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.SecondaryColor3svEXT(v);
}
static void DLM_APIENTRY executeSecondaryColor3svEXT(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceSecondaryColor3svEXT *instance = (struct instanceSecondaryColor3svEXT *)x;
	dispatchTable->SecondaryColor3svEXT(instance->v);
}
void DLM_APIENTRY crdlm_compile_SecondaryColor3svEXT( const GLshort * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceSecondaryColor3svEXT *instance;
	instance = crCalloc(sizeof(struct instanceSecondaryColor3svEXT));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding SecondaryColor3svEXT to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeSecondaryColor3svEXT;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLshort));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** SecondaryColor3ubEXT ***/
static void DLM_APIENTRY passSecondaryColor3ubEXT(GLubyte red, GLubyte green, GLubyte blue)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.SecondaryColor3ubEXT(red, green, blue);
}
static void DLM_APIENTRY executeSecondaryColor3ubEXT(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceSecondaryColor3ubEXT *instance = (struct instanceSecondaryColor3ubEXT *)x;
	dispatchTable->SecondaryColor3ubEXT(instance->red, instance->green, instance->blue);
}
void DLM_APIENTRY crdlm_compile_SecondaryColor3ubEXT( GLubyte red, GLubyte green, GLubyte blue )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceSecondaryColor3ubEXT *instance;
	instance = crCalloc(sizeof(struct instanceSecondaryColor3ubEXT));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding SecondaryColor3ubEXT to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeSecondaryColor3ubEXT;
	instance->red = red;
	instance->green = green;
	instance->blue = blue;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** SecondaryColor3ubvEXT ***/
static void DLM_APIENTRY passSecondaryColor3ubvEXT(const GLubyte * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.SecondaryColor3ubvEXT(v);
}
static void DLM_APIENTRY executeSecondaryColor3ubvEXT(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceSecondaryColor3ubvEXT *instance = (struct instanceSecondaryColor3ubvEXT *)x;
	dispatchTable->SecondaryColor3ubvEXT(instance->v);
}
void DLM_APIENTRY crdlm_compile_SecondaryColor3ubvEXT( const GLubyte * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceSecondaryColor3ubvEXT *instance;
	instance = crCalloc(sizeof(struct instanceSecondaryColor3ubvEXT));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding SecondaryColor3ubvEXT to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeSecondaryColor3ubvEXT;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLubyte));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** SecondaryColor3uiEXT ***/
static void DLM_APIENTRY passSecondaryColor3uiEXT(GLuint red, GLuint green, GLuint blue)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.SecondaryColor3uiEXT(red, green, blue);
}
static void DLM_APIENTRY executeSecondaryColor3uiEXT(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceSecondaryColor3uiEXT *instance = (struct instanceSecondaryColor3uiEXT *)x;
	dispatchTable->SecondaryColor3uiEXT(instance->red, instance->green, instance->blue);
}
void DLM_APIENTRY crdlm_compile_SecondaryColor3uiEXT( GLuint red, GLuint green, GLuint blue )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceSecondaryColor3uiEXT *instance;
	instance = crCalloc(sizeof(struct instanceSecondaryColor3uiEXT));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding SecondaryColor3uiEXT to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeSecondaryColor3uiEXT;
	instance->red = red;
	instance->green = green;
	instance->blue = blue;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** SecondaryColor3uivEXT ***/
static void DLM_APIENTRY passSecondaryColor3uivEXT(const GLuint * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.SecondaryColor3uivEXT(v);
}
static void DLM_APIENTRY executeSecondaryColor3uivEXT(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceSecondaryColor3uivEXT *instance = (struct instanceSecondaryColor3uivEXT *)x;
	dispatchTable->SecondaryColor3uivEXT(instance->v);
}
void DLM_APIENTRY crdlm_compile_SecondaryColor3uivEXT( const GLuint * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceSecondaryColor3uivEXT *instance;
	instance = crCalloc(sizeof(struct instanceSecondaryColor3uivEXT));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding SecondaryColor3uivEXT to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeSecondaryColor3uivEXT;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLuint));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** SecondaryColor3usEXT ***/
static void DLM_APIENTRY passSecondaryColor3usEXT(GLushort red, GLushort green, GLushort blue)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.SecondaryColor3usEXT(red, green, blue);
}
static void DLM_APIENTRY executeSecondaryColor3usEXT(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceSecondaryColor3usEXT *instance = (struct instanceSecondaryColor3usEXT *)x;
	dispatchTable->SecondaryColor3usEXT(instance->red, instance->green, instance->blue);
}
void DLM_APIENTRY crdlm_compile_SecondaryColor3usEXT( GLushort red, GLushort green, GLushort blue )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceSecondaryColor3usEXT *instance;
	instance = crCalloc(sizeof(struct instanceSecondaryColor3usEXT));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding SecondaryColor3usEXT to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeSecondaryColor3usEXT;
	instance->red = red;
	instance->green = green;
	instance->blue = blue;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** SecondaryColor3usvEXT ***/
static void DLM_APIENTRY passSecondaryColor3usvEXT(const GLushort * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.SecondaryColor3usvEXT(v);
}
static void DLM_APIENTRY executeSecondaryColor3usvEXT(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceSecondaryColor3usvEXT *instance = (struct instanceSecondaryColor3usvEXT *)x;
	dispatchTable->SecondaryColor3usvEXT(instance->v);
}
void DLM_APIENTRY crdlm_compile_SecondaryColor3usvEXT( const GLushort * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceSecondaryColor3usvEXT *instance;
	instance = crCalloc(sizeof(struct instanceSecondaryColor3usvEXT));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding SecondaryColor3usvEXT to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeSecondaryColor3usvEXT;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLushort));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** SecondaryColorPointerEXT ***/
static void DLM_APIENTRY passSecondaryColorPointerEXT(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer)
{
	CRDLMContextState *state = CURRENT_STATE();
	crdlmSecondaryColorPointerEXT(size, type, stride, pointer, state->clientState);
	state->savedDispatchTable.SecondaryColorPointerEXT(size, type, stride, pointer);
}

/*** SelectBuffer ***/
static void DLM_APIENTRY passSelectBuffer(GLsizei size, GLuint * buffer)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.SelectBuffer(size, buffer);
}

/*** SemaphoreCreateCR ***/
static void DLM_APIENTRY passSemaphoreCreateCR(GLuint name, GLuint count)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.SemaphoreCreateCR(name, count);
}

/*** SemaphoreDestroyCR ***/
static void DLM_APIENTRY passSemaphoreDestroyCR(GLuint name)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.SemaphoreDestroyCR(name);
}

/*** SemaphorePCR ***/
static void DLM_APIENTRY passSemaphorePCR(GLuint name)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.SemaphorePCR(name);
}

/*** SemaphoreVCR ***/
static void DLM_APIENTRY passSemaphoreVCR(GLuint name)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.SemaphoreVCR(name);
}

/*** SetFenceNV ***/
static void DLM_APIENTRY passSetFenceNV(GLuint fence, GLenum condition)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.SetFenceNV(fence, condition);
}
static void DLM_APIENTRY executeSetFenceNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceSetFenceNV *instance = (struct instanceSetFenceNV *)x;
	dispatchTable->SetFenceNV(instance->fence, instance->condition);
}
void DLM_APIENTRY crdlm_compile_SetFenceNV( GLuint fence, GLenum condition )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceSetFenceNV *instance;
	instance = crCalloc(sizeof(struct instanceSetFenceNV));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding SetFenceNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeSetFenceNV;
	instance->fence = fence;
	instance->condition = condition;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** ShadeModel ***/
static void DLM_APIENTRY passShadeModel(GLenum mode)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ShadeModel(mode);
}
static void DLM_APIENTRY executeShadeModel(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceShadeModel *instance = (struct instanceShadeModel *)x;
	dispatchTable->ShadeModel(instance->mode);
}
void DLM_APIENTRY crdlm_compile_ShadeModel( GLenum mode )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceShadeModel *instance;
	instance = crCalloc(sizeof(struct instanceShadeModel));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding ShadeModel to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeShadeModel;
	instance->mode = mode;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** StencilFunc ***/
static void DLM_APIENTRY passStencilFunc(GLenum func, GLint ref, GLuint mask)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.StencilFunc(func, ref, mask);
}
static void DLM_APIENTRY executeStencilFunc(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceStencilFunc *instance = (struct instanceStencilFunc *)x;
	dispatchTable->StencilFunc(instance->func, instance->ref, instance->mask);
}
void DLM_APIENTRY crdlm_compile_StencilFunc( GLenum func, GLint ref, GLuint mask )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceStencilFunc *instance;
	instance = crCalloc(sizeof(struct instanceStencilFunc));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding StencilFunc to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeStencilFunc;
	instance->func = func;
	instance->ref = ref;
	instance->mask = mask;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** StencilMask ***/
static void DLM_APIENTRY passStencilMask(GLuint mask)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.StencilMask(mask);
}
static void DLM_APIENTRY executeStencilMask(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceStencilMask *instance = (struct instanceStencilMask *)x;
	dispatchTable->StencilMask(instance->mask);
}
void DLM_APIENTRY crdlm_compile_StencilMask( GLuint mask )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceStencilMask *instance;
	instance = crCalloc(sizeof(struct instanceStencilMask));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding StencilMask to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeStencilMask;
	instance->mask = mask;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** StencilOp ***/
static void DLM_APIENTRY passStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.StencilOp(fail, zfail, zpass);
}
static void DLM_APIENTRY executeStencilOp(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceStencilOp *instance = (struct instanceStencilOp *)x;
	dispatchTable->StencilOp(instance->fail, instance->zfail, instance->zpass);
}
void DLM_APIENTRY crdlm_compile_StencilOp( GLenum fail, GLenum zfail, GLenum zpass )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceStencilOp *instance;
	instance = crCalloc(sizeof(struct instanceStencilOp));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding StencilOp to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeStencilOp;
	instance->fail = fail;
	instance->zfail = zfail;
	instance->zpass = zpass;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** SwapBuffers ***/
static void DLM_APIENTRY passSwapBuffers(GLint window, GLint flags)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.SwapBuffers(window, flags);
}

/*** TestFenceNV ***/
static GLboolean DLM_APIENTRY passTestFenceNV(GLuint fence)
{
	CRDLMContextState *state = CURRENT_STATE();
	return state->savedDispatchTable.TestFenceNV(fence);
}

/*** TexCoord1d ***/
static void DLM_APIENTRY passTexCoord1d(GLdouble s)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexCoord1d(s);
}
static void DLM_APIENTRY executeTexCoord1d(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexCoord1d *instance = (struct instanceTexCoord1d *)x;
	dispatchTable->TexCoord1d(instance->s);
}
void DLM_APIENTRY crdlm_compile_TexCoord1d( GLdouble s )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexCoord1d *instance;
	instance = crCalloc(sizeof(struct instanceTexCoord1d));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexCoord1d to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexCoord1d;
	instance->s = s;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexCoord1dv ***/
static void DLM_APIENTRY passTexCoord1dv(const GLdouble * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexCoord1dv(v);
}
static void DLM_APIENTRY executeTexCoord1dv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexCoord1dv *instance = (struct instanceTexCoord1dv *)x;
	dispatchTable->TexCoord1dv(instance->v);
}
void DLM_APIENTRY crdlm_compile_TexCoord1dv( const GLdouble * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexCoord1dv *instance;
	instance = crCalloc(sizeof(struct instanceTexCoord1dv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexCoord1dv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexCoord1dv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 1*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexCoord1f ***/
static void DLM_APIENTRY passTexCoord1f(GLfloat s)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexCoord1f(s);
}
static void DLM_APIENTRY executeTexCoord1f(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexCoord1f *instance = (struct instanceTexCoord1f *)x;
	dispatchTable->TexCoord1f(instance->s);
}
void DLM_APIENTRY crdlm_compile_TexCoord1f( GLfloat s )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexCoord1f *instance;
	instance = crCalloc(sizeof(struct instanceTexCoord1f));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexCoord1f to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexCoord1f;
	instance->s = s;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexCoord1fv ***/
static void DLM_APIENTRY passTexCoord1fv(const GLfloat * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexCoord1fv(v);
}
static void DLM_APIENTRY executeTexCoord1fv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexCoord1fv *instance = (struct instanceTexCoord1fv *)x;
	dispatchTable->TexCoord1fv(instance->v);
}
void DLM_APIENTRY crdlm_compile_TexCoord1fv( const GLfloat * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexCoord1fv *instance;
	instance = crCalloc(sizeof(struct instanceTexCoord1fv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexCoord1fv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexCoord1fv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 1*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexCoord1i ***/
static void DLM_APIENTRY passTexCoord1i(GLint s)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexCoord1i(s);
}
static void DLM_APIENTRY executeTexCoord1i(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexCoord1i *instance = (struct instanceTexCoord1i *)x;
	dispatchTable->TexCoord1i(instance->s);
}
void DLM_APIENTRY crdlm_compile_TexCoord1i( GLint s )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexCoord1i *instance;
	instance = crCalloc(sizeof(struct instanceTexCoord1i));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexCoord1i to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexCoord1i;
	instance->s = s;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexCoord1iv ***/
static void DLM_APIENTRY passTexCoord1iv(const GLint * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexCoord1iv(v);
}
static void DLM_APIENTRY executeTexCoord1iv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexCoord1iv *instance = (struct instanceTexCoord1iv *)x;
	dispatchTable->TexCoord1iv(instance->v);
}
void DLM_APIENTRY crdlm_compile_TexCoord1iv( const GLint * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexCoord1iv *instance;
	instance = crCalloc(sizeof(struct instanceTexCoord1iv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexCoord1iv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexCoord1iv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 1*sizeof(GLint));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexCoord1s ***/
static void DLM_APIENTRY passTexCoord1s(GLshort s)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexCoord1s(s);
}
static void DLM_APIENTRY executeTexCoord1s(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexCoord1s *instance = (struct instanceTexCoord1s *)x;
	dispatchTable->TexCoord1s(instance->s);
}
void DLM_APIENTRY crdlm_compile_TexCoord1s( GLshort s )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexCoord1s *instance;
	instance = crCalloc(sizeof(struct instanceTexCoord1s));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexCoord1s to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexCoord1s;
	instance->s = s;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexCoord1sv ***/
static void DLM_APIENTRY passTexCoord1sv(const GLshort * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexCoord1sv(v);
}
static void DLM_APIENTRY executeTexCoord1sv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexCoord1sv *instance = (struct instanceTexCoord1sv *)x;
	dispatchTable->TexCoord1sv(instance->v);
}
void DLM_APIENTRY crdlm_compile_TexCoord1sv( const GLshort * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexCoord1sv *instance;
	instance = crCalloc(sizeof(struct instanceTexCoord1sv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexCoord1sv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexCoord1sv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 1*sizeof(GLshort));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexCoord2d ***/
static void DLM_APIENTRY passTexCoord2d(GLdouble s, GLdouble t)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexCoord2d(s, t);
}
static void DLM_APIENTRY executeTexCoord2d(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexCoord2d *instance = (struct instanceTexCoord2d *)x;
	dispatchTable->TexCoord2d(instance->s, instance->t);
}
void DLM_APIENTRY crdlm_compile_TexCoord2d( GLdouble s, GLdouble t )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexCoord2d *instance;
	instance = crCalloc(sizeof(struct instanceTexCoord2d));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexCoord2d to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexCoord2d;
	instance->s = s;
	instance->t = t;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexCoord2dv ***/
static void DLM_APIENTRY passTexCoord2dv(const GLdouble * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexCoord2dv(v);
}
static void DLM_APIENTRY executeTexCoord2dv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexCoord2dv *instance = (struct instanceTexCoord2dv *)x;
	dispatchTable->TexCoord2dv(instance->v);
}
void DLM_APIENTRY crdlm_compile_TexCoord2dv( const GLdouble * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexCoord2dv *instance;
	instance = crCalloc(sizeof(struct instanceTexCoord2dv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexCoord2dv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexCoord2dv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 2*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexCoord2f ***/
static void DLM_APIENTRY passTexCoord2f(GLfloat s, GLfloat t)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexCoord2f(s, t);
}
static void DLM_APIENTRY executeTexCoord2f(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexCoord2f *instance = (struct instanceTexCoord2f *)x;
	dispatchTable->TexCoord2f(instance->s, instance->t);
}
void DLM_APIENTRY crdlm_compile_TexCoord2f( GLfloat s, GLfloat t )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexCoord2f *instance;
	instance = crCalloc(sizeof(struct instanceTexCoord2f));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexCoord2f to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexCoord2f;
	instance->s = s;
	instance->t = t;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexCoord2fv ***/
static void DLM_APIENTRY passTexCoord2fv(const GLfloat * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexCoord2fv(v);
}
static void DLM_APIENTRY executeTexCoord2fv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexCoord2fv *instance = (struct instanceTexCoord2fv *)x;
	dispatchTable->TexCoord2fv(instance->v);
}
void DLM_APIENTRY crdlm_compile_TexCoord2fv( const GLfloat * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexCoord2fv *instance;
	instance = crCalloc(sizeof(struct instanceTexCoord2fv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexCoord2fv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexCoord2fv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 2*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexCoord2i ***/
static void DLM_APIENTRY passTexCoord2i(GLint s, GLint t)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexCoord2i(s, t);
}
static void DLM_APIENTRY executeTexCoord2i(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexCoord2i *instance = (struct instanceTexCoord2i *)x;
	dispatchTable->TexCoord2i(instance->s, instance->t);
}
void DLM_APIENTRY crdlm_compile_TexCoord2i( GLint s, GLint t )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexCoord2i *instance;
	instance = crCalloc(sizeof(struct instanceTexCoord2i));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexCoord2i to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexCoord2i;
	instance->s = s;
	instance->t = t;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexCoord2iv ***/
static void DLM_APIENTRY passTexCoord2iv(const GLint * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexCoord2iv(v);
}
static void DLM_APIENTRY executeTexCoord2iv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexCoord2iv *instance = (struct instanceTexCoord2iv *)x;
	dispatchTable->TexCoord2iv(instance->v);
}
void DLM_APIENTRY crdlm_compile_TexCoord2iv( const GLint * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexCoord2iv *instance;
	instance = crCalloc(sizeof(struct instanceTexCoord2iv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexCoord2iv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexCoord2iv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 2*sizeof(GLint));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexCoord2s ***/
static void DLM_APIENTRY passTexCoord2s(GLshort s, GLshort t)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexCoord2s(s, t);
}
static void DLM_APIENTRY executeTexCoord2s(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexCoord2s *instance = (struct instanceTexCoord2s *)x;
	dispatchTable->TexCoord2s(instance->s, instance->t);
}
void DLM_APIENTRY crdlm_compile_TexCoord2s( GLshort s, GLshort t )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexCoord2s *instance;
	instance = crCalloc(sizeof(struct instanceTexCoord2s));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexCoord2s to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexCoord2s;
	instance->s = s;
	instance->t = t;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexCoord2sv ***/
static void DLM_APIENTRY passTexCoord2sv(const GLshort * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexCoord2sv(v);
}
static void DLM_APIENTRY executeTexCoord2sv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexCoord2sv *instance = (struct instanceTexCoord2sv *)x;
	dispatchTable->TexCoord2sv(instance->v);
}
void DLM_APIENTRY crdlm_compile_TexCoord2sv( const GLshort * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexCoord2sv *instance;
	instance = crCalloc(sizeof(struct instanceTexCoord2sv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexCoord2sv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexCoord2sv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 2*sizeof(GLshort));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexCoord3d ***/
static void DLM_APIENTRY passTexCoord3d(GLdouble s, GLdouble t, GLdouble r)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexCoord3d(s, t, r);
}
static void DLM_APIENTRY executeTexCoord3d(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexCoord3d *instance = (struct instanceTexCoord3d *)x;
	dispatchTable->TexCoord3d(instance->s, instance->t, instance->r);
}
void DLM_APIENTRY crdlm_compile_TexCoord3d( GLdouble s, GLdouble t, GLdouble r )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexCoord3d *instance;
	instance = crCalloc(sizeof(struct instanceTexCoord3d));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexCoord3d to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexCoord3d;
	instance->s = s;
	instance->t = t;
	instance->r = r;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexCoord3dv ***/
static void DLM_APIENTRY passTexCoord3dv(const GLdouble * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexCoord3dv(v);
}
static void DLM_APIENTRY executeTexCoord3dv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexCoord3dv *instance = (struct instanceTexCoord3dv *)x;
	dispatchTable->TexCoord3dv(instance->v);
}
void DLM_APIENTRY crdlm_compile_TexCoord3dv( const GLdouble * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexCoord3dv *instance;
	instance = crCalloc(sizeof(struct instanceTexCoord3dv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexCoord3dv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexCoord3dv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexCoord3f ***/
static void DLM_APIENTRY passTexCoord3f(GLfloat s, GLfloat t, GLfloat r)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexCoord3f(s, t, r);
}
static void DLM_APIENTRY executeTexCoord3f(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexCoord3f *instance = (struct instanceTexCoord3f *)x;
	dispatchTable->TexCoord3f(instance->s, instance->t, instance->r);
}
void DLM_APIENTRY crdlm_compile_TexCoord3f( GLfloat s, GLfloat t, GLfloat r )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexCoord3f *instance;
	instance = crCalloc(sizeof(struct instanceTexCoord3f));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexCoord3f to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexCoord3f;
	instance->s = s;
	instance->t = t;
	instance->r = r;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexCoord3fv ***/
static void DLM_APIENTRY passTexCoord3fv(const GLfloat * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexCoord3fv(v);
}
static void DLM_APIENTRY executeTexCoord3fv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexCoord3fv *instance = (struct instanceTexCoord3fv *)x;
	dispatchTable->TexCoord3fv(instance->v);
}
void DLM_APIENTRY crdlm_compile_TexCoord3fv( const GLfloat * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexCoord3fv *instance;
	instance = crCalloc(sizeof(struct instanceTexCoord3fv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexCoord3fv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexCoord3fv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexCoord3i ***/
static void DLM_APIENTRY passTexCoord3i(GLint s, GLint t, GLint r)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexCoord3i(s, t, r);
}
static void DLM_APIENTRY executeTexCoord3i(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexCoord3i *instance = (struct instanceTexCoord3i *)x;
	dispatchTable->TexCoord3i(instance->s, instance->t, instance->r);
}
void DLM_APIENTRY crdlm_compile_TexCoord3i( GLint s, GLint t, GLint r )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexCoord3i *instance;
	instance = crCalloc(sizeof(struct instanceTexCoord3i));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexCoord3i to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexCoord3i;
	instance->s = s;
	instance->t = t;
	instance->r = r;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexCoord3iv ***/
static void DLM_APIENTRY passTexCoord3iv(const GLint * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexCoord3iv(v);
}
static void DLM_APIENTRY executeTexCoord3iv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexCoord3iv *instance = (struct instanceTexCoord3iv *)x;
	dispatchTable->TexCoord3iv(instance->v);
}
void DLM_APIENTRY crdlm_compile_TexCoord3iv( const GLint * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexCoord3iv *instance;
	instance = crCalloc(sizeof(struct instanceTexCoord3iv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexCoord3iv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexCoord3iv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLint));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexCoord3s ***/
static void DLM_APIENTRY passTexCoord3s(GLshort s, GLshort t, GLshort r)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexCoord3s(s, t, r);
}
static void DLM_APIENTRY executeTexCoord3s(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexCoord3s *instance = (struct instanceTexCoord3s *)x;
	dispatchTable->TexCoord3s(instance->s, instance->t, instance->r);
}
void DLM_APIENTRY crdlm_compile_TexCoord3s( GLshort s, GLshort t, GLshort r )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexCoord3s *instance;
	instance = crCalloc(sizeof(struct instanceTexCoord3s));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexCoord3s to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexCoord3s;
	instance->s = s;
	instance->t = t;
	instance->r = r;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexCoord3sv ***/
static void DLM_APIENTRY passTexCoord3sv(const GLshort * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexCoord3sv(v);
}
static void DLM_APIENTRY executeTexCoord3sv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexCoord3sv *instance = (struct instanceTexCoord3sv *)x;
	dispatchTable->TexCoord3sv(instance->v);
}
void DLM_APIENTRY crdlm_compile_TexCoord3sv( const GLshort * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexCoord3sv *instance;
	instance = crCalloc(sizeof(struct instanceTexCoord3sv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexCoord3sv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexCoord3sv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLshort));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexCoord4d ***/
static void DLM_APIENTRY passTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexCoord4d(s, t, r, q);
}
static void DLM_APIENTRY executeTexCoord4d(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexCoord4d *instance = (struct instanceTexCoord4d *)x;
	dispatchTable->TexCoord4d(instance->s, instance->t, instance->r, instance->q);
}
void DLM_APIENTRY crdlm_compile_TexCoord4d( GLdouble s, GLdouble t, GLdouble r, GLdouble q )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexCoord4d *instance;
	instance = crCalloc(sizeof(struct instanceTexCoord4d));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexCoord4d to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexCoord4d;
	instance->s = s;
	instance->t = t;
	instance->r = r;
	instance->q = q;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexCoord4dv ***/
static void DLM_APIENTRY passTexCoord4dv(const GLdouble * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexCoord4dv(v);
}
static void DLM_APIENTRY executeTexCoord4dv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexCoord4dv *instance = (struct instanceTexCoord4dv *)x;
	dispatchTable->TexCoord4dv(instance->v);
}
void DLM_APIENTRY crdlm_compile_TexCoord4dv( const GLdouble * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexCoord4dv *instance;
	instance = crCalloc(sizeof(struct instanceTexCoord4dv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexCoord4dv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexCoord4dv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 4*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexCoord4f ***/
static void DLM_APIENTRY passTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexCoord4f(s, t, r, q);
}
static void DLM_APIENTRY executeTexCoord4f(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexCoord4f *instance = (struct instanceTexCoord4f *)x;
	dispatchTable->TexCoord4f(instance->s, instance->t, instance->r, instance->q);
}
void DLM_APIENTRY crdlm_compile_TexCoord4f( GLfloat s, GLfloat t, GLfloat r, GLfloat q )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexCoord4f *instance;
	instance = crCalloc(sizeof(struct instanceTexCoord4f));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexCoord4f to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexCoord4f;
	instance->s = s;
	instance->t = t;
	instance->r = r;
	instance->q = q;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexCoord4fv ***/
static void DLM_APIENTRY passTexCoord4fv(const GLfloat * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexCoord4fv(v);
}
static void DLM_APIENTRY executeTexCoord4fv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexCoord4fv *instance = (struct instanceTexCoord4fv *)x;
	dispatchTable->TexCoord4fv(instance->v);
}
void DLM_APIENTRY crdlm_compile_TexCoord4fv( const GLfloat * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexCoord4fv *instance;
	instance = crCalloc(sizeof(struct instanceTexCoord4fv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexCoord4fv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexCoord4fv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 4*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexCoord4i ***/
static void DLM_APIENTRY passTexCoord4i(GLint s, GLint t, GLint r, GLint q)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexCoord4i(s, t, r, q);
}
static void DLM_APIENTRY executeTexCoord4i(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexCoord4i *instance = (struct instanceTexCoord4i *)x;
	dispatchTable->TexCoord4i(instance->s, instance->t, instance->r, instance->q);
}
void DLM_APIENTRY crdlm_compile_TexCoord4i( GLint s, GLint t, GLint r, GLint q )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexCoord4i *instance;
	instance = crCalloc(sizeof(struct instanceTexCoord4i));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexCoord4i to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexCoord4i;
	instance->s = s;
	instance->t = t;
	instance->r = r;
	instance->q = q;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexCoord4iv ***/
static void DLM_APIENTRY passTexCoord4iv(const GLint * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexCoord4iv(v);
}
static void DLM_APIENTRY executeTexCoord4iv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexCoord4iv *instance = (struct instanceTexCoord4iv *)x;
	dispatchTable->TexCoord4iv(instance->v);
}
void DLM_APIENTRY crdlm_compile_TexCoord4iv( const GLint * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexCoord4iv *instance;
	instance = crCalloc(sizeof(struct instanceTexCoord4iv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexCoord4iv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexCoord4iv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 4*sizeof(GLint));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexCoord4s ***/
static void DLM_APIENTRY passTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexCoord4s(s, t, r, q);
}
static void DLM_APIENTRY executeTexCoord4s(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexCoord4s *instance = (struct instanceTexCoord4s *)x;
	dispatchTable->TexCoord4s(instance->s, instance->t, instance->r, instance->q);
}
void DLM_APIENTRY crdlm_compile_TexCoord4s( GLshort s, GLshort t, GLshort r, GLshort q )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexCoord4s *instance;
	instance = crCalloc(sizeof(struct instanceTexCoord4s));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexCoord4s to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexCoord4s;
	instance->s = s;
	instance->t = t;
	instance->r = r;
	instance->q = q;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexCoord4sv ***/
static void DLM_APIENTRY passTexCoord4sv(const GLshort * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexCoord4sv(v);
}
static void DLM_APIENTRY executeTexCoord4sv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexCoord4sv *instance = (struct instanceTexCoord4sv *)x;
	dispatchTable->TexCoord4sv(instance->v);
}
void DLM_APIENTRY crdlm_compile_TexCoord4sv( const GLshort * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexCoord4sv *instance;
	instance = crCalloc(sizeof(struct instanceTexCoord4sv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexCoord4sv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexCoord4sv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 4*sizeof(GLshort));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexCoordPointer ***/
static void DLM_APIENTRY passTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer)
{
	CRDLMContextState *state = CURRENT_STATE();
	crdlmTexCoordPointer(size, type, stride, pointer, state->clientState);
	state->savedDispatchTable.TexCoordPointer(size, type, stride, pointer);
}

/*** TexEnvf ***/
static void DLM_APIENTRY passTexEnvf(GLenum target, GLenum pname, GLfloat param)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexEnvf(target, pname, param);
}
static void DLM_APIENTRY executeTexEnvf(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexEnvf *instance = (struct instanceTexEnvf *)x;
	dispatchTable->TexEnvf(instance->target, instance->pname, instance->param);
}
void DLM_APIENTRY crdlm_compile_TexEnvf( GLenum target, GLenum pname, GLfloat param )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexEnvf *instance;
	instance = crCalloc(sizeof(struct instanceTexEnvf));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexEnvf to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexEnvf;
	instance->target = target;
	instance->pname = pname;
	instance->param = param;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexEnvfv ***/
static void DLM_APIENTRY passTexEnvfv(GLenum target, GLenum pname, const GLfloat * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexEnvfv(target, pname, params);
}
static void DLM_APIENTRY executeTexEnvfv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexEnvfv *instance = (struct instanceTexEnvfv *)x;
	dispatchTable->TexEnvfv(instance->target, instance->pname, instance->params);
}
void DLM_APIENTRY crdlm_compile_TexEnvfv( GLenum target, GLenum pname, const GLfloat * params )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexEnvfv *instance;
	instance = crCalloc(sizeof(struct instanceTexEnvfv) + crdlm_pointers_TexEnvfv(NULL, target, pname, params));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexEnvfv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexEnvfv;
	instance->target = target;
	instance->pname = pname;
	if (params == NULL) {
		instance->params = NULL;
	}
	else {
		instance->params = instance->paramsData;
	}
	(void) crdlm_pointers_TexEnvfv(instance, target, pname, params);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexEnvi ***/
static void DLM_APIENTRY passTexEnvi(GLenum target, GLenum pname, GLint param)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexEnvi(target, pname, param);
}
static void DLM_APIENTRY executeTexEnvi(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexEnvi *instance = (struct instanceTexEnvi *)x;
	dispatchTable->TexEnvi(instance->target, instance->pname, instance->param);
}
void DLM_APIENTRY crdlm_compile_TexEnvi( GLenum target, GLenum pname, GLint param )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexEnvi *instance;
	instance = crCalloc(sizeof(struct instanceTexEnvi));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexEnvi to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexEnvi;
	instance->target = target;
	instance->pname = pname;
	instance->param = param;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexEnviv ***/
static void DLM_APIENTRY passTexEnviv(GLenum target, GLenum pname, const GLint * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexEnviv(target, pname, params);
}
static void DLM_APIENTRY executeTexEnviv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexEnviv *instance = (struct instanceTexEnviv *)x;
	dispatchTable->TexEnviv(instance->target, instance->pname, instance->params);
}
void DLM_APIENTRY crdlm_compile_TexEnviv( GLenum target, GLenum pname, const GLint * params )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexEnviv *instance;
	instance = crCalloc(sizeof(struct instanceTexEnviv) + crdlm_pointers_TexEnviv(NULL, target, pname, params));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexEnviv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexEnviv;
	instance->target = target;
	instance->pname = pname;
	if (params == NULL) {
		instance->params = NULL;
	}
	else {
		instance->params = instance->paramsData;
	}
	(void) crdlm_pointers_TexEnviv(instance, target, pname, params);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexGend ***/
static void DLM_APIENTRY passTexGend(GLenum coord, GLenum pname, GLdouble param)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexGend(coord, pname, param);
}
static void DLM_APIENTRY executeTexGend(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexGend *instance = (struct instanceTexGend *)x;
	dispatchTable->TexGend(instance->coord, instance->pname, instance->param);
}
void DLM_APIENTRY crdlm_compile_TexGend( GLenum coord, GLenum pname, GLdouble param )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexGend *instance;
	instance = crCalloc(sizeof(struct instanceTexGend));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexGend to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexGend;
	instance->coord = coord;
	instance->pname = pname;
	instance->param = param;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexGendv ***/
static void DLM_APIENTRY passTexGendv(GLenum coord, GLenum pname, const GLdouble * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexGendv(coord, pname, params);
}
static void DLM_APIENTRY executeTexGendv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexGendv *instance = (struct instanceTexGendv *)x;
	dispatchTable->TexGendv(instance->coord, instance->pname, instance->params);
}
void DLM_APIENTRY crdlm_compile_TexGendv( GLenum coord, GLenum pname, const GLdouble * params )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexGendv *instance;
	instance = crCalloc(sizeof(struct instanceTexGendv) + crdlm_pointers_TexGendv(NULL, coord, pname, params));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexGendv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexGendv;
	instance->coord = coord;
	instance->pname = pname;
	if (params == NULL) {
		instance->params = NULL;
	}
	else {
		instance->params = instance->paramsData;
	}
	(void) crdlm_pointers_TexGendv(instance, coord, pname, params);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexGenf ***/
static void DLM_APIENTRY passTexGenf(GLenum coord, GLenum pname, GLfloat param)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexGenf(coord, pname, param);
}
static void DLM_APIENTRY executeTexGenf(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexGenf *instance = (struct instanceTexGenf *)x;
	dispatchTable->TexGenf(instance->coord, instance->pname, instance->param);
}
void DLM_APIENTRY crdlm_compile_TexGenf( GLenum coord, GLenum pname, GLfloat param )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexGenf *instance;
	instance = crCalloc(sizeof(struct instanceTexGenf));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexGenf to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexGenf;
	instance->coord = coord;
	instance->pname = pname;
	instance->param = param;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexGenfv ***/
static void DLM_APIENTRY passTexGenfv(GLenum coord, GLenum pname, const GLfloat * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexGenfv(coord, pname, params);
}
static void DLM_APIENTRY executeTexGenfv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexGenfv *instance = (struct instanceTexGenfv *)x;
	dispatchTable->TexGenfv(instance->coord, instance->pname, instance->params);
}
void DLM_APIENTRY crdlm_compile_TexGenfv( GLenum coord, GLenum pname, const GLfloat * params )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexGenfv *instance;
	instance = crCalloc(sizeof(struct instanceTexGenfv) + crdlm_pointers_TexGenfv(NULL, coord, pname, params));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexGenfv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexGenfv;
	instance->coord = coord;
	instance->pname = pname;
	if (params == NULL) {
		instance->params = NULL;
	}
	else {
		instance->params = instance->paramsData;
	}
	(void) crdlm_pointers_TexGenfv(instance, coord, pname, params);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexGeni ***/
static void DLM_APIENTRY passTexGeni(GLenum coord, GLenum pname, GLint param)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexGeni(coord, pname, param);
}
static void DLM_APIENTRY executeTexGeni(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexGeni *instance = (struct instanceTexGeni *)x;
	dispatchTable->TexGeni(instance->coord, instance->pname, instance->param);
}
void DLM_APIENTRY crdlm_compile_TexGeni( GLenum coord, GLenum pname, GLint param )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexGeni *instance;
	instance = crCalloc(sizeof(struct instanceTexGeni));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexGeni to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexGeni;
	instance->coord = coord;
	instance->pname = pname;
	instance->param = param;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexGeniv ***/
static void DLM_APIENTRY passTexGeniv(GLenum coord, GLenum pname, const GLint * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexGeniv(coord, pname, params);
}
static void DLM_APIENTRY executeTexGeniv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexGeniv *instance = (struct instanceTexGeniv *)x;
	dispatchTable->TexGeniv(instance->coord, instance->pname, instance->params);
}
void DLM_APIENTRY crdlm_compile_TexGeniv( GLenum coord, GLenum pname, const GLint * params )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexGeniv *instance;
	instance = crCalloc(sizeof(struct instanceTexGeniv) + crdlm_pointers_TexGeniv(NULL, coord, pname, params));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexGeniv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexGeniv;
	instance->coord = coord;
	instance->pname = pname;
	if (params == NULL) {
		instance->params = NULL;
	}
	else {
		instance->params = instance->paramsData;
	}
	(void) crdlm_pointers_TexGeniv(instance, coord, pname, params);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexImage1D ***/
static void DLM_APIENTRY passTexImage1D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid * pixels)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexImage1D(target, level, internalFormat, width, border, format, type, pixels);
}
static void DLM_APIENTRY executeTexImage1D(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexImage1D *instance = (struct instanceTexImage1D *)x;
	dispatchTable->TexImage1D(instance->target, instance->level, instance->internalFormat, instance->width, instance->border, instance->format, instance->type, instance->pixels);
}
void DLM_APIENTRY crdlm_compile_TexImage1D( GLenum target, GLint level, GLint internalFormat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid * pixels )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexImage1D *instance;
	if (crdlm_checkpass_TexImage1D(target, level, internalFormat, width, border, format, type, pixels)) {
		passTexImage1D(target, level, internalFormat, width, border, format, type, pixels);
		return;
	}
	instance = crCalloc(sizeof(struct instanceTexImage1D) + crdlm_pointers_TexImage1D(NULL, target, level, internalFormat, width, border, format, type, pixels));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexImage1D to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexImage1D;
	instance->target = target;
	instance->level = level;
	instance->internalFormat = internalFormat;
	instance->width = width;
	instance->border = border;
	instance->format = format;
	instance->type = type;
	if (pixels == NULL) {
		instance->pixels = NULL;
	}
	else {
		instance->pixels = instance->pixelsData;
	}
	(void) crdlm_pointers_TexImage1D(instance, target, level, internalFormat, width, border, format, type, pixels);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexImage2D ***/
static void DLM_APIENTRY passTexImage2D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid * pixels)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexImage2D(target, level, internalFormat, width, height, border, format, type, pixels);
}
static void DLM_APIENTRY executeTexImage2D(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexImage2D *instance = (struct instanceTexImage2D *)x;
	dispatchTable->TexImage2D(instance->target, instance->level, instance->internalFormat, instance->width, instance->height, instance->border, instance->format, instance->type, instance->pixels);
}
void DLM_APIENTRY crdlm_compile_TexImage2D( GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid * pixels )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexImage2D *instance;
	if (crdlm_checkpass_TexImage2D(target, level, internalFormat, width, height, border, format, type, pixels)) {
		passTexImage2D(target, level, internalFormat, width, height, border, format, type, pixels);
		return;
	}
	instance = crCalloc(sizeof(struct instanceTexImage2D) + crdlm_pointers_TexImage2D(NULL, target, level, internalFormat, width, height, border, format, type, pixels));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexImage2D to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexImage2D;
	instance->target = target;
	instance->level = level;
	instance->internalFormat = internalFormat;
	instance->width = width;
	instance->height = height;
	instance->border = border;
	instance->format = format;
	instance->type = type;
	if (pixels == NULL) {
		instance->pixels = NULL;
	}
	else {
		instance->pixels = instance->pixelsData;
	}
	(void) crdlm_pointers_TexImage2D(instance, target, level, internalFormat, width, height, border, format, type, pixels);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexImage3D ***/
static void DLM_APIENTRY passTexImage3D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexImage3D(target, level, internalFormat, width, height, depth, border, format, type, pixels);
}
static void DLM_APIENTRY executeTexImage3D(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexImage3D *instance = (struct instanceTexImage3D *)x;
	dispatchTable->TexImage3D(instance->target, instance->level, instance->internalFormat, instance->width, instance->height, instance->depth, instance->border, instance->format, instance->type, instance->pixels);
}
void DLM_APIENTRY crdlm_compile_TexImage3D( GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexImage3D *instance;
	if (crdlm_checkpass_TexImage3D(target, level, internalFormat, width, height, depth, border, format, type, pixels)) {
		passTexImage3D(target, level, internalFormat, width, height, depth, border, format, type, pixels);
		return;
	}
	instance = crCalloc(sizeof(struct instanceTexImage3D) + crdlm_pointers_TexImage3D(NULL, target, level, internalFormat, width, height, depth, border, format, type, pixels));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexImage3D to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexImage3D;
	instance->target = target;
	instance->level = level;
	instance->internalFormat = internalFormat;
	instance->width = width;
	instance->height = height;
	instance->depth = depth;
	instance->border = border;
	instance->format = format;
	instance->type = type;
	if (pixels == NULL) {
		instance->pixels = NULL;
	}
	else {
		instance->pixels = instance->pixelsData;
	}
	(void) crdlm_pointers_TexImage3D(instance, target, level, internalFormat, width, height, depth, border, format, type, pixels);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexImage3DEXT ***/
static void DLM_APIENTRY passTexImage3DEXT(GLenum target, GLint level, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexImage3DEXT(target, level, internalFormat, width, height, depth, border, format, type, pixels);
}
static void DLM_APIENTRY executeTexImage3DEXT(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexImage3DEXT *instance = (struct instanceTexImage3DEXT *)x;
	dispatchTable->TexImage3DEXT(instance->target, instance->level, instance->internalFormat, instance->width, instance->height, instance->depth, instance->border, instance->format, instance->type, instance->pixels);
}
void DLM_APIENTRY crdlm_compile_TexImage3DEXT( GLenum target, GLint level, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexImage3DEXT *instance;
	if (crdlm_checkpass_TexImage3DEXT(target, level, internalFormat, width, height, depth, border, format, type, pixels)) {
		passTexImage3DEXT(target, level, internalFormat, width, height, depth, border, format, type, pixels);
		return;
	}
	instance = crCalloc(sizeof(struct instanceTexImage3DEXT) + crdlm_pointers_TexImage3DEXT(NULL, target, level, internalFormat, width, height, depth, border, format, type, pixels));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexImage3DEXT to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexImage3DEXT;
	instance->target = target;
	instance->level = level;
	instance->internalFormat = internalFormat;
	instance->width = width;
	instance->height = height;
	instance->depth = depth;
	instance->border = border;
	instance->format = format;
	instance->type = type;
	if (pixels == NULL) {
		instance->pixels = NULL;
	}
	else {
		instance->pixels = instance->pixelsData;
	}
	(void) crdlm_pointers_TexImage3DEXT(instance, target, level, internalFormat, width, height, depth, border, format, type, pixels);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexParameterf ***/
static void DLM_APIENTRY passTexParameterf(GLenum target, GLenum pname, GLfloat param)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexParameterf(target, pname, param);
}
static void DLM_APIENTRY executeTexParameterf(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexParameterf *instance = (struct instanceTexParameterf *)x;
	dispatchTable->TexParameterf(instance->target, instance->pname, instance->param);
}
void DLM_APIENTRY crdlm_compile_TexParameterf( GLenum target, GLenum pname, GLfloat param )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexParameterf *instance;
	instance = crCalloc(sizeof(struct instanceTexParameterf));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexParameterf to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexParameterf;
	instance->target = target;
	instance->pname = pname;
	instance->param = param;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexParameterfv ***/
static void DLM_APIENTRY passTexParameterfv(GLenum target, GLenum pname, const GLfloat * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexParameterfv(target, pname, params);
}
static void DLM_APIENTRY executeTexParameterfv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexParameterfv *instance = (struct instanceTexParameterfv *)x;
	dispatchTable->TexParameterfv(instance->target, instance->pname, instance->params);
}
void DLM_APIENTRY crdlm_compile_TexParameterfv( GLenum target, GLenum pname, const GLfloat * params )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexParameterfv *instance;
	instance = crCalloc(sizeof(struct instanceTexParameterfv) + crdlm_pointers_TexParameterfv(NULL, target, pname, params));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexParameterfv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexParameterfv;
	instance->target = target;
	instance->pname = pname;
	if (params == NULL) {
		instance->params = NULL;
	}
	else {
		instance->params = instance->paramsData;
	}
	(void) crdlm_pointers_TexParameterfv(instance, target, pname, params);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexParameteri ***/
static void DLM_APIENTRY passTexParameteri(GLenum target, GLenum pname, GLint param)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexParameteri(target, pname, param);
}
static void DLM_APIENTRY executeTexParameteri(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexParameteri *instance = (struct instanceTexParameteri *)x;
	dispatchTable->TexParameteri(instance->target, instance->pname, instance->param);
}
void DLM_APIENTRY crdlm_compile_TexParameteri( GLenum target, GLenum pname, GLint param )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexParameteri *instance;
	instance = crCalloc(sizeof(struct instanceTexParameteri));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexParameteri to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexParameteri;
	instance->target = target;
	instance->pname = pname;
	instance->param = param;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexParameteriv ***/
static void DLM_APIENTRY passTexParameteriv(GLenum target, GLenum pname, const GLint * params)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexParameteriv(target, pname, params);
}
static void DLM_APIENTRY executeTexParameteriv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexParameteriv *instance = (struct instanceTexParameteriv *)x;
	dispatchTable->TexParameteriv(instance->target, instance->pname, instance->params);
}
void DLM_APIENTRY crdlm_compile_TexParameteriv( GLenum target, GLenum pname, const GLint * params )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexParameteriv *instance;
	instance = crCalloc(sizeof(struct instanceTexParameteriv) + crdlm_pointers_TexParameteriv(NULL, target, pname, params));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexParameteriv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexParameteriv;
	instance->target = target;
	instance->pname = pname;
	if (params == NULL) {
		instance->params = NULL;
	}
	else {
		instance->params = instance->paramsData;
	}
	(void) crdlm_pointers_TexParameteriv(instance, target, pname, params);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexSubImage1D ***/
static void DLM_APIENTRY passTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * pixels)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexSubImage1D(target, level, xoffset, width, format, type, pixels);
}
static void DLM_APIENTRY executeTexSubImage1D(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexSubImage1D *instance = (struct instanceTexSubImage1D *)x;
	dispatchTable->TexSubImage1D(instance->target, instance->level, instance->xoffset, instance->width, instance->format, instance->type, instance->pixels);
}
void DLM_APIENTRY crdlm_compile_TexSubImage1D( GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * pixels )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexSubImage1D *instance;
	instance = crCalloc(sizeof(struct instanceTexSubImage1D) + crdlm_pointers_TexSubImage1D(NULL, target, level, xoffset, width, format, type, pixels));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexSubImage1D to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexSubImage1D;
	instance->target = target;
	instance->level = level;
	instance->xoffset = xoffset;
	instance->width = width;
	instance->format = format;
	instance->type = type;
	if (pixels == NULL) {
		instance->pixels = NULL;
	}
	else {
		instance->pixels = instance->pixelsData;
	}
	(void) crdlm_pointers_TexSubImage1D(instance, target, level, xoffset, width, format, type, pixels);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexSubImage2D ***/
static void DLM_APIENTRY passTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
}
static void DLM_APIENTRY executeTexSubImage2D(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexSubImage2D *instance = (struct instanceTexSubImage2D *)x;
	dispatchTable->TexSubImage2D(instance->target, instance->level, instance->xoffset, instance->yoffset, instance->width, instance->height, instance->format, instance->type, instance->pixels);
}
void DLM_APIENTRY crdlm_compile_TexSubImage2D( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexSubImage2D *instance;
	instance = crCalloc(sizeof(struct instanceTexSubImage2D) + crdlm_pointers_TexSubImage2D(NULL, target, level, xoffset, yoffset, width, height, format, type, pixels));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexSubImage2D to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexSubImage2D;
	instance->target = target;
	instance->level = level;
	instance->xoffset = xoffset;
	instance->yoffset = yoffset;
	instance->width = width;
	instance->height = height;
	instance->format = format;
	instance->type = type;
	if (pixels == NULL) {
		instance->pixels = NULL;
	}
	else {
		instance->pixels = instance->pixelsData;
	}
	(void) crdlm_pointers_TexSubImage2D(instance, target, level, xoffset, yoffset, width, height, format, type, pixels);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TexSubImage3D ***/
static void DLM_APIENTRY passTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}
static void DLM_APIENTRY executeTexSubImage3D(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTexSubImage3D *instance = (struct instanceTexSubImage3D *)x;
	dispatchTable->TexSubImage3D(instance->target, instance->level, instance->xoffset, instance->yoffset, instance->zoffset, instance->width, instance->height, instance->depth, instance->format, instance->type, instance->pixels);
}
void DLM_APIENTRY crdlm_compile_TexSubImage3D( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTexSubImage3D *instance;
	instance = crCalloc(sizeof(struct instanceTexSubImage3D) + crdlm_pointers_TexSubImage3D(NULL, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TexSubImage3D to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTexSubImage3D;
	instance->target = target;
	instance->level = level;
	instance->xoffset = xoffset;
	instance->yoffset = yoffset;
	instance->zoffset = zoffset;
	instance->width = width;
	instance->height = height;
	instance->depth = depth;
	instance->format = format;
	instance->type = type;
	if (pixels == NULL) {
		instance->pixels = NULL;
	}
	else {
		instance->pixels = instance->pixelsData;
	}
	(void) crdlm_pointers_TexSubImage3D(instance, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** TrackMatrixNV ***/
static void DLM_APIENTRY passTrackMatrixNV(GLenum target, GLuint address, GLenum matrix, GLenum transform)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.TrackMatrixNV(target, address, matrix, transform);
}
static void DLM_APIENTRY executeTrackMatrixNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTrackMatrixNV *instance = (struct instanceTrackMatrixNV *)x;
	dispatchTable->TrackMatrixNV(instance->target, instance->address, instance->matrix, instance->transform);
}
void DLM_APIENTRY crdlm_compile_TrackMatrixNV( GLenum target, GLuint address, GLenum matrix, GLenum transform )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTrackMatrixNV *instance;
	instance = crCalloc(sizeof(struct instanceTrackMatrixNV));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding TrackMatrixNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTrackMatrixNV;
	instance->target = target;
	instance->address = address;
	instance->matrix = matrix;
	instance->transform = transform;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Translated ***/
static void DLM_APIENTRY passTranslated(GLdouble x, GLdouble y, GLdouble z)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Translated(x, y, z);
}
static void DLM_APIENTRY executeTranslated(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTranslated *instance = (struct instanceTranslated *)x;
	dispatchTable->Translated(instance->x, instance->y, instance->z);
}
void DLM_APIENTRY crdlm_compile_Translated( GLdouble x, GLdouble y, GLdouble z )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTranslated *instance;
	instance = crCalloc(sizeof(struct instanceTranslated));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Translated to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTranslated;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** Translatef ***/
static void DLM_APIENTRY passTranslatef(GLfloat x, GLfloat y, GLfloat z)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Translatef(x, y, z);
}
static void DLM_APIENTRY executeTranslatef(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceTranslatef *instance = (struct instanceTranslatef *)x;
	dispatchTable->Translatef(instance->x, instance->y, instance->z);
}
void DLM_APIENTRY crdlm_compile_Translatef( GLfloat x, GLfloat y, GLfloat z )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceTranslatef *instance;
	instance = crCalloc(sizeof(struct instanceTranslatef));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Translatef to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeTranslatef;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** UnmapBufferARB ***/
static GLboolean DLM_APIENTRY passUnmapBufferARB(GLenum target)
{
	CRDLMContextState *state = CURRENT_STATE();
	return state->savedDispatchTable.UnmapBufferARB(target);
}

/*** Vertex2d ***/
static void DLM_APIENTRY passVertex2d(GLdouble x, GLdouble y)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Vertex2d(x, y);
}
static void DLM_APIENTRY executeVertex2d(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertex2d *instance = (struct instanceVertex2d *)x;
	dispatchTable->Vertex2d(instance->x, instance->y);
}
void DLM_APIENTRY crdlm_compile_Vertex2d( GLdouble x, GLdouble y )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertex2d *instance;
	instance = crCalloc(sizeof(struct instanceVertex2d));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Vertex2d to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertex2d;
	instance->x = x;
	instance->y = y;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	{
		if (x < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = x;
		if (x > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = x;
		if (y < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = y;
		if (y > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = y;
		if (0.0 < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = 0.0;
		if (0.0 > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = 0.0;
	}
}

/*** Vertex2dv ***/
static void DLM_APIENTRY passVertex2dv(const GLdouble * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Vertex2dv(v);
}
static void DLM_APIENTRY executeVertex2dv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertex2dv *instance = (struct instanceVertex2dv *)x;
	dispatchTable->Vertex2dv(instance->v);
}
void DLM_APIENTRY crdlm_compile_Vertex2dv( const GLdouble * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertex2dv *instance;
	instance = crCalloc(sizeof(struct instanceVertex2dv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Vertex2dv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertex2dv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 2*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	{
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (0.0 < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = 0.0;
		if (0.0 > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = 0.0;
	}
}

/*** Vertex2f ***/
static void DLM_APIENTRY passVertex2f(GLfloat x, GLfloat y)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Vertex2f(x, y);
}
static void DLM_APIENTRY executeVertex2f(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertex2f *instance = (struct instanceVertex2f *)x;
	dispatchTable->Vertex2f(instance->x, instance->y);
}
void DLM_APIENTRY crdlm_compile_Vertex2f( GLfloat x, GLfloat y )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertex2f *instance;
	instance = crCalloc(sizeof(struct instanceVertex2f));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Vertex2f to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertex2f;
	instance->x = x;
	instance->y = y;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	{
		if (x < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = x;
		if (x > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = x;
		if (y < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = y;
		if (y > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = y;
		if (0.0 < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = 0.0;
		if (0.0 > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = 0.0;
	}
}

/*** Vertex2fv ***/
static void DLM_APIENTRY passVertex2fv(const GLfloat * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Vertex2fv(v);
}
static void DLM_APIENTRY executeVertex2fv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertex2fv *instance = (struct instanceVertex2fv *)x;
	dispatchTable->Vertex2fv(instance->v);
}
void DLM_APIENTRY crdlm_compile_Vertex2fv( const GLfloat * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertex2fv *instance;
	instance = crCalloc(sizeof(struct instanceVertex2fv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Vertex2fv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertex2fv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 2*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	{
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (0.0 < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = 0.0;
		if (0.0 > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = 0.0;
	}
}

/*** Vertex2i ***/
static void DLM_APIENTRY passVertex2i(GLint x, GLint y)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Vertex2i(x, y);
}
static void DLM_APIENTRY executeVertex2i(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertex2i *instance = (struct instanceVertex2i *)x;
	dispatchTable->Vertex2i(instance->x, instance->y);
}
void DLM_APIENTRY crdlm_compile_Vertex2i( GLint x, GLint y )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertex2i *instance;
	instance = crCalloc(sizeof(struct instanceVertex2i));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Vertex2i to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertex2i;
	instance->x = x;
	instance->y = y;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	{
		if (x < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = x;
		if (x > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = x;
		if (y < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = y;
		if (y > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = y;
		if (0.0 < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = 0.0;
		if (0.0 > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = 0.0;
	}
}

/*** Vertex2iv ***/
static void DLM_APIENTRY passVertex2iv(const GLint * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Vertex2iv(v);
}
static void DLM_APIENTRY executeVertex2iv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertex2iv *instance = (struct instanceVertex2iv *)x;
	dispatchTable->Vertex2iv(instance->v);
}
void DLM_APIENTRY crdlm_compile_Vertex2iv( const GLint * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertex2iv *instance;
	instance = crCalloc(sizeof(struct instanceVertex2iv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Vertex2iv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertex2iv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 2*sizeof(GLint));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	{
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (0.0 < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = 0.0;
		if (0.0 > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = 0.0;
	}
}

/*** Vertex2s ***/
static void DLM_APIENTRY passVertex2s(GLshort x, GLshort y)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Vertex2s(x, y);
}
static void DLM_APIENTRY executeVertex2s(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertex2s *instance = (struct instanceVertex2s *)x;
	dispatchTable->Vertex2s(instance->x, instance->y);
}
void DLM_APIENTRY crdlm_compile_Vertex2s( GLshort x, GLshort y )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertex2s *instance;
	instance = crCalloc(sizeof(struct instanceVertex2s));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Vertex2s to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertex2s;
	instance->x = x;
	instance->y = y;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	{
		if (x < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = x;
		if (x > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = x;
		if (y < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = y;
		if (y > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = y;
		if (0.0 < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = 0.0;
		if (0.0 > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = 0.0;
	}
}

/*** Vertex2sv ***/
static void DLM_APIENTRY passVertex2sv(const GLshort * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Vertex2sv(v);
}
static void DLM_APIENTRY executeVertex2sv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertex2sv *instance = (struct instanceVertex2sv *)x;
	dispatchTable->Vertex2sv(instance->v);
}
void DLM_APIENTRY crdlm_compile_Vertex2sv( const GLshort * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertex2sv *instance;
	instance = crCalloc(sizeof(struct instanceVertex2sv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Vertex2sv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertex2sv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 2*sizeof(GLshort));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	{
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (0.0 < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = 0.0;
		if (0.0 > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = 0.0;
	}
}

/*** Vertex3d ***/
static void DLM_APIENTRY passVertex3d(GLdouble x, GLdouble y, GLdouble z)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Vertex3d(x, y, z);
}
static void DLM_APIENTRY executeVertex3d(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertex3d *instance = (struct instanceVertex3d *)x;
	dispatchTable->Vertex3d(instance->x, instance->y, instance->z);
}
void DLM_APIENTRY crdlm_compile_Vertex3d( GLdouble x, GLdouble y, GLdouble z )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertex3d *instance;
	instance = crCalloc(sizeof(struct instanceVertex3d));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Vertex3d to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertex3d;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	{
		if (x < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = x;
		if (x > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = x;
		if (y < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = y;
		if (y > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = y;
		if (z < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = z;
		if (z > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = z;
	}
}

/*** Vertex3dv ***/
static void DLM_APIENTRY passVertex3dv(const GLdouble * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Vertex3dv(v);
}
static void DLM_APIENTRY executeVertex3dv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertex3dv *instance = (struct instanceVertex3dv *)x;
	dispatchTable->Vertex3dv(instance->v);
}
void DLM_APIENTRY crdlm_compile_Vertex3dv( const GLdouble * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertex3dv *instance;
	instance = crCalloc(sizeof(struct instanceVertex3dv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Vertex3dv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertex3dv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	{
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (v[2] < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = v[2];
		if (v[2] > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = v[2];
	}
}

/*** Vertex3f ***/
static void DLM_APIENTRY passVertex3f(GLfloat x, GLfloat y, GLfloat z)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Vertex3f(x, y, z);
}
static void DLM_APIENTRY executeVertex3f(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertex3f *instance = (struct instanceVertex3f *)x;
	dispatchTable->Vertex3f(instance->x, instance->y, instance->z);
}
void DLM_APIENTRY crdlm_compile_Vertex3f( GLfloat x, GLfloat y, GLfloat z )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertex3f *instance;
	instance = crCalloc(sizeof(struct instanceVertex3f));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Vertex3f to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertex3f;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	{
		if (x < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = x;
		if (x > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = x;
		if (y < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = y;
		if (y > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = y;
		if (z < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = z;
		if (z > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = z;
	}
}

/*** Vertex3fv ***/
static void DLM_APIENTRY passVertex3fv(const GLfloat * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Vertex3fv(v);
}
static void DLM_APIENTRY executeVertex3fv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertex3fv *instance = (struct instanceVertex3fv *)x;
	dispatchTable->Vertex3fv(instance->v);
}
void DLM_APIENTRY crdlm_compile_Vertex3fv( const GLfloat * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertex3fv *instance;
	instance = crCalloc(sizeof(struct instanceVertex3fv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Vertex3fv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertex3fv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	{
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (v[2] < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = v[2];
		if (v[2] > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = v[2];
	}
}

/*** Vertex3i ***/
static void DLM_APIENTRY passVertex3i(GLint x, GLint y, GLint z)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Vertex3i(x, y, z);
}
static void DLM_APIENTRY executeVertex3i(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertex3i *instance = (struct instanceVertex3i *)x;
	dispatchTable->Vertex3i(instance->x, instance->y, instance->z);
}
void DLM_APIENTRY crdlm_compile_Vertex3i( GLint x, GLint y, GLint z )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertex3i *instance;
	instance = crCalloc(sizeof(struct instanceVertex3i));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Vertex3i to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertex3i;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	{
		if (x < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = x;
		if (x > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = x;
		if (y < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = y;
		if (y > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = y;
		if (z < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = z;
		if (z > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = z;
	}
}

/*** Vertex3iv ***/
static void DLM_APIENTRY passVertex3iv(const GLint * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Vertex3iv(v);
}
static void DLM_APIENTRY executeVertex3iv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertex3iv *instance = (struct instanceVertex3iv *)x;
	dispatchTable->Vertex3iv(instance->v);
}
void DLM_APIENTRY crdlm_compile_Vertex3iv( const GLint * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertex3iv *instance;
	instance = crCalloc(sizeof(struct instanceVertex3iv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Vertex3iv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertex3iv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLint));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	{
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (v[2] < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = v[2];
		if (v[2] > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = v[2];
	}
}

/*** Vertex3s ***/
static void DLM_APIENTRY passVertex3s(GLshort x, GLshort y, GLshort z)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Vertex3s(x, y, z);
}
static void DLM_APIENTRY executeVertex3s(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertex3s *instance = (struct instanceVertex3s *)x;
	dispatchTable->Vertex3s(instance->x, instance->y, instance->z);
}
void DLM_APIENTRY crdlm_compile_Vertex3s( GLshort x, GLshort y, GLshort z )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertex3s *instance;
	instance = crCalloc(sizeof(struct instanceVertex3s));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Vertex3s to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertex3s;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	{
		if (x < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = x;
		if (x > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = x;
		if (y < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = y;
		if (y > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = y;
		if (z < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = z;
		if (z > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = z;
	}
}

/*** Vertex3sv ***/
static void DLM_APIENTRY passVertex3sv(const GLshort * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Vertex3sv(v);
}
static void DLM_APIENTRY executeVertex3sv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertex3sv *instance = (struct instanceVertex3sv *)x;
	dispatchTable->Vertex3sv(instance->v);
}
void DLM_APIENTRY crdlm_compile_Vertex3sv( const GLshort * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertex3sv *instance;
	instance = crCalloc(sizeof(struct instanceVertex3sv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Vertex3sv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertex3sv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLshort));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	{
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (v[2] < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = v[2];
		if (v[2] > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = v[2];
	}
}

/*** Vertex4d ***/
static void DLM_APIENTRY passVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Vertex4d(x, y, z, w);
}
static void DLM_APIENTRY executeVertex4d(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertex4d *instance = (struct instanceVertex4d *)x;
	dispatchTable->Vertex4d(instance->x, instance->y, instance->z, instance->w);
}
void DLM_APIENTRY crdlm_compile_Vertex4d( GLdouble x, GLdouble y, GLdouble z, GLdouble w )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertex4d *instance;
	instance = crCalloc(sizeof(struct instanceVertex4d));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Vertex4d to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertex4d;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	instance->w = w;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	{
		if (x < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = x;
		if (x > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = x;
		if (y < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = y;
		if (y > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = y;
		if (z < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = z;
		if (z > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = z;
	}
}

/*** Vertex4dv ***/
static void DLM_APIENTRY passVertex4dv(const GLdouble * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Vertex4dv(v);
}
static void DLM_APIENTRY executeVertex4dv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertex4dv *instance = (struct instanceVertex4dv *)x;
	dispatchTable->Vertex4dv(instance->v);
}
void DLM_APIENTRY crdlm_compile_Vertex4dv( const GLdouble * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertex4dv *instance;
	instance = crCalloc(sizeof(struct instanceVertex4dv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Vertex4dv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertex4dv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 4*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	{
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (v[2] < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = v[2];
		if (v[2] > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = v[2];
	}
}

/*** Vertex4f ***/
static void DLM_APIENTRY passVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Vertex4f(x, y, z, w);
}
static void DLM_APIENTRY executeVertex4f(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertex4f *instance = (struct instanceVertex4f *)x;
	dispatchTable->Vertex4f(instance->x, instance->y, instance->z, instance->w);
}
void DLM_APIENTRY crdlm_compile_Vertex4f( GLfloat x, GLfloat y, GLfloat z, GLfloat w )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertex4f *instance;
	instance = crCalloc(sizeof(struct instanceVertex4f));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Vertex4f to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertex4f;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	instance->w = w;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	{
		if (x < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = x;
		if (x > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = x;
		if (y < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = y;
		if (y > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = y;
		if (z < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = z;
		if (z > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = z;
	}
}

/*** Vertex4fv ***/
static void DLM_APIENTRY passVertex4fv(const GLfloat * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Vertex4fv(v);
}
static void DLM_APIENTRY executeVertex4fv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertex4fv *instance = (struct instanceVertex4fv *)x;
	dispatchTable->Vertex4fv(instance->v);
}
void DLM_APIENTRY crdlm_compile_Vertex4fv( const GLfloat * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertex4fv *instance;
	instance = crCalloc(sizeof(struct instanceVertex4fv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Vertex4fv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertex4fv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 4*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	{
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (v[2] < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = v[2];
		if (v[2] > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = v[2];
	}
}

/*** Vertex4i ***/
static void DLM_APIENTRY passVertex4i(GLint x, GLint y, GLint z, GLint w)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Vertex4i(x, y, z, w);
}
static void DLM_APIENTRY executeVertex4i(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertex4i *instance = (struct instanceVertex4i *)x;
	dispatchTable->Vertex4i(instance->x, instance->y, instance->z, instance->w);
}
void DLM_APIENTRY crdlm_compile_Vertex4i( GLint x, GLint y, GLint z, GLint w )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertex4i *instance;
	instance = crCalloc(sizeof(struct instanceVertex4i));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Vertex4i to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertex4i;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	instance->w = w;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	{
		if (x < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = x;
		if (x > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = x;
		if (y < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = y;
		if (y > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = y;
		if (z < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = z;
		if (z > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = z;
	}
}

/*** Vertex4iv ***/
static void DLM_APIENTRY passVertex4iv(const GLint * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Vertex4iv(v);
}
static void DLM_APIENTRY executeVertex4iv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertex4iv *instance = (struct instanceVertex4iv *)x;
	dispatchTable->Vertex4iv(instance->v);
}
void DLM_APIENTRY crdlm_compile_Vertex4iv( const GLint * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertex4iv *instance;
	instance = crCalloc(sizeof(struct instanceVertex4iv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Vertex4iv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertex4iv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 4*sizeof(GLint));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	{
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (v[2] < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = v[2];
		if (v[2] > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = v[2];
	}
}

/*** Vertex4s ***/
static void DLM_APIENTRY passVertex4s(GLshort x, GLshort y, GLshort z, GLshort w)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Vertex4s(x, y, z, w);
}
static void DLM_APIENTRY executeVertex4s(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertex4s *instance = (struct instanceVertex4s *)x;
	dispatchTable->Vertex4s(instance->x, instance->y, instance->z, instance->w);
}
void DLM_APIENTRY crdlm_compile_Vertex4s( GLshort x, GLshort y, GLshort z, GLshort w )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertex4s *instance;
	instance = crCalloc(sizeof(struct instanceVertex4s));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Vertex4s to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertex4s;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	instance->w = w;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	{
		if (x < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = x;
		if (x > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = x;
		if (y < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = y;
		if (y > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = y;
		if (z < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = z;
		if (z > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = z;
	}
}

/*** Vertex4sv ***/
static void DLM_APIENTRY passVertex4sv(const GLshort * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Vertex4sv(v);
}
static void DLM_APIENTRY executeVertex4sv(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertex4sv *instance = (struct instanceVertex4sv *)x;
	dispatchTable->Vertex4sv(instance->v);
}
void DLM_APIENTRY crdlm_compile_Vertex4sv( const GLshort * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertex4sv *instance;
	instance = crCalloc(sizeof(struct instanceVertex4sv));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Vertex4sv to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertex4sv;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 4*sizeof(GLshort));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	{
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (v[2] < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = v[2];
		if (v[2] > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = v[2];
	}
}

/*** VertexArrayRangeNV ***/
static void DLM_APIENTRY passVertexArrayRangeNV(GLsizei length, const GLvoid * pointer)
{
	CRDLMContextState *state = CURRENT_STATE();
	crdlmVertexArrayRangeNV(length, pointer, state->clientState);
	state->savedDispatchTable.VertexArrayRangeNV(length, pointer);
}

/*** VertexAttrib1dARB ***/
static void DLM_APIENTRY passVertexAttrib1dARB(GLuint index, GLdouble x)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib1dARB(index, x);
}
static void DLM_APIENTRY executeVertexAttrib1dARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib1dARB *instance = (struct instanceVertexAttrib1dARB *)x;
	dispatchTable->VertexAttrib1dARB(instance->index, instance->x);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib1dARB( GLuint index, GLdouble x )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib1dARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib1dARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib1dARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib1dARB;
	instance->index = index;
	instance->x = x;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (x < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = x;
		if (x > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = x;
		if (0.0 < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = 0.0;
		if (0.0 > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = 0.0;
	}
}

/*** VertexAttrib1dvARB ***/
static void DLM_APIENTRY passVertexAttrib1dvARB(GLuint index, const GLdouble * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib1dvARB(index, v);
}
static void DLM_APIENTRY executeVertexAttrib1dvARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib1dvARB *instance = (struct instanceVertexAttrib1dvARB *)x;
	dispatchTable->VertexAttrib1dvARB(instance->index, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib1dvARB( GLuint index, const GLdouble * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib1dvARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib1dvARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib1dvARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib1dvARB;
	instance->index = index;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 1*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (0.0 < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = 0.0;
		if (0.0 > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = 0.0;
	}
}

/*** VertexAttrib1fARB ***/
static void DLM_APIENTRY passVertexAttrib1fARB(GLuint index, GLfloat x)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib1fARB(index, x);
}
static void DLM_APIENTRY executeVertexAttrib1fARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib1fARB *instance = (struct instanceVertexAttrib1fARB *)x;
	dispatchTable->VertexAttrib1fARB(instance->index, instance->x);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib1fARB( GLuint index, GLfloat x )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib1fARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib1fARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib1fARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib1fARB;
	instance->index = index;
	instance->x = x;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (x < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = x;
		if (x > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = x;
		if (0.0 < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = 0.0;
		if (0.0 > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = 0.0;
	}
}

/*** VertexAttrib1fvARB ***/
static void DLM_APIENTRY passVertexAttrib1fvARB(GLuint index, const GLfloat * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib1fvARB(index, v);
}
static void DLM_APIENTRY executeVertexAttrib1fvARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib1fvARB *instance = (struct instanceVertexAttrib1fvARB *)x;
	dispatchTable->VertexAttrib1fvARB(instance->index, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib1fvARB( GLuint index, const GLfloat * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib1fvARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib1fvARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib1fvARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib1fvARB;
	instance->index = index;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 1*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (0.0 < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = 0.0;
		if (0.0 > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = 0.0;
	}
}

/*** VertexAttrib1sARB ***/
static void DLM_APIENTRY passVertexAttrib1sARB(GLuint index, GLshort x)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib1sARB(index, x);
}
static void DLM_APIENTRY executeVertexAttrib1sARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib1sARB *instance = (struct instanceVertexAttrib1sARB *)x;
	dispatchTable->VertexAttrib1sARB(instance->index, instance->x);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib1sARB( GLuint index, GLshort x )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib1sARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib1sARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib1sARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib1sARB;
	instance->index = index;
	instance->x = x;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (x < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = x;
		if (x > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = x;
		if (0.0 < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = 0.0;
		if (0.0 > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = 0.0;
	}
}

/*** VertexAttrib1svARB ***/
static void DLM_APIENTRY passVertexAttrib1svARB(GLuint index, const GLshort * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib1svARB(index, v);
}
static void DLM_APIENTRY executeVertexAttrib1svARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib1svARB *instance = (struct instanceVertexAttrib1svARB *)x;
	dispatchTable->VertexAttrib1svARB(instance->index, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib1svARB( GLuint index, const GLshort * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib1svARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib1svARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib1svARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib1svARB;
	instance->index = index;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 1*sizeof(GLshort));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (0.0 < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = 0.0;
		if (0.0 > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = 0.0;
	}
}

/*** VertexAttrib2dARB ***/
static void DLM_APIENTRY passVertexAttrib2dARB(GLuint index, GLdouble x, GLdouble y)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib2dARB(index, x, y);
}
static void DLM_APIENTRY executeVertexAttrib2dARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib2dARB *instance = (struct instanceVertexAttrib2dARB *)x;
	dispatchTable->VertexAttrib2dARB(instance->index, instance->x, instance->y);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib2dARB( GLuint index, GLdouble x, GLdouble y )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib2dARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib2dARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib2dARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib2dARB;
	instance->index = index;
	instance->x = x;
	instance->y = y;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (x < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = x;
		if (x > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = x;
		if (y < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = y;
		if (y > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = y;
		if (0.0 < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = 0.0;
		if (0.0 > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = 0.0;
	}
}

/*** VertexAttrib2dvARB ***/
static void DLM_APIENTRY passVertexAttrib2dvARB(GLuint index, const GLdouble * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib2dvARB(index, v);
}
static void DLM_APIENTRY executeVertexAttrib2dvARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib2dvARB *instance = (struct instanceVertexAttrib2dvARB *)x;
	dispatchTable->VertexAttrib2dvARB(instance->index, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib2dvARB( GLuint index, const GLdouble * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib2dvARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib2dvARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib2dvARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib2dvARB;
	instance->index = index;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 2*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (0.0 < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = 0.0;
		if (0.0 > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = 0.0;
	}
}

/*** VertexAttrib2fARB ***/
static void DLM_APIENTRY passVertexAttrib2fARB(GLuint index, GLfloat x, GLfloat y)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib2fARB(index, x, y);
}
static void DLM_APIENTRY executeVertexAttrib2fARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib2fARB *instance = (struct instanceVertexAttrib2fARB *)x;
	dispatchTable->VertexAttrib2fARB(instance->index, instance->x, instance->y);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib2fARB( GLuint index, GLfloat x, GLfloat y )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib2fARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib2fARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib2fARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib2fARB;
	instance->index = index;
	instance->x = x;
	instance->y = y;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (x < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = x;
		if (x > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = x;
		if (y < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = y;
		if (y > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = y;
		if (0.0 < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = 0.0;
		if (0.0 > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = 0.0;
	}
}

/*** VertexAttrib2fvARB ***/
static void DLM_APIENTRY passVertexAttrib2fvARB(GLuint index, const GLfloat * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib2fvARB(index, v);
}
static void DLM_APIENTRY executeVertexAttrib2fvARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib2fvARB *instance = (struct instanceVertexAttrib2fvARB *)x;
	dispatchTable->VertexAttrib2fvARB(instance->index, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib2fvARB( GLuint index, const GLfloat * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib2fvARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib2fvARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib2fvARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib2fvARB;
	instance->index = index;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 2*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (0.0 < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = 0.0;
		if (0.0 > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = 0.0;
	}
}

/*** VertexAttrib2sARB ***/
static void DLM_APIENTRY passVertexAttrib2sARB(GLuint index, GLshort x, GLshort y)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib2sARB(index, x, y);
}
static void DLM_APIENTRY executeVertexAttrib2sARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib2sARB *instance = (struct instanceVertexAttrib2sARB *)x;
	dispatchTable->VertexAttrib2sARB(instance->index, instance->x, instance->y);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib2sARB( GLuint index, GLshort x, GLshort y )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib2sARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib2sARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib2sARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib2sARB;
	instance->index = index;
	instance->x = x;
	instance->y = y;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (x < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = x;
		if (x > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = x;
		if (y < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = y;
		if (y > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = y;
		if (0.0 < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = 0.0;
		if (0.0 > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = 0.0;
	}
}

/*** VertexAttrib2svARB ***/
static void DLM_APIENTRY passVertexAttrib2svARB(GLuint index, const GLshort * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib2svARB(index, v);
}
static void DLM_APIENTRY executeVertexAttrib2svARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib2svARB *instance = (struct instanceVertexAttrib2svARB *)x;
	dispatchTable->VertexAttrib2svARB(instance->index, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib2svARB( GLuint index, const GLshort * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib2svARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib2svARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib2svARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib2svARB;
	instance->index = index;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 2*sizeof(GLshort));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (0.0 < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = 0.0;
		if (0.0 > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = 0.0;
	}
}

/*** VertexAttrib3dARB ***/
static void DLM_APIENTRY passVertexAttrib3dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib3dARB(index, x, y, z);
}
static void DLM_APIENTRY executeVertexAttrib3dARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib3dARB *instance = (struct instanceVertexAttrib3dARB *)x;
	dispatchTable->VertexAttrib3dARB(instance->index, instance->x, instance->y, instance->z);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib3dARB( GLuint index, GLdouble x, GLdouble y, GLdouble z )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib3dARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib3dARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib3dARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib3dARB;
	instance->index = index;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (x < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = x;
		if (x > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = x;
		if (y < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = y;
		if (y > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = y;
		if (z < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = z;
		if (z > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = z;
	}
}

/*** VertexAttrib3dvARB ***/
static void DLM_APIENTRY passVertexAttrib3dvARB(GLuint index, const GLdouble * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib3dvARB(index, v);
}
static void DLM_APIENTRY executeVertexAttrib3dvARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib3dvARB *instance = (struct instanceVertexAttrib3dvARB *)x;
	dispatchTable->VertexAttrib3dvARB(instance->index, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib3dvARB( GLuint index, const GLdouble * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib3dvARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib3dvARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib3dvARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib3dvARB;
	instance->index = index;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (v[2] < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = v[2];
		if (v[2] > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = v[2];
	}
}

/*** VertexAttrib3fARB ***/
static void DLM_APIENTRY passVertexAttrib3fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib3fARB(index, x, y, z);
}
static void DLM_APIENTRY executeVertexAttrib3fARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib3fARB *instance = (struct instanceVertexAttrib3fARB *)x;
	dispatchTable->VertexAttrib3fARB(instance->index, instance->x, instance->y, instance->z);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib3fARB( GLuint index, GLfloat x, GLfloat y, GLfloat z )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib3fARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib3fARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib3fARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib3fARB;
	instance->index = index;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (x < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = x;
		if (x > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = x;
		if (y < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = y;
		if (y > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = y;
		if (z < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = z;
		if (z > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = z;
	}
}

/*** VertexAttrib3fvARB ***/
static void DLM_APIENTRY passVertexAttrib3fvARB(GLuint index, const GLfloat * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib3fvARB(index, v);
}
static void DLM_APIENTRY executeVertexAttrib3fvARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib3fvARB *instance = (struct instanceVertexAttrib3fvARB *)x;
	dispatchTable->VertexAttrib3fvARB(instance->index, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib3fvARB( GLuint index, const GLfloat * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib3fvARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib3fvARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib3fvARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib3fvARB;
	instance->index = index;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (v[2] < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = v[2];
		if (v[2] > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = v[2];
	}
}

/*** VertexAttrib3sARB ***/
static void DLM_APIENTRY passVertexAttrib3sARB(GLuint index, GLshort x, GLshort y, GLshort z)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib3sARB(index, x, y, z);
}
static void DLM_APIENTRY executeVertexAttrib3sARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib3sARB *instance = (struct instanceVertexAttrib3sARB *)x;
	dispatchTable->VertexAttrib3sARB(instance->index, instance->x, instance->y, instance->z);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib3sARB( GLuint index, GLshort x, GLshort y, GLshort z )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib3sARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib3sARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib3sARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib3sARB;
	instance->index = index;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (x < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = x;
		if (x > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = x;
		if (y < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = y;
		if (y > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = y;
		if (z < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = z;
		if (z > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = z;
	}
}

/*** VertexAttrib3svARB ***/
static void DLM_APIENTRY passVertexAttrib3svARB(GLuint index, const GLshort * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib3svARB(index, v);
}
static void DLM_APIENTRY executeVertexAttrib3svARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib3svARB *instance = (struct instanceVertexAttrib3svARB *)x;
	dispatchTable->VertexAttrib3svARB(instance->index, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib3svARB( GLuint index, const GLshort * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib3svARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib3svARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib3svARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib3svARB;
	instance->index = index;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLshort));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (v[2] < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = v[2];
		if (v[2] > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = v[2];
	}
}

/*** VertexAttrib4NbvARB ***/
static void DLM_APIENTRY passVertexAttrib4NbvARB(GLuint index, const GLbyte * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib4NbvARB(index, v);
}
static void DLM_APIENTRY executeVertexAttrib4NbvARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib4NbvARB *instance = (struct instanceVertexAttrib4NbvARB *)x;
	dispatchTable->VertexAttrib4NbvARB(instance->index, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib4NbvARB( GLuint index, const GLbyte * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib4NbvARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib4NbvARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib4NbvARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib4NbvARB;
	instance->index = index;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 4*sizeof(GLbyte));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		GLfloat nx = (GLfloat) v[0] / 128.0f;
		GLfloat ny = (GLfloat) v[1] / 128.0f;
		GLfloat nz = (GLfloat) v[2] / 128.0f;
		if (nx < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = nx;
		if (nx > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = nx;
		if (ny < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = ny;
		if (ny > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = ny;
		if (nz < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = nz;
		if (nz > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = nz;
	}
}

/*** VertexAttrib4NivARB ***/
static void DLM_APIENTRY passVertexAttrib4NivARB(GLuint index, const GLint * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib4NivARB(index, v);
}
static void DLM_APIENTRY executeVertexAttrib4NivARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib4NivARB *instance = (struct instanceVertexAttrib4NivARB *)x;
	dispatchTable->VertexAttrib4NivARB(instance->index, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib4NivARB( GLuint index, const GLint * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib4NivARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib4NivARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib4NivARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib4NivARB;
	instance->index = index;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 4*sizeof(GLint));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		GLfloat nx = (GLfloat) v[0] / 2147483647.0f;
		GLfloat ny = (GLfloat) v[1] / 2147483647.0f;
		GLfloat nz = (GLfloat) v[2] / 2147483647.0f;
		if (nx < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = nx;
		if (nx > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = nx;
		if (ny < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = ny;
		if (ny > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = ny;
		if (nz < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = nz;
		if (nz > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = nz;
	}
}

/*** VertexAttrib4NsvARB ***/
static void DLM_APIENTRY passVertexAttrib4NsvARB(GLuint index, const GLshort * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib4NsvARB(index, v);
}
static void DLM_APIENTRY executeVertexAttrib4NsvARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib4NsvARB *instance = (struct instanceVertexAttrib4NsvARB *)x;
	dispatchTable->VertexAttrib4NsvARB(instance->index, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib4NsvARB( GLuint index, const GLshort * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib4NsvARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib4NsvARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib4NsvARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib4NsvARB;
	instance->index = index;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 4*sizeof(GLshort));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		GLfloat nx = (GLfloat) v[0] / 32768.0f;
		GLfloat ny = (GLfloat) v[1] / 32768.0f;
		GLfloat nz = (GLfloat) v[2] / 32768.0f;
		if (nx < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = nx;
		if (nx > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = nx;
		if (ny < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = ny;
		if (ny > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = ny;
		if (nz < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = nz;
		if (nz > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = nz;
	}
}

/*** VertexAttrib4NubARB ***/
static void DLM_APIENTRY passVertexAttrib4NubARB(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib4NubARB(index, x, y, z, w);
}
static void DLM_APIENTRY executeVertexAttrib4NubARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib4NubARB *instance = (struct instanceVertexAttrib4NubARB *)x;
	dispatchTable->VertexAttrib4NubARB(instance->index, instance->x, instance->y, instance->z, instance->w);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib4NubARB( GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib4NubARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib4NubARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib4NubARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib4NubARB;
	instance->index = index;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	instance->w = w;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		GLfloat nx = (GLfloat) x / 255.0f;
		GLfloat ny = (GLfloat) y / 255.0f;
		GLfloat nz = (GLfloat) z / 255.0f;
		if (nx < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = nx;
		if (nx > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = nx;
		if (ny < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = ny;
		if (ny > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = ny;
		if (nz < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = nz;
		if (nz > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = nz;
	}
}

/*** VertexAttrib4NubvARB ***/
static void DLM_APIENTRY passVertexAttrib4NubvARB(GLuint index, const GLubyte * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib4NubvARB(index, v);
}
static void DLM_APIENTRY executeVertexAttrib4NubvARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib4NubvARB *instance = (struct instanceVertexAttrib4NubvARB *)x;
	dispatchTable->VertexAttrib4NubvARB(instance->index, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib4NubvARB( GLuint index, const GLubyte * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib4NubvARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib4NubvARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib4NubvARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib4NubvARB;
	instance->index = index;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 4*sizeof(GLubyte));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		GLfloat nx = (GLfloat) v[0] / 255.0f;
		GLfloat ny = (GLfloat) v[1] / 255.0f;
		GLfloat nz = (GLfloat) v[2] / 255.0f;
		if (nx < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = nx;
		if (nx > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = nx;
		if (ny < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = ny;
		if (ny > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = ny;
		if (nz < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = nz;
		if (nz > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = nz;
	}
}

/*** VertexAttrib4NuivARB ***/
static void DLM_APIENTRY passVertexAttrib4NuivARB(GLuint index, const GLuint * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib4NuivARB(index, v);
}
static void DLM_APIENTRY executeVertexAttrib4NuivARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib4NuivARB *instance = (struct instanceVertexAttrib4NuivARB *)x;
	dispatchTable->VertexAttrib4NuivARB(instance->index, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib4NuivARB( GLuint index, const GLuint * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib4NuivARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib4NuivARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib4NuivARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib4NuivARB;
	instance->index = index;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 4*sizeof(GLuint));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		GLfloat nx = (GLfloat) v[0] / 4294967295.0f;
		GLfloat ny = (GLfloat) v[1] / 4294967295.0f;
		GLfloat nz = (GLfloat) v[2] / 4294967295.0f;
		if (nx < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = nx;
		if (nx > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = nx;
		if (ny < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = ny;
		if (ny > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = ny;
		if (nz < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = nz;
		if (nz > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = nz;
	}
}

/*** VertexAttrib4NusvARB ***/
static void DLM_APIENTRY passVertexAttrib4NusvARB(GLuint index, const GLushort * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib4NusvARB(index, v);
}
static void DLM_APIENTRY executeVertexAttrib4NusvARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib4NusvARB *instance = (struct instanceVertexAttrib4NusvARB *)x;
	dispatchTable->VertexAttrib4NusvARB(instance->index, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib4NusvARB( GLuint index, const GLushort * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib4NusvARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib4NusvARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib4NusvARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib4NusvARB;
	instance->index = index;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 4*sizeof(GLushort));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		GLfloat nx = (GLfloat) v[0] / 65535.0f;
		GLfloat ny = (GLfloat) v[1] / 65535.0f;
		GLfloat nz = (GLfloat) v[2] / 65535.0f;
		if (nx < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = nx;
		if (nx > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = nx;
		if (ny < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = ny;
		if (ny > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = ny;
		if (nz < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = nz;
		if (nz > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = nz;
	}
}

/*** VertexAttrib4bvARB ***/
static void DLM_APIENTRY passVertexAttrib4bvARB(GLuint index, const GLbyte * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib4bvARB(index, v);
}
static void DLM_APIENTRY executeVertexAttrib4bvARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib4bvARB *instance = (struct instanceVertexAttrib4bvARB *)x;
	dispatchTable->VertexAttrib4bvARB(instance->index, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib4bvARB( GLuint index, const GLbyte * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib4bvARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib4bvARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib4bvARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib4bvARB;
	instance->index = index;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 4*sizeof(GLbyte));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (v[2] < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = v[2];
		if (v[2] > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = v[2];
	}
}

/*** VertexAttrib4dARB ***/
static void DLM_APIENTRY passVertexAttrib4dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib4dARB(index, x, y, z, w);
}
static void DLM_APIENTRY executeVertexAttrib4dARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib4dARB *instance = (struct instanceVertexAttrib4dARB *)x;
	dispatchTable->VertexAttrib4dARB(instance->index, instance->x, instance->y, instance->z, instance->w);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib4dARB( GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib4dARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib4dARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib4dARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib4dARB;
	instance->index = index;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	instance->w = w;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (x < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = x;
		if (x > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = x;
		if (y < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = y;
		if (y > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = y;
		if (z < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = z;
		if (z > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = z;
	}
}

/*** VertexAttrib4dvARB ***/
static void DLM_APIENTRY passVertexAttrib4dvARB(GLuint index, const GLdouble * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib4dvARB(index, v);
}
static void DLM_APIENTRY executeVertexAttrib4dvARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib4dvARB *instance = (struct instanceVertexAttrib4dvARB *)x;
	dispatchTable->VertexAttrib4dvARB(instance->index, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib4dvARB( GLuint index, const GLdouble * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib4dvARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib4dvARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib4dvARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib4dvARB;
	instance->index = index;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 4*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (v[2] < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = v[2];
		if (v[2] > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = v[2];
	}
}

/*** VertexAttrib4fARB ***/
static void DLM_APIENTRY passVertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib4fARB(index, x, y, z, w);
}
static void DLM_APIENTRY executeVertexAttrib4fARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib4fARB *instance = (struct instanceVertexAttrib4fARB *)x;
	dispatchTable->VertexAttrib4fARB(instance->index, instance->x, instance->y, instance->z, instance->w);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib4fARB( GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib4fARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib4fARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib4fARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib4fARB;
	instance->index = index;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	instance->w = w;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (x < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = x;
		if (x > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = x;
		if (y < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = y;
		if (y > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = y;
		if (z < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = z;
		if (z > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = z;
	}
}

/*** VertexAttrib4fvARB ***/
static void DLM_APIENTRY passVertexAttrib4fvARB(GLuint index, const GLfloat * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib4fvARB(index, v);
}
static void DLM_APIENTRY executeVertexAttrib4fvARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib4fvARB *instance = (struct instanceVertexAttrib4fvARB *)x;
	dispatchTable->VertexAttrib4fvARB(instance->index, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib4fvARB( GLuint index, const GLfloat * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib4fvARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib4fvARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib4fvARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib4fvARB;
	instance->index = index;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 4*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (v[2] < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = v[2];
		if (v[2] > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = v[2];
	}
}

/*** VertexAttrib4ivARB ***/
static void DLM_APIENTRY passVertexAttrib4ivARB(GLuint index, const GLint * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib4ivARB(index, v);
}
static void DLM_APIENTRY executeVertexAttrib4ivARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib4ivARB *instance = (struct instanceVertexAttrib4ivARB *)x;
	dispatchTable->VertexAttrib4ivARB(instance->index, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib4ivARB( GLuint index, const GLint * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib4ivARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib4ivARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib4ivARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib4ivARB;
	instance->index = index;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 4*sizeof(GLint));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (v[2] < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = v[2];
		if (v[2] > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = v[2];
	}
}

/*** VertexAttrib4sARB ***/
static void DLM_APIENTRY passVertexAttrib4sARB(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib4sARB(index, x, y, z, w);
}
static void DLM_APIENTRY executeVertexAttrib4sARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib4sARB *instance = (struct instanceVertexAttrib4sARB *)x;
	dispatchTable->VertexAttrib4sARB(instance->index, instance->x, instance->y, instance->z, instance->w);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib4sARB( GLuint index, GLshort x, GLshort y, GLshort z, GLshort w )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib4sARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib4sARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib4sARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib4sARB;
	instance->index = index;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	instance->w = w;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (x < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = x;
		if (x > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = x;
		if (y < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = y;
		if (y > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = y;
		if (z < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = z;
		if (z > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = z;
	}
}

/*** VertexAttrib4svARB ***/
static void DLM_APIENTRY passVertexAttrib4svARB(GLuint index, const GLshort * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib4svARB(index, v);
}
static void DLM_APIENTRY executeVertexAttrib4svARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib4svARB *instance = (struct instanceVertexAttrib4svARB *)x;
	dispatchTable->VertexAttrib4svARB(instance->index, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib4svARB( GLuint index, const GLshort * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib4svARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib4svARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib4svARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib4svARB;
	instance->index = index;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 4*sizeof(GLshort));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (v[2] < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = v[2];
		if (v[2] > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = v[2];
	}
}

/*** VertexAttrib4ubvARB ***/
static void DLM_APIENTRY passVertexAttrib4ubvARB(GLuint index, const GLubyte * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib4ubvARB(index, v);
}
static void DLM_APIENTRY executeVertexAttrib4ubvARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib4ubvARB *instance = (struct instanceVertexAttrib4ubvARB *)x;
	dispatchTable->VertexAttrib4ubvARB(instance->index, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib4ubvARB( GLuint index, const GLubyte * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib4ubvARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib4ubvARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib4ubvARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib4ubvARB;
	instance->index = index;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 4*sizeof(GLubyte));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (v[2] < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = v[2];
		if (v[2] > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = v[2];
	}
}

/*** VertexAttrib4uivARB ***/
static void DLM_APIENTRY passVertexAttrib4uivARB(GLuint index, const GLuint * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib4uivARB(index, v);
}
static void DLM_APIENTRY executeVertexAttrib4uivARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib4uivARB *instance = (struct instanceVertexAttrib4uivARB *)x;
	dispatchTable->VertexAttrib4uivARB(instance->index, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib4uivARB( GLuint index, const GLuint * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib4uivARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib4uivARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib4uivARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib4uivARB;
	instance->index = index;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 4*sizeof(GLuint));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (v[2] < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = v[2];
		if (v[2] > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = v[2];
	}
}

/*** VertexAttrib4usvARB ***/
static void DLM_APIENTRY passVertexAttrib4usvARB(GLuint index, const GLushort * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttrib4usvARB(index, v);
}
static void DLM_APIENTRY executeVertexAttrib4usvARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttrib4usvARB *instance = (struct instanceVertexAttrib4usvARB *)x;
	dispatchTable->VertexAttrib4usvARB(instance->index, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttrib4usvARB( GLuint index, const GLushort * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttrib4usvARB *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttrib4usvARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttrib4usvARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttrib4usvARB;
	instance->index = index;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 4*sizeof(GLushort));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (v[2] < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = v[2];
		if (v[2] > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = v[2];
	}
}

/*** VertexAttribPointerARB ***/
static void DLM_APIENTRY passVertexAttribPointerARB(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid * pointer)
{
	CRDLMContextState *state = CURRENT_STATE();
	crdlmVertexAttribPointerARB(index, size, type, normalized, stride, pointer, state->clientState);
	state->savedDispatchTable.VertexAttribPointerARB(index, size, type, normalized, stride, pointer);
}

/*** VertexAttribPointerNV ***/
static void DLM_APIENTRY passVertexAttribPointerNV(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer)
{
	CRDLMContextState *state = CURRENT_STATE();
	crdlmVertexAttribPointerNV(index, size, type, stride, pointer, state->clientState);
	state->savedDispatchTable.VertexAttribPointerNV(index, size, type, stride, pointer);
}

/*** VertexAttribs1dvNV ***/
static void DLM_APIENTRY passVertexAttribs1dvNV(GLuint index, GLsizei n, const GLdouble * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttribs1dvNV(index, n, v);
}
static void DLM_APIENTRY executeVertexAttribs1dvNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttribs1dvNV *instance = (struct instanceVertexAttribs1dvNV *)x;
	dispatchTable->VertexAttribs1dvNV(instance->index, instance->n, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttribs1dvNV( GLuint index, GLsizei n, const GLdouble * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttribs1dvNV *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttribs1dvNV) + crdlm_pointers_VertexAttribs1dvNV(NULL, index, n, v));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttribs1dvNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttribs1dvNV;
	instance->index = index;
	instance->n = n;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	(void) crdlm_pointers_VertexAttribs1dvNV(instance, index, n, v);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (0.0 < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = 0.0;
		if (0.0 > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = 0.0;
	}
}

/*** VertexAttribs1fvNV ***/
static void DLM_APIENTRY passVertexAttribs1fvNV(GLuint index, GLsizei n, const GLfloat * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttribs1fvNV(index, n, v);
}
static void DLM_APIENTRY executeVertexAttribs1fvNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttribs1fvNV *instance = (struct instanceVertexAttribs1fvNV *)x;
	dispatchTable->VertexAttribs1fvNV(instance->index, instance->n, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttribs1fvNV( GLuint index, GLsizei n, const GLfloat * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttribs1fvNV *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttribs1fvNV) + crdlm_pointers_VertexAttribs1fvNV(NULL, index, n, v));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttribs1fvNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttribs1fvNV;
	instance->index = index;
	instance->n = n;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	(void) crdlm_pointers_VertexAttribs1fvNV(instance, index, n, v);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (0.0 < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = 0.0;
		if (0.0 > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = 0.0;
	}
}

/*** VertexAttribs1svNV ***/
static void DLM_APIENTRY passVertexAttribs1svNV(GLuint index, GLsizei n, const GLshort * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttribs1svNV(index, n, v);
}
static void DLM_APIENTRY executeVertexAttribs1svNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttribs1svNV *instance = (struct instanceVertexAttribs1svNV *)x;
	dispatchTable->VertexAttribs1svNV(instance->index, instance->n, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttribs1svNV( GLuint index, GLsizei n, const GLshort * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttribs1svNV *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttribs1svNV) + crdlm_pointers_VertexAttribs1svNV(NULL, index, n, v));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttribs1svNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttribs1svNV;
	instance->index = index;
	instance->n = n;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	(void) crdlm_pointers_VertexAttribs1svNV(instance, index, n, v);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (0.0 < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = 0.0;
		if (0.0 > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = 0.0;
	}
}

/*** VertexAttribs2dvNV ***/
static void DLM_APIENTRY passVertexAttribs2dvNV(GLuint index, GLsizei n, const GLdouble * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttribs2dvNV(index, n, v);
}
static void DLM_APIENTRY executeVertexAttribs2dvNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttribs2dvNV *instance = (struct instanceVertexAttribs2dvNV *)x;
	dispatchTable->VertexAttribs2dvNV(instance->index, instance->n, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttribs2dvNV( GLuint index, GLsizei n, const GLdouble * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttribs2dvNV *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttribs2dvNV) + crdlm_pointers_VertexAttribs2dvNV(NULL, index, n, v));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttribs2dvNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttribs2dvNV;
	instance->index = index;
	instance->n = n;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	(void) crdlm_pointers_VertexAttribs2dvNV(instance, index, n, v);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (0.0 < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = 0.0;
		if (0.0 > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = 0.0;
	}
}

/*** VertexAttribs2fvNV ***/
static void DLM_APIENTRY passVertexAttribs2fvNV(GLuint index, GLsizei n, const GLfloat * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttribs2fvNV(index, n, v);
}
static void DLM_APIENTRY executeVertexAttribs2fvNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttribs2fvNV *instance = (struct instanceVertexAttribs2fvNV *)x;
	dispatchTable->VertexAttribs2fvNV(instance->index, instance->n, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttribs2fvNV( GLuint index, GLsizei n, const GLfloat * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttribs2fvNV *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttribs2fvNV) + crdlm_pointers_VertexAttribs2fvNV(NULL, index, n, v));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttribs2fvNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttribs2fvNV;
	instance->index = index;
	instance->n = n;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	(void) crdlm_pointers_VertexAttribs2fvNV(instance, index, n, v);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (0.0 < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = 0.0;
		if (0.0 > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = 0.0;
	}
}

/*** VertexAttribs2svNV ***/
static void DLM_APIENTRY passVertexAttribs2svNV(GLuint index, GLsizei n, const GLshort * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttribs2svNV(index, n, v);
}
static void DLM_APIENTRY executeVertexAttribs2svNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttribs2svNV *instance = (struct instanceVertexAttribs2svNV *)x;
	dispatchTable->VertexAttribs2svNV(instance->index, instance->n, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttribs2svNV( GLuint index, GLsizei n, const GLshort * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttribs2svNV *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttribs2svNV) + crdlm_pointers_VertexAttribs2svNV(NULL, index, n, v));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttribs2svNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttribs2svNV;
	instance->index = index;
	instance->n = n;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	(void) crdlm_pointers_VertexAttribs2svNV(instance, index, n, v);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (0.0 < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = 0.0;
		if (0.0 > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = 0.0;
	}
}

/*** VertexAttribs3dvNV ***/
static void DLM_APIENTRY passVertexAttribs3dvNV(GLuint index, GLsizei n, const GLdouble * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttribs3dvNV(index, n, v);
}
static void DLM_APIENTRY executeVertexAttribs3dvNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttribs3dvNV *instance = (struct instanceVertexAttribs3dvNV *)x;
	dispatchTable->VertexAttribs3dvNV(instance->index, instance->n, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttribs3dvNV( GLuint index, GLsizei n, const GLdouble * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttribs3dvNV *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttribs3dvNV) + crdlm_pointers_VertexAttribs3dvNV(NULL, index, n, v));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttribs3dvNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttribs3dvNV;
	instance->index = index;
	instance->n = n;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	(void) crdlm_pointers_VertexAttribs3dvNV(instance, index, n, v);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (v[2] < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = v[2];
		if (v[2] > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = v[2];
	}
}

/*** VertexAttribs3fvNV ***/
static void DLM_APIENTRY passVertexAttribs3fvNV(GLuint index, GLsizei n, const GLfloat * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttribs3fvNV(index, n, v);
}
static void DLM_APIENTRY executeVertexAttribs3fvNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttribs3fvNV *instance = (struct instanceVertexAttribs3fvNV *)x;
	dispatchTable->VertexAttribs3fvNV(instance->index, instance->n, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttribs3fvNV( GLuint index, GLsizei n, const GLfloat * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttribs3fvNV *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttribs3fvNV) + crdlm_pointers_VertexAttribs3fvNV(NULL, index, n, v));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttribs3fvNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttribs3fvNV;
	instance->index = index;
	instance->n = n;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	(void) crdlm_pointers_VertexAttribs3fvNV(instance, index, n, v);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (v[2] < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = v[2];
		if (v[2] > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = v[2];
	}
}

/*** VertexAttribs3svNV ***/
static void DLM_APIENTRY passVertexAttribs3svNV(GLuint index, GLsizei n, const GLshort * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttribs3svNV(index, n, v);
}
static void DLM_APIENTRY executeVertexAttribs3svNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttribs3svNV *instance = (struct instanceVertexAttribs3svNV *)x;
	dispatchTable->VertexAttribs3svNV(instance->index, instance->n, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttribs3svNV( GLuint index, GLsizei n, const GLshort * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttribs3svNV *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttribs3svNV) + crdlm_pointers_VertexAttribs3svNV(NULL, index, n, v));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttribs3svNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttribs3svNV;
	instance->index = index;
	instance->n = n;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	(void) crdlm_pointers_VertexAttribs3svNV(instance, index, n, v);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (v[2] < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = v[2];
		if (v[2] > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = v[2];
	}
}

/*** VertexAttribs4dvNV ***/
static void DLM_APIENTRY passVertexAttribs4dvNV(GLuint index, GLsizei n, const GLdouble * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttribs4dvNV(index, n, v);
}
static void DLM_APIENTRY executeVertexAttribs4dvNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttribs4dvNV *instance = (struct instanceVertexAttribs4dvNV *)x;
	dispatchTable->VertexAttribs4dvNV(instance->index, instance->n, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttribs4dvNV( GLuint index, GLsizei n, const GLdouble * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttribs4dvNV *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttribs4dvNV) + crdlm_pointers_VertexAttribs4dvNV(NULL, index, n, v));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttribs4dvNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttribs4dvNV;
	instance->index = index;
	instance->n = n;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	(void) crdlm_pointers_VertexAttribs4dvNV(instance, index, n, v);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (v[2] < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = v[2];
		if (v[2] > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = v[2];
	}
}

/*** VertexAttribs4fvNV ***/
static void DLM_APIENTRY passVertexAttribs4fvNV(GLuint index, GLsizei n, const GLfloat * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttribs4fvNV(index, n, v);
}
static void DLM_APIENTRY executeVertexAttribs4fvNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttribs4fvNV *instance = (struct instanceVertexAttribs4fvNV *)x;
	dispatchTable->VertexAttribs4fvNV(instance->index, instance->n, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttribs4fvNV( GLuint index, GLsizei n, const GLfloat * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttribs4fvNV *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttribs4fvNV) + crdlm_pointers_VertexAttribs4fvNV(NULL, index, n, v));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttribs4fvNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttribs4fvNV;
	instance->index = index;
	instance->n = n;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	(void) crdlm_pointers_VertexAttribs4fvNV(instance, index, n, v);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (v[2] < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = v[2];
		if (v[2] > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = v[2];
	}
}

/*** VertexAttribs4svNV ***/
static void DLM_APIENTRY passVertexAttribs4svNV(GLuint index, GLsizei n, const GLshort * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttribs4svNV(index, n, v);
}
static void DLM_APIENTRY executeVertexAttribs4svNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttribs4svNV *instance = (struct instanceVertexAttribs4svNV *)x;
	dispatchTable->VertexAttribs4svNV(instance->index, instance->n, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttribs4svNV( GLuint index, GLsizei n, const GLshort * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttribs4svNV *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttribs4svNV) + crdlm_pointers_VertexAttribs4svNV(NULL, index, n, v));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttribs4svNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttribs4svNV;
	instance->index = index;
	instance->n = n;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	(void) crdlm_pointers_VertexAttribs4svNV(instance, index, n, v);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (v[2] < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = v[2];
		if (v[2] > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = v[2];
	}
}

/*** VertexAttribs4ubvNV ***/
static void DLM_APIENTRY passVertexAttribs4ubvNV(GLuint index, GLsizei n, const GLubyte * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.VertexAttribs4ubvNV(index, n, v);
}
static void DLM_APIENTRY executeVertexAttribs4ubvNV(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceVertexAttribs4ubvNV *instance = (struct instanceVertexAttribs4ubvNV *)x;
	dispatchTable->VertexAttribs4ubvNV(instance->index, instance->n, instance->v);
}
void DLM_APIENTRY crdlm_compile_VertexAttribs4ubvNV( GLuint index, GLsizei n, const GLubyte * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceVertexAttribs4ubvNV *instance;
	instance = crCalloc(sizeof(struct instanceVertexAttribs4ubvNV) + crdlm_pointers_VertexAttribs4ubvNV(NULL, index, n, v));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding VertexAttribs4ubvNV to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeVertexAttribs4ubvNV;
	instance->index = index;
	instance->n = n;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	(void) crdlm_pointers_VertexAttribs4ubvNV(instance, index, n, v);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
	if (index == 0) {
		if (v[0] < state->currentListInfo->bbox.xmin)
			state->currentListInfo->bbox.xmin = v[0];
		if (v[0] > state->currentListInfo->bbox.xmax)
			state->currentListInfo->bbox.xmax = v[0];
		if (v[1] < state->currentListInfo->bbox.ymin)
			state->currentListInfo->bbox.ymin = v[1];
		if (v[1] > state->currentListInfo->bbox.ymax)
			state->currentListInfo->bbox.ymax = v[1];
		if (v[2] < state->currentListInfo->bbox.zmin)
			state->currentListInfo->bbox.zmin = v[2];
		if (v[2] > state->currentListInfo->bbox.zmax)
			state->currentListInfo->bbox.zmax = v[2];
	}
}

/*** VertexPointer ***/
static void DLM_APIENTRY passVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer)
{
	CRDLMContextState *state = CURRENT_STATE();
	crdlmVertexPointer(size, type, stride, pointer, state->clientState);
	state->savedDispatchTable.VertexPointer(size, type, stride, pointer);
}

/*** Viewport ***/
static void DLM_APIENTRY passViewport(GLint x, GLint y, GLsizei width, GLsizei height)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Viewport(x, y, width, height);
}
static void DLM_APIENTRY executeViewport(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceViewport *instance = (struct instanceViewport *)x;
	dispatchTable->Viewport(instance->x, instance->y, instance->width, instance->height);
}
void DLM_APIENTRY crdlm_compile_Viewport( GLint x, GLint y, GLsizei width, GLsizei height )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceViewport *instance;
	instance = crCalloc(sizeof(struct instanceViewport));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding Viewport to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeViewport;
	instance->x = x;
	instance->y = y;
	instance->width = width;
	instance->height = height;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** WindowCreate ***/
static GLint DLM_APIENTRY passWindowCreate(const char * dpyName, GLint visBits)
{
	CRDLMContextState *state = CURRENT_STATE();
	return state->savedDispatchTable.WindowCreate(dpyName, visBits);
}

/*** WindowDestroy ***/
static void DLM_APIENTRY passWindowDestroy(GLint window)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.WindowDestroy(window);
}

/*** WindowPos2dARB ***/
static void DLM_APIENTRY passWindowPos2dARB(GLdouble x, GLdouble y)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.WindowPos2dARB(x, y);
}
static void DLM_APIENTRY executeWindowPos2dARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceWindowPos2dARB *instance = (struct instanceWindowPos2dARB *)x;
	dispatchTable->WindowPos2dARB(instance->x, instance->y);
}
void DLM_APIENTRY crdlm_compile_WindowPos2dARB( GLdouble x, GLdouble y )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceWindowPos2dARB *instance;
	instance = crCalloc(sizeof(struct instanceWindowPos2dARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding WindowPos2dARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeWindowPos2dARB;
	instance->x = x;
	instance->y = y;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** WindowPos2dvARB ***/
static void DLM_APIENTRY passWindowPos2dvARB(const GLdouble * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.WindowPos2dvARB(v);
}
static void DLM_APIENTRY executeWindowPos2dvARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceWindowPos2dvARB *instance = (struct instanceWindowPos2dvARB *)x;
	dispatchTable->WindowPos2dvARB(instance->v);
}
void DLM_APIENTRY crdlm_compile_WindowPos2dvARB( const GLdouble * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceWindowPos2dvARB *instance;
	instance = crCalloc(sizeof(struct instanceWindowPos2dvARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding WindowPos2dvARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeWindowPos2dvARB;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 2*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** WindowPos2fARB ***/
static void DLM_APIENTRY passWindowPos2fARB(GLfloat x, GLfloat y)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.WindowPos2fARB(x, y);
}
static void DLM_APIENTRY executeWindowPos2fARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceWindowPos2fARB *instance = (struct instanceWindowPos2fARB *)x;
	dispatchTable->WindowPos2fARB(instance->x, instance->y);
}
void DLM_APIENTRY crdlm_compile_WindowPos2fARB( GLfloat x, GLfloat y )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceWindowPos2fARB *instance;
	instance = crCalloc(sizeof(struct instanceWindowPos2fARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding WindowPos2fARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeWindowPos2fARB;
	instance->x = x;
	instance->y = y;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** WindowPos2fvARB ***/
static void DLM_APIENTRY passWindowPos2fvARB(const GLfloat * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.WindowPos2fvARB(v);
}
static void DLM_APIENTRY executeWindowPos2fvARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceWindowPos2fvARB *instance = (struct instanceWindowPos2fvARB *)x;
	dispatchTable->WindowPos2fvARB(instance->v);
}
void DLM_APIENTRY crdlm_compile_WindowPos2fvARB( const GLfloat * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceWindowPos2fvARB *instance;
	instance = crCalloc(sizeof(struct instanceWindowPos2fvARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding WindowPos2fvARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeWindowPos2fvARB;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 2*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** WindowPos2iARB ***/
static void DLM_APIENTRY passWindowPos2iARB(GLint x, GLint y)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.WindowPos2iARB(x, y);
}
static void DLM_APIENTRY executeWindowPos2iARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceWindowPos2iARB *instance = (struct instanceWindowPos2iARB *)x;
	dispatchTable->WindowPos2iARB(instance->x, instance->y);
}
void DLM_APIENTRY crdlm_compile_WindowPos2iARB( GLint x, GLint y )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceWindowPos2iARB *instance;
	instance = crCalloc(sizeof(struct instanceWindowPos2iARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding WindowPos2iARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeWindowPos2iARB;
	instance->x = x;
	instance->y = y;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** WindowPos2ivARB ***/
static void DLM_APIENTRY passWindowPos2ivARB(const GLint * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.WindowPos2ivARB(v);
}
static void DLM_APIENTRY executeWindowPos2ivARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceWindowPos2ivARB *instance = (struct instanceWindowPos2ivARB *)x;
	dispatchTable->WindowPos2ivARB(instance->v);
}
void DLM_APIENTRY crdlm_compile_WindowPos2ivARB( const GLint * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceWindowPos2ivARB *instance;
	instance = crCalloc(sizeof(struct instanceWindowPos2ivARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding WindowPos2ivARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeWindowPos2ivARB;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 2*sizeof(GLint));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** WindowPos2sARB ***/
static void DLM_APIENTRY passWindowPos2sARB(GLshort x, GLshort y)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.WindowPos2sARB(x, y);
}
static void DLM_APIENTRY executeWindowPos2sARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceWindowPos2sARB *instance = (struct instanceWindowPos2sARB *)x;
	dispatchTable->WindowPos2sARB(instance->x, instance->y);
}
void DLM_APIENTRY crdlm_compile_WindowPos2sARB( GLshort x, GLshort y )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceWindowPos2sARB *instance;
	instance = crCalloc(sizeof(struct instanceWindowPos2sARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding WindowPos2sARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeWindowPos2sARB;
	instance->x = x;
	instance->y = y;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** WindowPos2svARB ***/
static void DLM_APIENTRY passWindowPos2svARB(const GLshort * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.WindowPos2svARB(v);
}
static void DLM_APIENTRY executeWindowPos2svARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceWindowPos2svARB *instance = (struct instanceWindowPos2svARB *)x;
	dispatchTable->WindowPos2svARB(instance->v);
}
void DLM_APIENTRY crdlm_compile_WindowPos2svARB( const GLshort * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceWindowPos2svARB *instance;
	instance = crCalloc(sizeof(struct instanceWindowPos2svARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding WindowPos2svARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeWindowPos2svARB;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 2*sizeof(GLshort));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** WindowPos3dARB ***/
static void DLM_APIENTRY passWindowPos3dARB(GLdouble x, GLdouble y, GLdouble z)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.WindowPos3dARB(x, y, z);
}
static void DLM_APIENTRY executeWindowPos3dARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceWindowPos3dARB *instance = (struct instanceWindowPos3dARB *)x;
	dispatchTable->WindowPos3dARB(instance->x, instance->y, instance->z);
}
void DLM_APIENTRY crdlm_compile_WindowPos3dARB( GLdouble x, GLdouble y, GLdouble z )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceWindowPos3dARB *instance;
	instance = crCalloc(sizeof(struct instanceWindowPos3dARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding WindowPos3dARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeWindowPos3dARB;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** WindowPos3dvARB ***/
static void DLM_APIENTRY passWindowPos3dvARB(const GLdouble * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.WindowPos3dvARB(v);
}
static void DLM_APIENTRY executeWindowPos3dvARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceWindowPos3dvARB *instance = (struct instanceWindowPos3dvARB *)x;
	dispatchTable->WindowPos3dvARB(instance->v);
}
void DLM_APIENTRY crdlm_compile_WindowPos3dvARB( const GLdouble * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceWindowPos3dvARB *instance;
	instance = crCalloc(sizeof(struct instanceWindowPos3dvARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding WindowPos3dvARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeWindowPos3dvARB;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLdouble));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** WindowPos3fARB ***/
static void DLM_APIENTRY passWindowPos3fARB(GLfloat x, GLfloat y, GLfloat z)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.WindowPos3fARB(x, y, z);
}
static void DLM_APIENTRY executeWindowPos3fARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceWindowPos3fARB *instance = (struct instanceWindowPos3fARB *)x;
	dispatchTable->WindowPos3fARB(instance->x, instance->y, instance->z);
}
void DLM_APIENTRY crdlm_compile_WindowPos3fARB( GLfloat x, GLfloat y, GLfloat z )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceWindowPos3fARB *instance;
	instance = crCalloc(sizeof(struct instanceWindowPos3fARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding WindowPos3fARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeWindowPos3fARB;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** WindowPos3fvARB ***/
static void DLM_APIENTRY passWindowPos3fvARB(const GLfloat * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.WindowPos3fvARB(v);
}
static void DLM_APIENTRY executeWindowPos3fvARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceWindowPos3fvARB *instance = (struct instanceWindowPos3fvARB *)x;
	dispatchTable->WindowPos3fvARB(instance->v);
}
void DLM_APIENTRY crdlm_compile_WindowPos3fvARB( const GLfloat * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceWindowPos3fvARB *instance;
	instance = crCalloc(sizeof(struct instanceWindowPos3fvARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding WindowPos3fvARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeWindowPos3fvARB;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLfloat));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** WindowPos3iARB ***/
static void DLM_APIENTRY passWindowPos3iARB(GLint x, GLint y, GLint z)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.WindowPos3iARB(x, y, z);
}
static void DLM_APIENTRY executeWindowPos3iARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceWindowPos3iARB *instance = (struct instanceWindowPos3iARB *)x;
	dispatchTable->WindowPos3iARB(instance->x, instance->y, instance->z);
}
void DLM_APIENTRY crdlm_compile_WindowPos3iARB( GLint x, GLint y, GLint z )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceWindowPos3iARB *instance;
	instance = crCalloc(sizeof(struct instanceWindowPos3iARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding WindowPos3iARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeWindowPos3iARB;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** WindowPos3ivARB ***/
static void DLM_APIENTRY passWindowPos3ivARB(const GLint * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.WindowPos3ivARB(v);
}
static void DLM_APIENTRY executeWindowPos3ivARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceWindowPos3ivARB *instance = (struct instanceWindowPos3ivARB *)x;
	dispatchTable->WindowPos3ivARB(instance->v);
}
void DLM_APIENTRY crdlm_compile_WindowPos3ivARB( const GLint * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceWindowPos3ivARB *instance;
	instance = crCalloc(sizeof(struct instanceWindowPos3ivARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding WindowPos3ivARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeWindowPos3ivARB;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLint));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** WindowPos3sARB ***/
static void DLM_APIENTRY passWindowPos3sARB(GLshort x, GLshort y, GLshort z)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.WindowPos3sARB(x, y, z);
}
static void DLM_APIENTRY executeWindowPos3sARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceWindowPos3sARB *instance = (struct instanceWindowPos3sARB *)x;
	dispatchTable->WindowPos3sARB(instance->x, instance->y, instance->z);
}
void DLM_APIENTRY crdlm_compile_WindowPos3sARB( GLshort x, GLshort y, GLshort z )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceWindowPos3sARB *instance;
	instance = crCalloc(sizeof(struct instanceWindowPos3sARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding WindowPos3sARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeWindowPos3sARB;
	instance->x = x;
	instance->y = y;
	instance->z = z;
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** WindowPos3svARB ***/
static void DLM_APIENTRY passWindowPos3svARB(const GLshort * v)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.WindowPos3svARB(v);
}
static void DLM_APIENTRY executeWindowPos3svARB(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceWindowPos3svARB *instance = (struct instanceWindowPos3svARB *)x;
	dispatchTable->WindowPos3svARB(instance->v);
}
void DLM_APIENTRY crdlm_compile_WindowPos3svARB( const GLshort * v )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceWindowPos3svARB *instance;
	instance = crCalloc(sizeof(struct instanceWindowPos3svARB));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding WindowPos3svARB to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeWindowPos3svARB;
	if (v == NULL) {
		instance->v = NULL;
	}
	else {
		instance->v = instance->vData;
	}
	crMemcpy((void *)instance->v, (void *) v, 3*sizeof(GLshort));
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}

/*** WindowPosition ***/
static void DLM_APIENTRY passWindowPosition(GLint window, GLint x, GLint y)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.WindowPosition(window, x, y);
}

/*** WindowShow ***/
static void DLM_APIENTRY passWindowShow(GLint window, GLint flag)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.WindowShow(window, flag);
}

/*** WindowSize ***/
static void DLM_APIENTRY passWindowSize(GLint window, GLint w, GLint h)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.WindowSize(window, w, h);
}

/*** Writeback ***/
static void DLM_APIENTRY passWriteback(GLint * writeback)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.Writeback(writeback);
}

/*** ZPixCR ***/
static void DLM_APIENTRY passZPixCR(GLsizei width, GLsizei height, GLenum format, GLenum type, GLenum ztype, GLint zparm, GLint length, const GLvoid * pixels)
{
	CRDLMContextState *state = CURRENT_STATE();
	state->savedDispatchTable.ZPixCR(width, height, format, type, ztype, zparm, length, pixels);
}
static void DLM_APIENTRY executeZPixCR(DLMInstanceList *x, SPUDispatchTable *dispatchTable)
{
	struct instanceZPixCR *instance = (struct instanceZPixCR *)x;
	dispatchTable->ZPixCR(instance->width, instance->height, instance->format, instance->type, instance->ztype, instance->zparm, instance->length, instance->pixels);
}
void DLM_APIENTRY crdlm_compile_ZPixCR( GLsizei width, GLsizei height, GLenum format, GLenum type, GLenum ztype, GLint zparm, GLint length, const GLvoid * pixels )
{
	CRDLMContextState *state = CURRENT_STATE();
	struct instanceZPixCR *instance;
	instance = crCalloc(sizeof(struct instanceZPixCR) + crdlm_pointers_ZPixCR(NULL, width, height, format, type, ztype, zparm, length, pixels));
	if (!instance) {
		crdlm_error(__LINE__, __FILE__, GL_OUT_OF_MEMORY,
			"out of memory adding ZPixCR to display list");
		return;
	}
	instance->next = NULL;
	instance->execute = executeZPixCR;
	instance->width = width;
	instance->height = height;
	instance->format = format;
	instance->type = type;
	instance->ztype = ztype;
	instance->zparm = zparm;
	instance->length = length;
	if (pixels == NULL) {
		instance->pixels = NULL;
	}
	else {
		instance->pixels = instance->pixelsData;
	}
	(void) crdlm_pointers_ZPixCR(instance, width, height, format, type, ztype, zparm, length, pixels);
	if (!state->currentListInfo->first) {
		state->currentListInfo->first = (DLMInstanceList *)instance;
	}
	else {
		state->currentListInfo->last->next = (DLMInstanceList *)instance;
	}
	state->currentListInfo->last = (DLMInstanceList *)instance;
}
/********** Dispatch tables following ****************/


void crdlm_setup_compile_dispatcher(SPUDispatchTable *t)
{
	crSPUChangeInterface(t, (void *) t->Accum, crdlm_compile_Accum);
	crSPUChangeInterface(t, (void *) t->ActiveTextureARB, crdlm_compile_ActiveTextureARB);
	crSPUChangeInterface(t, (void *) t->AlphaFunc, crdlm_compile_AlphaFunc);
/*	passAreProgramsResidentNV,*/
/*	passAreTexturesResident,*/
	crSPUChangeInterface(t, (void *) t->ArrayElement, crdlm_compile_ArrayElement);
/*	passBarrierCreateCR,*/
/*	passBarrierDestroyCR,*/
/*	passBarrierExecCR,*/
	crSPUChangeInterface(t, (void *) t->Begin, crdlm_compile_Begin);
	crSPUChangeInterface(t, (void *) t->BeginQueryARB, crdlm_compile_BeginQueryARB);
/*	passBindBufferARB,*/
	crSPUChangeInterface(t, (void *) t->BindProgramARB, crdlm_compile_BindProgramARB);
	crSPUChangeInterface(t, (void *) t->BindProgramNV, crdlm_compile_BindProgramNV);
	crSPUChangeInterface(t, (void *) t->BindTexture, crdlm_compile_BindTexture);
	crSPUChangeInterface(t, (void *) t->Bitmap, crdlm_compile_Bitmap);
	crSPUChangeInterface(t, (void *) t->BlendColorEXT, crdlm_compile_BlendColorEXT);
	crSPUChangeInterface(t, (void *) t->BlendEquationEXT, crdlm_compile_BlendEquationEXT);
	crSPUChangeInterface(t, (void *) t->BlendFunc, crdlm_compile_BlendFunc);
	crSPUChangeInterface(t, (void *) t->BlendFuncSeparateEXT, crdlm_compile_BlendFuncSeparateEXT);
/*	passBoundsInfoCR,*/
/*	passBufferDataARB,*/
/*	passBufferSubDataARB,*/
	crSPUChangeInterface(t, (void *) t->CallList, crdlm_compile_CallList);
	crSPUChangeInterface(t, (void *) t->CallLists, crdlm_compile_CallLists);
/*	passChromiumParameterfCR,*/
/*	passChromiumParameteriCR,*/
/*	passChromiumParametervCR,*/
	crSPUChangeInterface(t, (void *) t->Clear, crdlm_compile_Clear);
	crSPUChangeInterface(t, (void *) t->ClearAccum, crdlm_compile_ClearAccum);
	crSPUChangeInterface(t, (void *) t->ClearColor, crdlm_compile_ClearColor);
	crSPUChangeInterface(t, (void *) t->ClearDepth, crdlm_compile_ClearDepth);
	crSPUChangeInterface(t, (void *) t->ClearIndex, crdlm_compile_ClearIndex);
	crSPUChangeInterface(t, (void *) t->ClearStencil, crdlm_compile_ClearStencil);
/*	passClientActiveTextureARB,*/
	crSPUChangeInterface(t, (void *) t->ClipPlane, crdlm_compile_ClipPlane);
	crSPUChangeInterface(t, (void *) t->Color3b, crdlm_compile_Color3b);
	crSPUChangeInterface(t, (void *) t->Color3bv, crdlm_compile_Color3bv);
	crSPUChangeInterface(t, (void *) t->Color3d, crdlm_compile_Color3d);
	crSPUChangeInterface(t, (void *) t->Color3dv, crdlm_compile_Color3dv);
	crSPUChangeInterface(t, (void *) t->Color3f, crdlm_compile_Color3f);
	crSPUChangeInterface(t, (void *) t->Color3fv, crdlm_compile_Color3fv);
	crSPUChangeInterface(t, (void *) t->Color3i, crdlm_compile_Color3i);
	crSPUChangeInterface(t, (void *) t->Color3iv, crdlm_compile_Color3iv);
	crSPUChangeInterface(t, (void *) t->Color3s, crdlm_compile_Color3s);
	crSPUChangeInterface(t, (void *) t->Color3sv, crdlm_compile_Color3sv);
	crSPUChangeInterface(t, (void *) t->Color3ub, crdlm_compile_Color3ub);
	crSPUChangeInterface(t, (void *) t->Color3ubv, crdlm_compile_Color3ubv);
	crSPUChangeInterface(t, (void *) t->Color3ui, crdlm_compile_Color3ui);
	crSPUChangeInterface(t, (void *) t->Color3uiv, crdlm_compile_Color3uiv);
	crSPUChangeInterface(t, (void *) t->Color3us, crdlm_compile_Color3us);
	crSPUChangeInterface(t, (void *) t->Color3usv, crdlm_compile_Color3usv);
	crSPUChangeInterface(t, (void *) t->Color4b, crdlm_compile_Color4b);
	crSPUChangeInterface(t, (void *) t->Color4bv, crdlm_compile_Color4bv);
	crSPUChangeInterface(t, (void *) t->Color4d, crdlm_compile_Color4d);
	crSPUChangeInterface(t, (void *) t->Color4dv, crdlm_compile_Color4dv);
	crSPUChangeInterface(t, (void *) t->Color4f, crdlm_compile_Color4f);
	crSPUChangeInterface(t, (void *) t->Color4fv, crdlm_compile_Color4fv);
	crSPUChangeInterface(t, (void *) t->Color4i, crdlm_compile_Color4i);
	crSPUChangeInterface(t, (void *) t->Color4iv, crdlm_compile_Color4iv);
	crSPUChangeInterface(t, (void *) t->Color4s, crdlm_compile_Color4s);
	crSPUChangeInterface(t, (void *) t->Color4sv, crdlm_compile_Color4sv);
	crSPUChangeInterface(t, (void *) t->Color4ub, crdlm_compile_Color4ub);
	crSPUChangeInterface(t, (void *) t->Color4ubv, crdlm_compile_Color4ubv);
	crSPUChangeInterface(t, (void *) t->Color4ui, crdlm_compile_Color4ui);
	crSPUChangeInterface(t, (void *) t->Color4uiv, crdlm_compile_Color4uiv);
	crSPUChangeInterface(t, (void *) t->Color4us, crdlm_compile_Color4us);
	crSPUChangeInterface(t, (void *) t->Color4usv, crdlm_compile_Color4usv);
	crSPUChangeInterface(t, (void *) t->ColorMask, crdlm_compile_ColorMask);
	crSPUChangeInterface(t, (void *) t->ColorMaterial, crdlm_compile_ColorMaterial);
/*	passColorPointer,*/
	crSPUChangeInterface(t, (void *) t->CombinerInputNV, crdlm_compile_CombinerInputNV);
	crSPUChangeInterface(t, (void *) t->CombinerOutputNV, crdlm_compile_CombinerOutputNV);
	crSPUChangeInterface(t, (void *) t->CombinerParameterfNV, crdlm_compile_CombinerParameterfNV);
	crSPUChangeInterface(t, (void *) t->CombinerParameterfvNV, crdlm_compile_CombinerParameterfvNV);
	crSPUChangeInterface(t, (void *) t->CombinerParameteriNV, crdlm_compile_CombinerParameteriNV);
	crSPUChangeInterface(t, (void *) t->CombinerParameterivNV, crdlm_compile_CombinerParameterivNV);
	crSPUChangeInterface(t, (void *) t->CombinerStageParameterfvNV, crdlm_compile_CombinerStageParameterfvNV);
	crSPUChangeInterface(t, (void *) t->CompressedTexImage1DARB, crdlm_compile_CompressedTexImage1DARB);
	crSPUChangeInterface(t, (void *) t->CompressedTexImage2DARB, crdlm_compile_CompressedTexImage2DARB);
	crSPUChangeInterface(t, (void *) t->CompressedTexImage3DARB, crdlm_compile_CompressedTexImage3DARB);
	crSPUChangeInterface(t, (void *) t->CompressedTexSubImage1DARB, crdlm_compile_CompressedTexSubImage1DARB);
	crSPUChangeInterface(t, (void *) t->CompressedTexSubImage2DARB, crdlm_compile_CompressedTexSubImage2DARB);
	crSPUChangeInterface(t, (void *) t->CompressedTexSubImage3DARB, crdlm_compile_CompressedTexSubImage3DARB);
	crSPUChangeInterface(t, (void *) t->CopyPixels, crdlm_compile_CopyPixels);
	crSPUChangeInterface(t, (void *) t->CopyTexImage1D, crdlm_compile_CopyTexImage1D);
	crSPUChangeInterface(t, (void *) t->CopyTexImage2D, crdlm_compile_CopyTexImage2D);
	crSPUChangeInterface(t, (void *) t->CopyTexSubImage1D, crdlm_compile_CopyTexSubImage1D);
	crSPUChangeInterface(t, (void *) t->CopyTexSubImage2D, crdlm_compile_CopyTexSubImage2D);
	crSPUChangeInterface(t, (void *) t->CopyTexSubImage3D, crdlm_compile_CopyTexSubImage3D);
/*	passCreateContext,*/
	crSPUChangeInterface(t, (void *) t->CullFace, crdlm_compile_CullFace);
/*	passDeleteBuffersARB,*/
/*	passDeleteFencesNV,*/
/*	passDeleteLists,*/
/*	passDeleteProgramsARB,*/
/*	passDeleteQueriesARB,*/
/*	passDeleteTextures,*/
	crSPUChangeInterface(t, (void *) t->DepthFunc, crdlm_compile_DepthFunc);
	crSPUChangeInterface(t, (void *) t->DepthMask, crdlm_compile_DepthMask);
	crSPUChangeInterface(t, (void *) t->DepthRange, crdlm_compile_DepthRange);
/*	passDestroyContext,*/
	crSPUChangeInterface(t, (void *) t->Disable, crdlm_compile_Disable);
/*	passDisableClientState,*/
/*	passDisableVertexAttribArrayARB,*/
	crSPUChangeInterface(t, (void *) t->DrawArrays, crdlm_compile_DrawArrays);
	crSPUChangeInterface(t, (void *) t->DrawBuffer, crdlm_compile_DrawBuffer);
	crSPUChangeInterface(t, (void *) t->DrawElements, crdlm_compile_DrawElements);
	crSPUChangeInterface(t, (void *) t->DrawPixels, crdlm_compile_DrawPixels);
	crSPUChangeInterface(t, (void *) t->DrawRangeElements, crdlm_compile_DrawRangeElements);
	crSPUChangeInterface(t, (void *) t->EdgeFlag, crdlm_compile_EdgeFlag);
/*	passEdgeFlagPointer,*/
	crSPUChangeInterface(t, (void *) t->EdgeFlagv, crdlm_compile_EdgeFlagv);
	crSPUChangeInterface(t, (void *) t->Enable, crdlm_compile_Enable);
/*	passEnableClientState,*/
/*	passEnableVertexAttribArrayARB,*/
	crSPUChangeInterface(t, (void *) t->End, crdlm_compile_End);
/*	passEndList,*/
	crSPUChangeInterface(t, (void *) t->EndQueryARB, crdlm_compile_EndQueryARB);
	crSPUChangeInterface(t, (void *) t->EvalCoord1d, crdlm_compile_EvalCoord1d);
	crSPUChangeInterface(t, (void *) t->EvalCoord1dv, crdlm_compile_EvalCoord1dv);
	crSPUChangeInterface(t, (void *) t->EvalCoord1f, crdlm_compile_EvalCoord1f);
	crSPUChangeInterface(t, (void *) t->EvalCoord1fv, crdlm_compile_EvalCoord1fv);
	crSPUChangeInterface(t, (void *) t->EvalCoord2d, crdlm_compile_EvalCoord2d);
	crSPUChangeInterface(t, (void *) t->EvalCoord2dv, crdlm_compile_EvalCoord2dv);
	crSPUChangeInterface(t, (void *) t->EvalCoord2f, crdlm_compile_EvalCoord2f);
	crSPUChangeInterface(t, (void *) t->EvalCoord2fv, crdlm_compile_EvalCoord2fv);
	crSPUChangeInterface(t, (void *) t->EvalMesh1, crdlm_compile_EvalMesh1);
	crSPUChangeInterface(t, (void *) t->EvalMesh2, crdlm_compile_EvalMesh2);
	crSPUChangeInterface(t, (void *) t->EvalPoint1, crdlm_compile_EvalPoint1);
	crSPUChangeInterface(t, (void *) t->EvalPoint2, crdlm_compile_EvalPoint2);
	crSPUChangeInterface(t, (void *) t->ExecuteProgramNV, crdlm_compile_ExecuteProgramNV);
/*	passFeedbackBuffer,*/
	crSPUChangeInterface(t, (void *) t->FinalCombinerInputNV, crdlm_compile_FinalCombinerInputNV);
/*	passFinish,*/
	crSPUChangeInterface(t, (void *) t->FinishFenceNV, crdlm_compile_FinishFenceNV);
/*	passFlush,*/
/*	passFlushVertexArrayRangeNV,*/
/*	passFogCoordPointerEXT,*/
	crSPUChangeInterface(t, (void *) t->FogCoorddEXT, crdlm_compile_FogCoorddEXT);
	crSPUChangeInterface(t, (void *) t->FogCoorddvEXT, crdlm_compile_FogCoorddvEXT);
	crSPUChangeInterface(t, (void *) t->FogCoordfEXT, crdlm_compile_FogCoordfEXT);
	crSPUChangeInterface(t, (void *) t->FogCoordfvEXT, crdlm_compile_FogCoordfvEXT);
	crSPUChangeInterface(t, (void *) t->Fogf, crdlm_compile_Fogf);
	crSPUChangeInterface(t, (void *) t->Fogfv, crdlm_compile_Fogfv);
	crSPUChangeInterface(t, (void *) t->Fogi, crdlm_compile_Fogi);
	crSPUChangeInterface(t, (void *) t->Fogiv, crdlm_compile_Fogiv);
	crSPUChangeInterface(t, (void *) t->FrontFace, crdlm_compile_FrontFace);
	crSPUChangeInterface(t, (void *) t->Frustum, crdlm_compile_Frustum);
/*	passGenBuffersARB,*/
/*	passGenFencesNV,*/
/*	passGenLists,*/
/*	passGenProgramsARB,*/
/*	passGenProgramsNV,*/
/*	passGenQueriesARB,*/
/*	passGenTextures,*/
/*	passGetBooleanv,*/
/*	passGetBufferParameterivARB,*/
/*	passGetBufferPointervARB,*/
/*	passGetBufferSubDataARB,*/
/*	passGetChromiumParametervCR,*/
/*	passGetClipPlane,*/
/*	passGetCombinerInputParameterfvNV,*/
/*	passGetCombinerInputParameterivNV,*/
/*	passGetCombinerOutputParameterfvNV,*/
/*	passGetCombinerOutputParameterivNV,*/
/*	passGetCombinerStageParameterfvNV,*/
/*	passGetCompressedTexImageARB,*/
/*	passGetDoublev,*/
/*	passGetError,*/
/*	passGetFenceivNV,*/
/*	passGetFinalCombinerInputParameterfvNV,*/
/*	passGetFinalCombinerInputParameterivNV,*/
/*	passGetFloatv,*/
/*	passGetIntegerv,*/
/*	passGetLightfv,*/
/*	passGetLightiv,*/
/*	passGetMapdv,*/
/*	passGetMapfv,*/
/*	passGetMapiv,*/
/*	passGetMaterialfv,*/
/*	passGetMaterialiv,*/
/*	passGetPixelMapfv,*/
/*	passGetPixelMapuiv,*/
/*	passGetPixelMapusv,*/
/*	passGetPointerv,*/
/*	passGetPolygonStipple,*/
/*	passGetProgramEnvParameterdvARB,*/
/*	passGetProgramEnvParameterfvARB,*/
/*	passGetProgramLocalParameterdvARB,*/
/*	passGetProgramLocalParameterfvARB,*/
/*	passGetProgramNamedParameterdvNV,*/
/*	passGetProgramNamedParameterfvNV,*/
/*	passGetProgramParameterdvNV,*/
/*	passGetProgramParameterfvNV,*/
/*	passGetProgramStringARB,*/
/*	passGetProgramStringNV,*/
/*	passGetProgramivARB,*/
/*	passGetProgramivNV,*/
/*	passGetQueryObjectivARB,*/
/*	passGetQueryObjectuivARB,*/
/*	passGetQueryivARB,*/
/*	passGetString,*/
/*	passGetTexEnvfv,*/
/*	passGetTexEnviv,*/
/*	passGetTexGendv,*/
/*	passGetTexGenfv,*/
/*	passGetTexGeniv,*/
/*	passGetTexImage,*/
/*	passGetTexLevelParameterfv,*/
/*	passGetTexLevelParameteriv,*/
/*	passGetTexParameterfv,*/
/*	passGetTexParameteriv,*/
/*	passGetTrackMatrixivNV,*/
/*	passGetVertexAttribPointervARB,*/
/*	passGetVertexAttribPointervNV,*/
/*	passGetVertexAttribdvARB,*/
/*	passGetVertexAttribdvNV,*/
/*	passGetVertexAttribfvARB,*/
/*	passGetVertexAttribfvNV,*/
/*	passGetVertexAttribivARB,*/
/*	passGetVertexAttribivNV,*/
	crSPUChangeInterface(t, (void *) t->Hint, crdlm_compile_Hint);
	crSPUChangeInterface(t, (void *) t->IndexMask, crdlm_compile_IndexMask);
/*	passIndexPointer,*/
	crSPUChangeInterface(t, (void *) t->Indexd, crdlm_compile_Indexd);
	crSPUChangeInterface(t, (void *) t->Indexdv, crdlm_compile_Indexdv);
	crSPUChangeInterface(t, (void *) t->Indexf, crdlm_compile_Indexf);
	crSPUChangeInterface(t, (void *) t->Indexfv, crdlm_compile_Indexfv);
	crSPUChangeInterface(t, (void *) t->Indexi, crdlm_compile_Indexi);
	crSPUChangeInterface(t, (void *) t->Indexiv, crdlm_compile_Indexiv);
	crSPUChangeInterface(t, (void *) t->Indexs, crdlm_compile_Indexs);
	crSPUChangeInterface(t, (void *) t->Indexsv, crdlm_compile_Indexsv);
	crSPUChangeInterface(t, (void *) t->Indexub, crdlm_compile_Indexub);
	crSPUChangeInterface(t, (void *) t->Indexubv, crdlm_compile_Indexubv);
	crSPUChangeInterface(t, (void *) t->InitNames, crdlm_compile_InitNames);
/*	passInterleavedArrays,*/
/*	passIsBufferARB,*/
/*	passIsEnabled,*/
/*	passIsFenceNV,*/
/*	passIsList,*/
/*	passIsProgramARB,*/
/*	passIsQueryARB,*/
/*	passIsTexture,*/
	crSPUChangeInterface(t, (void *) t->LightModelf, crdlm_compile_LightModelf);
	crSPUChangeInterface(t, (void *) t->LightModelfv, crdlm_compile_LightModelfv);
	crSPUChangeInterface(t, (void *) t->LightModeli, crdlm_compile_LightModeli);
	crSPUChangeInterface(t, (void *) t->LightModeliv, crdlm_compile_LightModeliv);
	crSPUChangeInterface(t, (void *) t->Lightf, crdlm_compile_Lightf);
	crSPUChangeInterface(t, (void *) t->Lightfv, crdlm_compile_Lightfv);
	crSPUChangeInterface(t, (void *) t->Lighti, crdlm_compile_Lighti);
	crSPUChangeInterface(t, (void *) t->Lightiv, crdlm_compile_Lightiv);
	crSPUChangeInterface(t, (void *) t->LineStipple, crdlm_compile_LineStipple);
	crSPUChangeInterface(t, (void *) t->LineWidth, crdlm_compile_LineWidth);
	crSPUChangeInterface(t, (void *) t->ListBase, crdlm_compile_ListBase);
	crSPUChangeInterface(t, (void *) t->LoadIdentity, crdlm_compile_LoadIdentity);
	crSPUChangeInterface(t, (void *) t->LoadMatrixd, crdlm_compile_LoadMatrixd);
	crSPUChangeInterface(t, (void *) t->LoadMatrixf, crdlm_compile_LoadMatrixf);
	crSPUChangeInterface(t, (void *) t->LoadName, crdlm_compile_LoadName);
	crSPUChangeInterface(t, (void *) t->LoadProgramNV, crdlm_compile_LoadProgramNV);
	crSPUChangeInterface(t, (void *) t->LoadTransposeMatrixdARB, crdlm_compile_LoadTransposeMatrixdARB);
	crSPUChangeInterface(t, (void *) t->LoadTransposeMatrixfARB, crdlm_compile_LoadTransposeMatrixfARB);
	crSPUChangeInterface(t, (void *) t->LogicOp, crdlm_compile_LogicOp);
/*	passMakeCurrent,*/
	crSPUChangeInterface(t, (void *) t->Map1d, crdlm_compile_Map1d);
	crSPUChangeInterface(t, (void *) t->Map1f, crdlm_compile_Map1f);
	crSPUChangeInterface(t, (void *) t->Map2d, crdlm_compile_Map2d);
	crSPUChangeInterface(t, (void *) t->Map2f, crdlm_compile_Map2f);
/*	passMapBufferARB,*/
	crSPUChangeInterface(t, (void *) t->MapGrid1d, crdlm_compile_MapGrid1d);
	crSPUChangeInterface(t, (void *) t->MapGrid1f, crdlm_compile_MapGrid1f);
	crSPUChangeInterface(t, (void *) t->MapGrid2d, crdlm_compile_MapGrid2d);
	crSPUChangeInterface(t, (void *) t->MapGrid2f, crdlm_compile_MapGrid2f);
	crSPUChangeInterface(t, (void *) t->Materialf, crdlm_compile_Materialf);
	crSPUChangeInterface(t, (void *) t->Materialfv, crdlm_compile_Materialfv);
	crSPUChangeInterface(t, (void *) t->Materiali, crdlm_compile_Materiali);
	crSPUChangeInterface(t, (void *) t->Materialiv, crdlm_compile_Materialiv);
	crSPUChangeInterface(t, (void *) t->MatrixMode, crdlm_compile_MatrixMode);
	crSPUChangeInterface(t, (void *) t->MultMatrixd, crdlm_compile_MultMatrixd);
	crSPUChangeInterface(t, (void *) t->MultMatrixf, crdlm_compile_MultMatrixf);
	crSPUChangeInterface(t, (void *) t->MultTransposeMatrixdARB, crdlm_compile_MultTransposeMatrixdARB);
	crSPUChangeInterface(t, (void *) t->MultTransposeMatrixfARB, crdlm_compile_MultTransposeMatrixfARB);
	crSPUChangeInterface(t, (void *) t->MultiDrawArraysEXT, crdlm_compile_MultiDrawArraysEXT);
	crSPUChangeInterface(t, (void *) t->MultiDrawElementsEXT, crdlm_compile_MultiDrawElementsEXT);
	crSPUChangeInterface(t, (void *) t->MultiTexCoord1dARB, crdlm_compile_MultiTexCoord1dARB);
	crSPUChangeInterface(t, (void *) t->MultiTexCoord1dvARB, crdlm_compile_MultiTexCoord1dvARB);
	crSPUChangeInterface(t, (void *) t->MultiTexCoord1fARB, crdlm_compile_MultiTexCoord1fARB);
	crSPUChangeInterface(t, (void *) t->MultiTexCoord1fvARB, crdlm_compile_MultiTexCoord1fvARB);
	crSPUChangeInterface(t, (void *) t->MultiTexCoord1iARB, crdlm_compile_MultiTexCoord1iARB);
	crSPUChangeInterface(t, (void *) t->MultiTexCoord1ivARB, crdlm_compile_MultiTexCoord1ivARB);
	crSPUChangeInterface(t, (void *) t->MultiTexCoord1sARB, crdlm_compile_MultiTexCoord1sARB);
	crSPUChangeInterface(t, (void *) t->MultiTexCoord1svARB, crdlm_compile_MultiTexCoord1svARB);
	crSPUChangeInterface(t, (void *) t->MultiTexCoord2dARB, crdlm_compile_MultiTexCoord2dARB);
	crSPUChangeInterface(t, (void *) t->MultiTexCoord2dvARB, crdlm_compile_MultiTexCoord2dvARB);
	crSPUChangeInterface(t, (void *) t->MultiTexCoord2fARB, crdlm_compile_MultiTexCoord2fARB);
	crSPUChangeInterface(t, (void *) t->MultiTexCoord2fvARB, crdlm_compile_MultiTexCoord2fvARB);
	crSPUChangeInterface(t, (void *) t->MultiTexCoord2iARB, crdlm_compile_MultiTexCoord2iARB);
	crSPUChangeInterface(t, (void *) t->MultiTexCoord2ivARB, crdlm_compile_MultiTexCoord2ivARB);
	crSPUChangeInterface(t, (void *) t->MultiTexCoord2sARB, crdlm_compile_MultiTexCoord2sARB);
	crSPUChangeInterface(t, (void *) t->MultiTexCoord2svARB, crdlm_compile_MultiTexCoord2svARB);
	crSPUChangeInterface(t, (void *) t->MultiTexCoord3dARB, crdlm_compile_MultiTexCoord3dARB);
	crSPUChangeInterface(t, (void *) t->MultiTexCoord3dvARB, crdlm_compile_MultiTexCoord3dvARB);
	crSPUChangeInterface(t, (void *) t->MultiTexCoord3fARB, crdlm_compile_MultiTexCoord3fARB);
	crSPUChangeInterface(t, (void *) t->MultiTexCoord3fvARB, crdlm_compile_MultiTexCoord3fvARB);
	crSPUChangeInterface(t, (void *) t->MultiTexCoord3iARB, crdlm_compile_MultiTexCoord3iARB);
	crSPUChangeInterface(t, (void *) t->MultiTexCoord3ivARB, crdlm_compile_MultiTexCoord3ivARB);
	crSPUChangeInterface(t, (void *) t->MultiTexCoord3sARB, crdlm_compile_MultiTexCoord3sARB);
	crSPUChangeInterface(t, (void *) t->MultiTexCoord3svARB, crdlm_compile_MultiTexCoord3svARB);
	crSPUChangeInterface(t, (void *) t->MultiTexCoord4dARB, crdlm_compile_MultiTexCoord4dARB);
	crSPUChangeInterface(t, (void *) t->MultiTexCoord4dvARB, crdlm_compile_MultiTexCoord4dvARB);
	crSPUChangeInterface(t, (void *) t->MultiTexCoord4fARB, crdlm_compile_MultiTexCoord4fARB);
	crSPUChangeInterface(t, (void *) t->MultiTexCoord4fvARB, crdlm_compile_MultiTexCoord4fvARB);
	crSPUChangeInterface(t, (void *) t->MultiTexCoord4iARB, crdlm_compile_MultiTexCoord4iARB);
	crSPUChangeInterface(t, (void *) t->MultiTexCoord4ivARB, crdlm_compile_MultiTexCoord4ivARB);
	crSPUChangeInterface(t, (void *) t->MultiTexCoord4sARB, crdlm_compile_MultiTexCoord4sARB);
	crSPUChangeInterface(t, (void *) t->MultiTexCoord4svARB, crdlm_compile_MultiTexCoord4svARB);
/*	passNewList,*/
	crSPUChangeInterface(t, (void *) t->Normal3b, crdlm_compile_Normal3b);
	crSPUChangeInterface(t, (void *) t->Normal3bv, crdlm_compile_Normal3bv);
	crSPUChangeInterface(t, (void *) t->Normal3d, crdlm_compile_Normal3d);
	crSPUChangeInterface(t, (void *) t->Normal3dv, crdlm_compile_Normal3dv);
	crSPUChangeInterface(t, (void *) t->Normal3f, crdlm_compile_Normal3f);
	crSPUChangeInterface(t, (void *) t->Normal3fv, crdlm_compile_Normal3fv);
	crSPUChangeInterface(t, (void *) t->Normal3i, crdlm_compile_Normal3i);
	crSPUChangeInterface(t, (void *) t->Normal3iv, crdlm_compile_Normal3iv);
	crSPUChangeInterface(t, (void *) t->Normal3s, crdlm_compile_Normal3s);
	crSPUChangeInterface(t, (void *) t->Normal3sv, crdlm_compile_Normal3sv);
/*	passNormalPointer,*/
	crSPUChangeInterface(t, (void *) t->Ortho, crdlm_compile_Ortho);
	crSPUChangeInterface(t, (void *) t->PassThrough, crdlm_compile_PassThrough);
	crSPUChangeInterface(t, (void *) t->PixelMapfv, crdlm_compile_PixelMapfv);
	crSPUChangeInterface(t, (void *) t->PixelMapuiv, crdlm_compile_PixelMapuiv);
	crSPUChangeInterface(t, (void *) t->PixelMapusv, crdlm_compile_PixelMapusv);
/*	passPixelStoref,*/
/*	passPixelStorei,*/
	crSPUChangeInterface(t, (void *) t->PixelTransferf, crdlm_compile_PixelTransferf);
	crSPUChangeInterface(t, (void *) t->PixelTransferi, crdlm_compile_PixelTransferi);
	crSPUChangeInterface(t, (void *) t->PixelZoom, crdlm_compile_PixelZoom);
	crSPUChangeInterface(t, (void *) t->PointParameterfARB, crdlm_compile_PointParameterfARB);
	crSPUChangeInterface(t, (void *) t->PointParameterfvARB, crdlm_compile_PointParameterfvARB);
	crSPUChangeInterface(t, (void *) t->PointParameteri, crdlm_compile_PointParameteri);
	crSPUChangeInterface(t, (void *) t->PointParameteriv, crdlm_compile_PointParameteriv);
	crSPUChangeInterface(t, (void *) t->PointSize, crdlm_compile_PointSize);
	crSPUChangeInterface(t, (void *) t->PolygonMode, crdlm_compile_PolygonMode);
	crSPUChangeInterface(t, (void *) t->PolygonOffset, crdlm_compile_PolygonOffset);
	crSPUChangeInterface(t, (void *) t->PolygonStipple, crdlm_compile_PolygonStipple);
	crSPUChangeInterface(t, (void *) t->PopAttrib, crdlm_compile_PopAttrib);
/*	passPopClientAttrib,*/
	crSPUChangeInterface(t, (void *) t->PopMatrix, crdlm_compile_PopMatrix);
	crSPUChangeInterface(t, (void *) t->PopName, crdlm_compile_PopName);
	crSPUChangeInterface(t, (void *) t->PrioritizeTextures, crdlm_compile_PrioritizeTextures);
	crSPUChangeInterface(t, (void *) t->ProgramEnvParameter4dARB, crdlm_compile_ProgramEnvParameter4dARB);
	crSPUChangeInterface(t, (void *) t->ProgramEnvParameter4dvARB, crdlm_compile_ProgramEnvParameter4dvARB);
	crSPUChangeInterface(t, (void *) t->ProgramEnvParameter4fARB, crdlm_compile_ProgramEnvParameter4fARB);
	crSPUChangeInterface(t, (void *) t->ProgramEnvParameter4fvARB, crdlm_compile_ProgramEnvParameter4fvARB);
	crSPUChangeInterface(t, (void *) t->ProgramLocalParameter4dARB, crdlm_compile_ProgramLocalParameter4dARB);
	crSPUChangeInterface(t, (void *) t->ProgramLocalParameter4dvARB, crdlm_compile_ProgramLocalParameter4dvARB);
	crSPUChangeInterface(t, (void *) t->ProgramLocalParameter4fARB, crdlm_compile_ProgramLocalParameter4fARB);
	crSPUChangeInterface(t, (void *) t->ProgramLocalParameter4fvARB, crdlm_compile_ProgramLocalParameter4fvARB);
	crSPUChangeInterface(t, (void *) t->ProgramNamedParameter4dNV, crdlm_compile_ProgramNamedParameter4dNV);
	crSPUChangeInterface(t, (void *) t->ProgramNamedParameter4dvNV, crdlm_compile_ProgramNamedParameter4dvNV);
	crSPUChangeInterface(t, (void *) t->ProgramNamedParameter4fNV, crdlm_compile_ProgramNamedParameter4fNV);
	crSPUChangeInterface(t, (void *) t->ProgramNamedParameter4fvNV, crdlm_compile_ProgramNamedParameter4fvNV);
	crSPUChangeInterface(t, (void *) t->ProgramParameter4dNV, crdlm_compile_ProgramParameter4dNV);
	crSPUChangeInterface(t, (void *) t->ProgramParameter4dvNV, crdlm_compile_ProgramParameter4dvNV);
	crSPUChangeInterface(t, (void *) t->ProgramParameter4fNV, crdlm_compile_ProgramParameter4fNV);
	crSPUChangeInterface(t, (void *) t->ProgramParameter4fvNV, crdlm_compile_ProgramParameter4fvNV);
	crSPUChangeInterface(t, (void *) t->ProgramParameters4dvNV, crdlm_compile_ProgramParameters4dvNV);
	crSPUChangeInterface(t, (void *) t->ProgramParameters4fvNV, crdlm_compile_ProgramParameters4fvNV);
	crSPUChangeInterface(t, (void *) t->ProgramStringARB, crdlm_compile_ProgramStringARB);
	crSPUChangeInterface(t, (void *) t->PushAttrib, crdlm_compile_PushAttrib);
/*	passPushClientAttrib,*/
	crSPUChangeInterface(t, (void *) t->PushMatrix, crdlm_compile_PushMatrix);
	crSPUChangeInterface(t, (void *) t->PushName, crdlm_compile_PushName);
	crSPUChangeInterface(t, (void *) t->RasterPos2d, crdlm_compile_RasterPos2d);
	crSPUChangeInterface(t, (void *) t->RasterPos2dv, crdlm_compile_RasterPos2dv);
	crSPUChangeInterface(t, (void *) t->RasterPos2f, crdlm_compile_RasterPos2f);
	crSPUChangeInterface(t, (void *) t->RasterPos2fv, crdlm_compile_RasterPos2fv);
	crSPUChangeInterface(t, (void *) t->RasterPos2i, crdlm_compile_RasterPos2i);
	crSPUChangeInterface(t, (void *) t->RasterPos2iv, crdlm_compile_RasterPos2iv);
	crSPUChangeInterface(t, (void *) t->RasterPos2s, crdlm_compile_RasterPos2s);
	crSPUChangeInterface(t, (void *) t->RasterPos2sv, crdlm_compile_RasterPos2sv);
	crSPUChangeInterface(t, (void *) t->RasterPos3d, crdlm_compile_RasterPos3d);
	crSPUChangeInterface(t, (void *) t->RasterPos3dv, crdlm_compile_RasterPos3dv);
	crSPUChangeInterface(t, (void *) t->RasterPos3f, crdlm_compile_RasterPos3f);
	crSPUChangeInterface(t, (void *) t->RasterPos3fv, crdlm_compile_RasterPos3fv);
	crSPUChangeInterface(t, (void *) t->RasterPos3i, crdlm_compile_RasterPos3i);
	crSPUChangeInterface(t, (void *) t->RasterPos3iv, crdlm_compile_RasterPos3iv);
	crSPUChangeInterface(t, (void *) t->RasterPos3s, crdlm_compile_RasterPos3s);
	crSPUChangeInterface(t, (void *) t->RasterPos3sv, crdlm_compile_RasterPos3sv);
	crSPUChangeInterface(t, (void *) t->RasterPos4d, crdlm_compile_RasterPos4d);
	crSPUChangeInterface(t, (void *) t->RasterPos4dv, crdlm_compile_RasterPos4dv);
	crSPUChangeInterface(t, (void *) t->RasterPos4f, crdlm_compile_RasterPos4f);
	crSPUChangeInterface(t, (void *) t->RasterPos4fv, crdlm_compile_RasterPos4fv);
	crSPUChangeInterface(t, (void *) t->RasterPos4i, crdlm_compile_RasterPos4i);
	crSPUChangeInterface(t, (void *) t->RasterPos4iv, crdlm_compile_RasterPos4iv);
	crSPUChangeInterface(t, (void *) t->RasterPos4s, crdlm_compile_RasterPos4s);
	crSPUChangeInterface(t, (void *) t->RasterPos4sv, crdlm_compile_RasterPos4sv);
	crSPUChangeInterface(t, (void *) t->ReadBuffer, crdlm_compile_ReadBuffer);
/*	passReadPixels,*/
	crSPUChangeInterface(t, (void *) t->Rectd, crdlm_compile_Rectd);
	crSPUChangeInterface(t, (void *) t->Rectdv, crdlm_compile_Rectdv);
	crSPUChangeInterface(t, (void *) t->Rectf, crdlm_compile_Rectf);
	crSPUChangeInterface(t, (void *) t->Rectfv, crdlm_compile_Rectfv);
	crSPUChangeInterface(t, (void *) t->Recti, crdlm_compile_Recti);
	crSPUChangeInterface(t, (void *) t->Rectiv, crdlm_compile_Rectiv);
	crSPUChangeInterface(t, (void *) t->Rects, crdlm_compile_Rects);
	crSPUChangeInterface(t, (void *) t->Rectsv, crdlm_compile_Rectsv);
/*	passRenderMode,*/
	crSPUChangeInterface(t, (void *) t->RequestResidentProgramsNV, crdlm_compile_RequestResidentProgramsNV);
	crSPUChangeInterface(t, (void *) t->Rotated, crdlm_compile_Rotated);
	crSPUChangeInterface(t, (void *) t->Rotatef, crdlm_compile_Rotatef);
	crSPUChangeInterface(t, (void *) t->SampleCoverageARB, crdlm_compile_SampleCoverageARB);
	crSPUChangeInterface(t, (void *) t->Scaled, crdlm_compile_Scaled);
	crSPUChangeInterface(t, (void *) t->Scalef, crdlm_compile_Scalef);
	crSPUChangeInterface(t, (void *) t->Scissor, crdlm_compile_Scissor);
	crSPUChangeInterface(t, (void *) t->SecondaryColor3bEXT, crdlm_compile_SecondaryColor3bEXT);
	crSPUChangeInterface(t, (void *) t->SecondaryColor3bvEXT, crdlm_compile_SecondaryColor3bvEXT);
	crSPUChangeInterface(t, (void *) t->SecondaryColor3dEXT, crdlm_compile_SecondaryColor3dEXT);
	crSPUChangeInterface(t, (void *) t->SecondaryColor3dvEXT, crdlm_compile_SecondaryColor3dvEXT);
	crSPUChangeInterface(t, (void *) t->SecondaryColor3fEXT, crdlm_compile_SecondaryColor3fEXT);
	crSPUChangeInterface(t, (void *) t->SecondaryColor3fvEXT, crdlm_compile_SecondaryColor3fvEXT);
	crSPUChangeInterface(t, (void *) t->SecondaryColor3iEXT, crdlm_compile_SecondaryColor3iEXT);
	crSPUChangeInterface(t, (void *) t->SecondaryColor3ivEXT, crdlm_compile_SecondaryColor3ivEXT);
	crSPUChangeInterface(t, (void *) t->SecondaryColor3sEXT, crdlm_compile_SecondaryColor3sEXT);
	crSPUChangeInterface(t, (void *) t->SecondaryColor3svEXT, crdlm_compile_SecondaryColor3svEXT);
	crSPUChangeInterface(t, (void *) t->SecondaryColor3ubEXT, crdlm_compile_SecondaryColor3ubEXT);
	crSPUChangeInterface(t, (void *) t->SecondaryColor3ubvEXT, crdlm_compile_SecondaryColor3ubvEXT);
	crSPUChangeInterface(t, (void *) t->SecondaryColor3uiEXT, crdlm_compile_SecondaryColor3uiEXT);
	crSPUChangeInterface(t, (void *) t->SecondaryColor3uivEXT, crdlm_compile_SecondaryColor3uivEXT);
	crSPUChangeInterface(t, (void *) t->SecondaryColor3usEXT, crdlm_compile_SecondaryColor3usEXT);
	crSPUChangeInterface(t, (void *) t->SecondaryColor3usvEXT, crdlm_compile_SecondaryColor3usvEXT);
/*	passSecondaryColorPointerEXT,*/
/*	passSelectBuffer,*/
/*	passSemaphoreCreateCR,*/
/*	passSemaphoreDestroyCR,*/
/*	passSemaphorePCR,*/
/*	passSemaphoreVCR,*/
	crSPUChangeInterface(t, (void *) t->SetFenceNV, crdlm_compile_SetFenceNV);
	crSPUChangeInterface(t, (void *) t->ShadeModel, crdlm_compile_ShadeModel);
	crSPUChangeInterface(t, (void *) t->StencilFunc, crdlm_compile_StencilFunc);
	crSPUChangeInterface(t, (void *) t->StencilMask, crdlm_compile_StencilMask);
	crSPUChangeInterface(t, (void *) t->StencilOp, crdlm_compile_StencilOp);
/*	passSwapBuffers,*/
/*	passTestFenceNV,*/
	crSPUChangeInterface(t, (void *) t->TexCoord1d, crdlm_compile_TexCoord1d);
	crSPUChangeInterface(t, (void *) t->TexCoord1dv, crdlm_compile_TexCoord1dv);
	crSPUChangeInterface(t, (void *) t->TexCoord1f, crdlm_compile_TexCoord1f);
	crSPUChangeInterface(t, (void *) t->TexCoord1fv, crdlm_compile_TexCoord1fv);
	crSPUChangeInterface(t, (void *) t->TexCoord1i, crdlm_compile_TexCoord1i);
	crSPUChangeInterface(t, (void *) t->TexCoord1iv, crdlm_compile_TexCoord1iv);
	crSPUChangeInterface(t, (void *) t->TexCoord1s, crdlm_compile_TexCoord1s);
	crSPUChangeInterface(t, (void *) t->TexCoord1sv, crdlm_compile_TexCoord1sv);
	crSPUChangeInterface(t, (void *) t->TexCoord2d, crdlm_compile_TexCoord2d);
	crSPUChangeInterface(t, (void *) t->TexCoord2dv, crdlm_compile_TexCoord2dv);
	crSPUChangeInterface(t, (void *) t->TexCoord2f, crdlm_compile_TexCoord2f);
	crSPUChangeInterface(t, (void *) t->TexCoord2fv, crdlm_compile_TexCoord2fv);
	crSPUChangeInterface(t, (void *) t->TexCoord2i, crdlm_compile_TexCoord2i);
	crSPUChangeInterface(t, (void *) t->TexCoord2iv, crdlm_compile_TexCoord2iv);
	crSPUChangeInterface(t, (void *) t->TexCoord2s, crdlm_compile_TexCoord2s);
	crSPUChangeInterface(t, (void *) t->TexCoord2sv, crdlm_compile_TexCoord2sv);
	crSPUChangeInterface(t, (void *) t->TexCoord3d, crdlm_compile_TexCoord3d);
	crSPUChangeInterface(t, (void *) t->TexCoord3dv, crdlm_compile_TexCoord3dv);
	crSPUChangeInterface(t, (void *) t->TexCoord3f, crdlm_compile_TexCoord3f);
	crSPUChangeInterface(t, (void *) t->TexCoord3fv, crdlm_compile_TexCoord3fv);
	crSPUChangeInterface(t, (void *) t->TexCoord3i, crdlm_compile_TexCoord3i);
	crSPUChangeInterface(t, (void *) t->TexCoord3iv, crdlm_compile_TexCoord3iv);
	crSPUChangeInterface(t, (void *) t->TexCoord3s, crdlm_compile_TexCoord3s);
	crSPUChangeInterface(t, (void *) t->TexCoord3sv, crdlm_compile_TexCoord3sv);
	crSPUChangeInterface(t, (void *) t->TexCoord4d, crdlm_compile_TexCoord4d);
	crSPUChangeInterface(t, (void *) t->TexCoord4dv, crdlm_compile_TexCoord4dv);
	crSPUChangeInterface(t, (void *) t->TexCoord4f, crdlm_compile_TexCoord4f);
	crSPUChangeInterface(t, (void *) t->TexCoord4fv, crdlm_compile_TexCoord4fv);
	crSPUChangeInterface(t, (void *) t->TexCoord4i, crdlm_compile_TexCoord4i);
	crSPUChangeInterface(t, (void *) t->TexCoord4iv, crdlm_compile_TexCoord4iv);
	crSPUChangeInterface(t, (void *) t->TexCoord4s, crdlm_compile_TexCoord4s);
	crSPUChangeInterface(t, (void *) t->TexCoord4sv, crdlm_compile_TexCoord4sv);
/*	passTexCoordPointer,*/
	crSPUChangeInterface(t, (void *) t->TexEnvf, crdlm_compile_TexEnvf);
	crSPUChangeInterface(t, (void *) t->TexEnvfv, crdlm_compile_TexEnvfv);
	crSPUChangeInterface(t, (void *) t->TexEnvi, crdlm_compile_TexEnvi);
	crSPUChangeInterface(t, (void *) t->TexEnviv, crdlm_compile_TexEnviv);
	crSPUChangeInterface(t, (void *) t->TexGend, crdlm_compile_TexGend);
	crSPUChangeInterface(t, (void *) t->TexGendv, crdlm_compile_TexGendv);
	crSPUChangeInterface(t, (void *) t->TexGenf, crdlm_compile_TexGenf);
	crSPUChangeInterface(t, (void *) t->TexGenfv, crdlm_compile_TexGenfv);
	crSPUChangeInterface(t, (void *) t->TexGeni, crdlm_compile_TexGeni);
	crSPUChangeInterface(t, (void *) t->TexGeniv, crdlm_compile_TexGeniv);
	crSPUChangeInterface(t, (void *) t->TexImage1D, crdlm_compile_TexImage1D);
	crSPUChangeInterface(t, (void *) t->TexImage2D, crdlm_compile_TexImage2D);
	crSPUChangeInterface(t, (void *) t->TexImage3D, crdlm_compile_TexImage3D);
	crSPUChangeInterface(t, (void *) t->TexImage3DEXT, crdlm_compile_TexImage3DEXT);
	crSPUChangeInterface(t, (void *) t->TexParameterf, crdlm_compile_TexParameterf);
	crSPUChangeInterface(t, (void *) t->TexParameterfv, crdlm_compile_TexParameterfv);
	crSPUChangeInterface(t, (void *) t->TexParameteri, crdlm_compile_TexParameteri);
	crSPUChangeInterface(t, (void *) t->TexParameteriv, crdlm_compile_TexParameteriv);
	crSPUChangeInterface(t, (void *) t->TexSubImage1D, crdlm_compile_TexSubImage1D);
	crSPUChangeInterface(t, (void *) t->TexSubImage2D, crdlm_compile_TexSubImage2D);
	crSPUChangeInterface(t, (void *) t->TexSubImage3D, crdlm_compile_TexSubImage3D);
	crSPUChangeInterface(t, (void *) t->TrackMatrixNV, crdlm_compile_TrackMatrixNV);
	crSPUChangeInterface(t, (void *) t->Translated, crdlm_compile_Translated);
	crSPUChangeInterface(t, (void *) t->Translatef, crdlm_compile_Translatef);
/*	passUnmapBufferARB,*/
	crSPUChangeInterface(t, (void *) t->Vertex2d, crdlm_compile_Vertex2d);
	crSPUChangeInterface(t, (void *) t->Vertex2dv, crdlm_compile_Vertex2dv);
	crSPUChangeInterface(t, (void *) t->Vertex2f, crdlm_compile_Vertex2f);
	crSPUChangeInterface(t, (void *) t->Vertex2fv, crdlm_compile_Vertex2fv);
	crSPUChangeInterface(t, (void *) t->Vertex2i, crdlm_compile_Vertex2i);
	crSPUChangeInterface(t, (void *) t->Vertex2iv, crdlm_compile_Vertex2iv);
	crSPUChangeInterface(t, (void *) t->Vertex2s, crdlm_compile_Vertex2s);
	crSPUChangeInterface(t, (void *) t->Vertex2sv, crdlm_compile_Vertex2sv);
	crSPUChangeInterface(t, (void *) t->Vertex3d, crdlm_compile_Vertex3d);
	crSPUChangeInterface(t, (void *) t->Vertex3dv, crdlm_compile_Vertex3dv);
	crSPUChangeInterface(t, (void *) t->Vertex3f, crdlm_compile_Vertex3f);
	crSPUChangeInterface(t, (void *) t->Vertex3fv, crdlm_compile_Vertex3fv);
	crSPUChangeInterface(t, (void *) t->Vertex3i, crdlm_compile_Vertex3i);
	crSPUChangeInterface(t, (void *) t->Vertex3iv, crdlm_compile_Vertex3iv);
	crSPUChangeInterface(t, (void *) t->Vertex3s, crdlm_compile_Vertex3s);
	crSPUChangeInterface(t, (void *) t->Vertex3sv, crdlm_compile_Vertex3sv);
	crSPUChangeInterface(t, (void *) t->Vertex4d, crdlm_compile_Vertex4d);
	crSPUChangeInterface(t, (void *) t->Vertex4dv, crdlm_compile_Vertex4dv);
	crSPUChangeInterface(t, (void *) t->Vertex4f, crdlm_compile_Vertex4f);
	crSPUChangeInterface(t, (void *) t->Vertex4fv, crdlm_compile_Vertex4fv);
	crSPUChangeInterface(t, (void *) t->Vertex4i, crdlm_compile_Vertex4i);
	crSPUChangeInterface(t, (void *) t->Vertex4iv, crdlm_compile_Vertex4iv);
	crSPUChangeInterface(t, (void *) t->Vertex4s, crdlm_compile_Vertex4s);
	crSPUChangeInterface(t, (void *) t->Vertex4sv, crdlm_compile_Vertex4sv);
/*	passVertexArrayRangeNV,*/
	crSPUChangeInterface(t, (void *) t->VertexAttrib1dARB, crdlm_compile_VertexAttrib1dARB);
	crSPUChangeInterface(t, (void *) t->VertexAttrib1dvARB, crdlm_compile_VertexAttrib1dvARB);
	crSPUChangeInterface(t, (void *) t->VertexAttrib1fARB, crdlm_compile_VertexAttrib1fARB);
	crSPUChangeInterface(t, (void *) t->VertexAttrib1fvARB, crdlm_compile_VertexAttrib1fvARB);
	crSPUChangeInterface(t, (void *) t->VertexAttrib1sARB, crdlm_compile_VertexAttrib1sARB);
	crSPUChangeInterface(t, (void *) t->VertexAttrib1svARB, crdlm_compile_VertexAttrib1svARB);
	crSPUChangeInterface(t, (void *) t->VertexAttrib2dARB, crdlm_compile_VertexAttrib2dARB);
	crSPUChangeInterface(t, (void *) t->VertexAttrib2dvARB, crdlm_compile_VertexAttrib2dvARB);
	crSPUChangeInterface(t, (void *) t->VertexAttrib2fARB, crdlm_compile_VertexAttrib2fARB);
	crSPUChangeInterface(t, (void *) t->VertexAttrib2fvARB, crdlm_compile_VertexAttrib2fvARB);
	crSPUChangeInterface(t, (void *) t->VertexAttrib2sARB, crdlm_compile_VertexAttrib2sARB);
	crSPUChangeInterface(t, (void *) t->VertexAttrib2svARB, crdlm_compile_VertexAttrib2svARB);
	crSPUChangeInterface(t, (void *) t->VertexAttrib3dARB, crdlm_compile_VertexAttrib3dARB);
	crSPUChangeInterface(t, (void *) t->VertexAttrib3dvARB, crdlm_compile_VertexAttrib3dvARB);
	crSPUChangeInterface(t, (void *) t->VertexAttrib3fARB, crdlm_compile_VertexAttrib3fARB);
	crSPUChangeInterface(t, (void *) t->VertexAttrib3fvARB, crdlm_compile_VertexAttrib3fvARB);
	crSPUChangeInterface(t, (void *) t->VertexAttrib3sARB, crdlm_compile_VertexAttrib3sARB);
	crSPUChangeInterface(t, (void *) t->VertexAttrib3svARB, crdlm_compile_VertexAttrib3svARB);
	crSPUChangeInterface(t, (void *) t->VertexAttrib4NbvARB, crdlm_compile_VertexAttrib4NbvARB);
	crSPUChangeInterface(t, (void *) t->VertexAttrib4NivARB, crdlm_compile_VertexAttrib4NivARB);
	crSPUChangeInterface(t, (void *) t->VertexAttrib4NsvARB, crdlm_compile_VertexAttrib4NsvARB);
	crSPUChangeInterface(t, (void *) t->VertexAttrib4NubARB, crdlm_compile_VertexAttrib4NubARB);
	crSPUChangeInterface(t, (void *) t->VertexAttrib4NubvARB, crdlm_compile_VertexAttrib4NubvARB);
	crSPUChangeInterface(t, (void *) t->VertexAttrib4NuivARB, crdlm_compile_VertexAttrib4NuivARB);
	crSPUChangeInterface(t, (void *) t->VertexAttrib4NusvARB, crdlm_compile_VertexAttrib4NusvARB);
	crSPUChangeInterface(t, (void *) t->VertexAttrib4bvARB, crdlm_compile_VertexAttrib4bvARB);
	crSPUChangeInterface(t, (void *) t->VertexAttrib4dARB, crdlm_compile_VertexAttrib4dARB);
	crSPUChangeInterface(t, (void *) t->VertexAttrib4dvARB, crdlm_compile_VertexAttrib4dvARB);
	crSPUChangeInterface(t, (void *) t->VertexAttrib4fARB, crdlm_compile_VertexAttrib4fARB);
	crSPUChangeInterface(t, (void *) t->VertexAttrib4fvARB, crdlm_compile_VertexAttrib4fvARB);
	crSPUChangeInterface(t, (void *) t->VertexAttrib4ivARB, crdlm_compile_VertexAttrib4ivARB);
	crSPUChangeInterface(t, (void *) t->VertexAttrib4sARB, crdlm_compile_VertexAttrib4sARB);
	crSPUChangeInterface(t, (void *) t->VertexAttrib4svARB, crdlm_compile_VertexAttrib4svARB);
	crSPUChangeInterface(t, (void *) t->VertexAttrib4ubvARB, crdlm_compile_VertexAttrib4ubvARB);
	crSPUChangeInterface(t, (void *) t->VertexAttrib4uivARB, crdlm_compile_VertexAttrib4uivARB);
	crSPUChangeInterface(t, (void *) t->VertexAttrib4usvARB, crdlm_compile_VertexAttrib4usvARB);
/*	passVertexAttribPointerARB,*/
/*	passVertexAttribPointerNV,*/
	crSPUChangeInterface(t, (void *) t->VertexAttribs1dvNV, crdlm_compile_VertexAttribs1dvNV);
	crSPUChangeInterface(t, (void *) t->VertexAttribs1fvNV, crdlm_compile_VertexAttribs1fvNV);
	crSPUChangeInterface(t, (void *) t->VertexAttribs1svNV, crdlm_compile_VertexAttribs1svNV);
	crSPUChangeInterface(t, (void *) t->VertexAttribs2dvNV, crdlm_compile_VertexAttribs2dvNV);
	crSPUChangeInterface(t, (void *) t->VertexAttribs2fvNV, crdlm_compile_VertexAttribs2fvNV);
	crSPUChangeInterface(t, (void *) t->VertexAttribs2svNV, crdlm_compile_VertexAttribs2svNV);
	crSPUChangeInterface(t, (void *) t->VertexAttribs3dvNV, crdlm_compile_VertexAttribs3dvNV);
	crSPUChangeInterface(t, (void *) t->VertexAttribs3fvNV, crdlm_compile_VertexAttribs3fvNV);
	crSPUChangeInterface(t, (void *) t->VertexAttribs3svNV, crdlm_compile_VertexAttribs3svNV);
	crSPUChangeInterface(t, (void *) t->VertexAttribs4dvNV, crdlm_compile_VertexAttribs4dvNV);
	crSPUChangeInterface(t, (void *) t->VertexAttribs4fvNV, crdlm_compile_VertexAttribs4fvNV);
	crSPUChangeInterface(t, (void *) t->VertexAttribs4svNV, crdlm_compile_VertexAttribs4svNV);
	crSPUChangeInterface(t, (void *) t->VertexAttribs4ubvNV, crdlm_compile_VertexAttribs4ubvNV);
/*	passVertexPointer,*/
	crSPUChangeInterface(t, (void *) t->Viewport, crdlm_compile_Viewport);
/*	passWindowCreate,*/
/*	passWindowDestroy,*/
	crSPUChangeInterface(t, (void *) t->WindowPos2dARB, crdlm_compile_WindowPos2dARB);
	crSPUChangeInterface(t, (void *) t->WindowPos2dvARB, crdlm_compile_WindowPos2dvARB);
	crSPUChangeInterface(t, (void *) t->WindowPos2fARB, crdlm_compile_WindowPos2fARB);
	crSPUChangeInterface(t, (void *) t->WindowPos2fvARB, crdlm_compile_WindowPos2fvARB);
	crSPUChangeInterface(t, (void *) t->WindowPos2iARB, crdlm_compile_WindowPos2iARB);
	crSPUChangeInterface(t, (void *) t->WindowPos2ivARB, crdlm_compile_WindowPos2ivARB);
	crSPUChangeInterface(t, (void *) t->WindowPos2sARB, crdlm_compile_WindowPos2sARB);
	crSPUChangeInterface(t, (void *) t->WindowPos2svARB, crdlm_compile_WindowPos2svARB);
	crSPUChangeInterface(t, (void *) t->WindowPos3dARB, crdlm_compile_WindowPos3dARB);
	crSPUChangeInterface(t, (void *) t->WindowPos3dvARB, crdlm_compile_WindowPos3dvARB);
	crSPUChangeInterface(t, (void *) t->WindowPos3fARB, crdlm_compile_WindowPos3fARB);
	crSPUChangeInterface(t, (void *) t->WindowPos3fvARB, crdlm_compile_WindowPos3fvARB);
	crSPUChangeInterface(t, (void *) t->WindowPos3iARB, crdlm_compile_WindowPos3iARB);
	crSPUChangeInterface(t, (void *) t->WindowPos3ivARB, crdlm_compile_WindowPos3ivARB);
	crSPUChangeInterface(t, (void *) t->WindowPos3sARB, crdlm_compile_WindowPos3sARB);
	crSPUChangeInterface(t, (void *) t->WindowPos3svARB, crdlm_compile_WindowPos3svARB);
/*	passWindowPosition,*/
/*	passWindowShow,*/
/*	passWindowSize,*/
/*	passWriteback,*/
	crSPUChangeInterface(t, (void *) t->ZPixCR, crdlm_compile_ZPixCR);
}


void crdlm_restore_dispatcher(SPUDispatchTable *t, const SPUDispatchTable *original)
{
	if (t->Accum != original->Accum)
		crSPUChangeInterface(t, (void *) t->Accum, (void *) original->Accum);
	if (t->ActiveTextureARB != original->ActiveTextureARB)
		crSPUChangeInterface(t, (void *) t->ActiveTextureARB, (void *) original->ActiveTextureARB);
	if (t->AlphaFunc != original->AlphaFunc)
		crSPUChangeInterface(t, (void *) t->AlphaFunc, (void *) original->AlphaFunc);
	if (t->AreProgramsResidentNV != original->AreProgramsResidentNV)
		crSPUChangeInterface(t, (void *) t->AreProgramsResidentNV, (void *) original->AreProgramsResidentNV);
	if (t->AreTexturesResident != original->AreTexturesResident)
		crSPUChangeInterface(t, (void *) t->AreTexturesResident, (void *) original->AreTexturesResident);
	if (t->ArrayElement != original->ArrayElement)
		crSPUChangeInterface(t, (void *) t->ArrayElement, (void *) original->ArrayElement);
	if (t->BarrierCreateCR != original->BarrierCreateCR)
		crSPUChangeInterface(t, (void *) t->BarrierCreateCR, (void *) original->BarrierCreateCR);
	if (t->BarrierDestroyCR != original->BarrierDestroyCR)
		crSPUChangeInterface(t, (void *) t->BarrierDestroyCR, (void *) original->BarrierDestroyCR);
	if (t->BarrierExecCR != original->BarrierExecCR)
		crSPUChangeInterface(t, (void *) t->BarrierExecCR, (void *) original->BarrierExecCR);
	if (t->Begin != original->Begin)
		crSPUChangeInterface(t, (void *) t->Begin, (void *) original->Begin);
	if (t->BeginQueryARB != original->BeginQueryARB)
		crSPUChangeInterface(t, (void *) t->BeginQueryARB, (void *) original->BeginQueryARB);
	if (t->BindBufferARB != original->BindBufferARB)
		crSPUChangeInterface(t, (void *) t->BindBufferARB, (void *) original->BindBufferARB);
	if (t->BindProgramARB != original->BindProgramARB)
		crSPUChangeInterface(t, (void *) t->BindProgramARB, (void *) original->BindProgramARB);
	if (t->BindProgramNV != original->BindProgramNV)
		crSPUChangeInterface(t, (void *) t->BindProgramNV, (void *) original->BindProgramNV);
	if (t->BindTexture != original->BindTexture)
		crSPUChangeInterface(t, (void *) t->BindTexture, (void *) original->BindTexture);
	if (t->Bitmap != original->Bitmap)
		crSPUChangeInterface(t, (void *) t->Bitmap, (void *) original->Bitmap);
	if (t->BlendColorEXT != original->BlendColorEXT)
		crSPUChangeInterface(t, (void *) t->BlendColorEXT, (void *) original->BlendColorEXT);
	if (t->BlendEquationEXT != original->BlendEquationEXT)
		crSPUChangeInterface(t, (void *) t->BlendEquationEXT, (void *) original->BlendEquationEXT);
	if (t->BlendFunc != original->BlendFunc)
		crSPUChangeInterface(t, (void *) t->BlendFunc, (void *) original->BlendFunc);
	if (t->BlendFuncSeparateEXT != original->BlendFuncSeparateEXT)
		crSPUChangeInterface(t, (void *) t->BlendFuncSeparateEXT, (void *) original->BlendFuncSeparateEXT);
	if (t->BoundsInfoCR != original->BoundsInfoCR)
		crSPUChangeInterface(t, (void *) t->BoundsInfoCR, (void *) original->BoundsInfoCR);
	if (t->BufferDataARB != original->BufferDataARB)
		crSPUChangeInterface(t, (void *) t->BufferDataARB, (void *) original->BufferDataARB);
	if (t->BufferSubDataARB != original->BufferSubDataARB)
		crSPUChangeInterface(t, (void *) t->BufferSubDataARB, (void *) original->BufferSubDataARB);
	if (t->CallList != original->CallList)
		crSPUChangeInterface(t, (void *) t->CallList, (void *) original->CallList);
	if (t->CallLists != original->CallLists)
		crSPUChangeInterface(t, (void *) t->CallLists, (void *) original->CallLists);
	if (t->ChromiumParameterfCR != original->ChromiumParameterfCR)
		crSPUChangeInterface(t, (void *) t->ChromiumParameterfCR, (void *) original->ChromiumParameterfCR);
	if (t->ChromiumParameteriCR != original->ChromiumParameteriCR)
		crSPUChangeInterface(t, (void *) t->ChromiumParameteriCR, (void *) original->ChromiumParameteriCR);
	if (t->ChromiumParametervCR != original->ChromiumParametervCR)
		crSPUChangeInterface(t, (void *) t->ChromiumParametervCR, (void *) original->ChromiumParametervCR);
	if (t->Clear != original->Clear)
		crSPUChangeInterface(t, (void *) t->Clear, (void *) original->Clear);
	if (t->ClearAccum != original->ClearAccum)
		crSPUChangeInterface(t, (void *) t->ClearAccum, (void *) original->ClearAccum);
	if (t->ClearColor != original->ClearColor)
		crSPUChangeInterface(t, (void *) t->ClearColor, (void *) original->ClearColor);
	if (t->ClearDepth != original->ClearDepth)
		crSPUChangeInterface(t, (void *) t->ClearDepth, (void *) original->ClearDepth);
	if (t->ClearIndex != original->ClearIndex)
		crSPUChangeInterface(t, (void *) t->ClearIndex, (void *) original->ClearIndex);
	if (t->ClearStencil != original->ClearStencil)
		crSPUChangeInterface(t, (void *) t->ClearStencil, (void *) original->ClearStencil);
	if (t->ClientActiveTextureARB != original->ClientActiveTextureARB)
		crSPUChangeInterface(t, (void *) t->ClientActiveTextureARB, (void *) original->ClientActiveTextureARB);
	if (t->ClipPlane != original->ClipPlane)
		crSPUChangeInterface(t, (void *) t->ClipPlane, (void *) original->ClipPlane);
	if (t->Color3b != original->Color3b)
		crSPUChangeInterface(t, (void *) t->Color3b, (void *) original->Color3b);
	if (t->Color3bv != original->Color3bv)
		crSPUChangeInterface(t, (void *) t->Color3bv, (void *) original->Color3bv);
	if (t->Color3d != original->Color3d)
		crSPUChangeInterface(t, (void *) t->Color3d, (void *) original->Color3d);
	if (t->Color3dv != original->Color3dv)
		crSPUChangeInterface(t, (void *) t->Color3dv, (void *) original->Color3dv);
	if (t->Color3f != original->Color3f)
		crSPUChangeInterface(t, (void *) t->Color3f, (void *) original->Color3f);
	if (t->Color3fv != original->Color3fv)
		crSPUChangeInterface(t, (void *) t->Color3fv, (void *) original->Color3fv);
	if (t->Color3i != original->Color3i)
		crSPUChangeInterface(t, (void *) t->Color3i, (void *) original->Color3i);
	if (t->Color3iv != original->Color3iv)
		crSPUChangeInterface(t, (void *) t->Color3iv, (void *) original->Color3iv);
	if (t->Color3s != original->Color3s)
		crSPUChangeInterface(t, (void *) t->Color3s, (void *) original->Color3s);
	if (t->Color3sv != original->Color3sv)
		crSPUChangeInterface(t, (void *) t->Color3sv, (void *) original->Color3sv);
	if (t->Color3ub != original->Color3ub)
		crSPUChangeInterface(t, (void *) t->Color3ub, (void *) original->Color3ub);
	if (t->Color3ubv != original->Color3ubv)
		crSPUChangeInterface(t, (void *) t->Color3ubv, (void *) original->Color3ubv);
	if (t->Color3ui != original->Color3ui)
		crSPUChangeInterface(t, (void *) t->Color3ui, (void *) original->Color3ui);
	if (t->Color3uiv != original->Color3uiv)
		crSPUChangeInterface(t, (void *) t->Color3uiv, (void *) original->Color3uiv);
	if (t->Color3us != original->Color3us)
		crSPUChangeInterface(t, (void *) t->Color3us, (void *) original->Color3us);
	if (t->Color3usv != original->Color3usv)
		crSPUChangeInterface(t, (void *) t->Color3usv, (void *) original->Color3usv);
	if (t->Color4b != original->Color4b)
		crSPUChangeInterface(t, (void *) t->Color4b, (void *) original->Color4b);
	if (t->Color4bv != original->Color4bv)
		crSPUChangeInterface(t, (void *) t->Color4bv, (void *) original->Color4bv);
	if (t->Color4d != original->Color4d)
		crSPUChangeInterface(t, (void *) t->Color4d, (void *) original->Color4d);
	if (t->Color4dv != original->Color4dv)
		crSPUChangeInterface(t, (void *) t->Color4dv, (void *) original->Color4dv);
	if (t->Color4f != original->Color4f)
		crSPUChangeInterface(t, (void *) t->Color4f, (void *) original->Color4f);
	if (t->Color4fv != original->Color4fv)
		crSPUChangeInterface(t, (void *) t->Color4fv, (void *) original->Color4fv);
	if (t->Color4i != original->Color4i)
		crSPUChangeInterface(t, (void *) t->Color4i, (void *) original->Color4i);
	if (t->Color4iv != original->Color4iv)
		crSPUChangeInterface(t, (void *) t->Color4iv, (void *) original->Color4iv);
	if (t->Color4s != original->Color4s)
		crSPUChangeInterface(t, (void *) t->Color4s, (void *) original->Color4s);
	if (t->Color4sv != original->Color4sv)
		crSPUChangeInterface(t, (void *) t->Color4sv, (void *) original->Color4sv);
	if (t->Color4ub != original->Color4ub)
		crSPUChangeInterface(t, (void *) t->Color4ub, (void *) original->Color4ub);
	if (t->Color4ubv != original->Color4ubv)
		crSPUChangeInterface(t, (void *) t->Color4ubv, (void *) original->Color4ubv);
	if (t->Color4ui != original->Color4ui)
		crSPUChangeInterface(t, (void *) t->Color4ui, (void *) original->Color4ui);
	if (t->Color4uiv != original->Color4uiv)
		crSPUChangeInterface(t, (void *) t->Color4uiv, (void *) original->Color4uiv);
	if (t->Color4us != original->Color4us)
		crSPUChangeInterface(t, (void *) t->Color4us, (void *) original->Color4us);
	if (t->Color4usv != original->Color4usv)
		crSPUChangeInterface(t, (void *) t->Color4usv, (void *) original->Color4usv);
	if (t->ColorMask != original->ColorMask)
		crSPUChangeInterface(t, (void *) t->ColorMask, (void *) original->ColorMask);
	if (t->ColorMaterial != original->ColorMaterial)
		crSPUChangeInterface(t, (void *) t->ColorMaterial, (void *) original->ColorMaterial);
	if (t->ColorPointer != original->ColorPointer)
		crSPUChangeInterface(t, (void *) t->ColorPointer, (void *) original->ColorPointer);
	if (t->CombinerInputNV != original->CombinerInputNV)
		crSPUChangeInterface(t, (void *) t->CombinerInputNV, (void *) original->CombinerInputNV);
	if (t->CombinerOutputNV != original->CombinerOutputNV)
		crSPUChangeInterface(t, (void *) t->CombinerOutputNV, (void *) original->CombinerOutputNV);
	if (t->CombinerParameterfNV != original->CombinerParameterfNV)
		crSPUChangeInterface(t, (void *) t->CombinerParameterfNV, (void *) original->CombinerParameterfNV);
	if (t->CombinerParameterfvNV != original->CombinerParameterfvNV)
		crSPUChangeInterface(t, (void *) t->CombinerParameterfvNV, (void *) original->CombinerParameterfvNV);
	if (t->CombinerParameteriNV != original->CombinerParameteriNV)
		crSPUChangeInterface(t, (void *) t->CombinerParameteriNV, (void *) original->CombinerParameteriNV);
	if (t->CombinerParameterivNV != original->CombinerParameterivNV)
		crSPUChangeInterface(t, (void *) t->CombinerParameterivNV, (void *) original->CombinerParameterivNV);
	if (t->CombinerStageParameterfvNV != original->CombinerStageParameterfvNV)
		crSPUChangeInterface(t, (void *) t->CombinerStageParameterfvNV, (void *) original->CombinerStageParameterfvNV);
	if (t->CompressedTexImage1DARB != original->CompressedTexImage1DARB)
		crSPUChangeInterface(t, (void *) t->CompressedTexImage1DARB, (void *) original->CompressedTexImage1DARB);
	if (t->CompressedTexImage2DARB != original->CompressedTexImage2DARB)
		crSPUChangeInterface(t, (void *) t->CompressedTexImage2DARB, (void *) original->CompressedTexImage2DARB);
	if (t->CompressedTexImage3DARB != original->CompressedTexImage3DARB)
		crSPUChangeInterface(t, (void *) t->CompressedTexImage3DARB, (void *) original->CompressedTexImage3DARB);
	if (t->CompressedTexSubImage1DARB != original->CompressedTexSubImage1DARB)
		crSPUChangeInterface(t, (void *) t->CompressedTexSubImage1DARB, (void *) original->CompressedTexSubImage1DARB);
	if (t->CompressedTexSubImage2DARB != original->CompressedTexSubImage2DARB)
		crSPUChangeInterface(t, (void *) t->CompressedTexSubImage2DARB, (void *) original->CompressedTexSubImage2DARB);
	if (t->CompressedTexSubImage3DARB != original->CompressedTexSubImage3DARB)
		crSPUChangeInterface(t, (void *) t->CompressedTexSubImage3DARB, (void *) original->CompressedTexSubImage3DARB);
	if (t->CopyPixels != original->CopyPixels)
		crSPUChangeInterface(t, (void *) t->CopyPixels, (void *) original->CopyPixels);
	if (t->CopyTexImage1D != original->CopyTexImage1D)
		crSPUChangeInterface(t, (void *) t->CopyTexImage1D, (void *) original->CopyTexImage1D);
	if (t->CopyTexImage2D != original->CopyTexImage2D)
		crSPUChangeInterface(t, (void *) t->CopyTexImage2D, (void *) original->CopyTexImage2D);
	if (t->CopyTexSubImage1D != original->CopyTexSubImage1D)
		crSPUChangeInterface(t, (void *) t->CopyTexSubImage1D, (void *) original->CopyTexSubImage1D);
	if (t->CopyTexSubImage2D != original->CopyTexSubImage2D)
		crSPUChangeInterface(t, (void *) t->CopyTexSubImage2D, (void *) original->CopyTexSubImage2D);
	if (t->CopyTexSubImage3D != original->CopyTexSubImage3D)
		crSPUChangeInterface(t, (void *) t->CopyTexSubImage3D, (void *) original->CopyTexSubImage3D);
	if (t->CreateContext != original->CreateContext)
		crSPUChangeInterface(t, (void *) t->CreateContext, (void *) original->CreateContext);
	if (t->CullFace != original->CullFace)
		crSPUChangeInterface(t, (void *) t->CullFace, (void *) original->CullFace);
	if (t->DeleteBuffersARB != original->DeleteBuffersARB)
		crSPUChangeInterface(t, (void *) t->DeleteBuffersARB, (void *) original->DeleteBuffersARB);
	if (t->DeleteFencesNV != original->DeleteFencesNV)
		crSPUChangeInterface(t, (void *) t->DeleteFencesNV, (void *) original->DeleteFencesNV);
	if (t->DeleteLists != original->DeleteLists)
		crSPUChangeInterface(t, (void *) t->DeleteLists, (void *) original->DeleteLists);
	if (t->DeleteProgramsARB != original->DeleteProgramsARB)
		crSPUChangeInterface(t, (void *) t->DeleteProgramsARB, (void *) original->DeleteProgramsARB);
	if (t->DeleteQueriesARB != original->DeleteQueriesARB)
		crSPUChangeInterface(t, (void *) t->DeleteQueriesARB, (void *) original->DeleteQueriesARB);
	if (t->DeleteTextures != original->DeleteTextures)
		crSPUChangeInterface(t, (void *) t->DeleteTextures, (void *) original->DeleteTextures);
	if (t->DepthFunc != original->DepthFunc)
		crSPUChangeInterface(t, (void *) t->DepthFunc, (void *) original->DepthFunc);
	if (t->DepthMask != original->DepthMask)
		crSPUChangeInterface(t, (void *) t->DepthMask, (void *) original->DepthMask);
	if (t->DepthRange != original->DepthRange)
		crSPUChangeInterface(t, (void *) t->DepthRange, (void *) original->DepthRange);
	if (t->DestroyContext != original->DestroyContext)
		crSPUChangeInterface(t, (void *) t->DestroyContext, (void *) original->DestroyContext);
	if (t->Disable != original->Disable)
		crSPUChangeInterface(t, (void *) t->Disable, (void *) original->Disable);
	if (t->DisableClientState != original->DisableClientState)
		crSPUChangeInterface(t, (void *) t->DisableClientState, (void *) original->DisableClientState);
	if (t->DisableVertexAttribArrayARB != original->DisableVertexAttribArrayARB)
		crSPUChangeInterface(t, (void *) t->DisableVertexAttribArrayARB, (void *) original->DisableVertexAttribArrayARB);
	if (t->DrawArrays != original->DrawArrays)
		crSPUChangeInterface(t, (void *) t->DrawArrays, (void *) original->DrawArrays);
	if (t->DrawBuffer != original->DrawBuffer)
		crSPUChangeInterface(t, (void *) t->DrawBuffer, (void *) original->DrawBuffer);
	if (t->DrawElements != original->DrawElements)
		crSPUChangeInterface(t, (void *) t->DrawElements, (void *) original->DrawElements);
	if (t->DrawPixels != original->DrawPixels)
		crSPUChangeInterface(t, (void *) t->DrawPixels, (void *) original->DrawPixels);
	if (t->DrawRangeElements != original->DrawRangeElements)
		crSPUChangeInterface(t, (void *) t->DrawRangeElements, (void *) original->DrawRangeElements);
	if (t->EdgeFlag != original->EdgeFlag)
		crSPUChangeInterface(t, (void *) t->EdgeFlag, (void *) original->EdgeFlag);
	if (t->EdgeFlagPointer != original->EdgeFlagPointer)
		crSPUChangeInterface(t, (void *) t->EdgeFlagPointer, (void *) original->EdgeFlagPointer);
	if (t->EdgeFlagv != original->EdgeFlagv)
		crSPUChangeInterface(t, (void *) t->EdgeFlagv, (void *) original->EdgeFlagv);
	if (t->Enable != original->Enable)
		crSPUChangeInterface(t, (void *) t->Enable, (void *) original->Enable);
	if (t->EnableClientState != original->EnableClientState)
		crSPUChangeInterface(t, (void *) t->EnableClientState, (void *) original->EnableClientState);
	if (t->EnableVertexAttribArrayARB != original->EnableVertexAttribArrayARB)
		crSPUChangeInterface(t, (void *) t->EnableVertexAttribArrayARB, (void *) original->EnableVertexAttribArrayARB);
	if (t->End != original->End)
		crSPUChangeInterface(t, (void *) t->End, (void *) original->End);
	if (t->EndList != original->EndList)
		crSPUChangeInterface(t, (void *) t->EndList, (void *) original->EndList);
	if (t->EndQueryARB != original->EndQueryARB)
		crSPUChangeInterface(t, (void *) t->EndQueryARB, (void *) original->EndQueryARB);
	if (t->EvalCoord1d != original->EvalCoord1d)
		crSPUChangeInterface(t, (void *) t->EvalCoord1d, (void *) original->EvalCoord1d);
	if (t->EvalCoord1dv != original->EvalCoord1dv)
		crSPUChangeInterface(t, (void *) t->EvalCoord1dv, (void *) original->EvalCoord1dv);
	if (t->EvalCoord1f != original->EvalCoord1f)
		crSPUChangeInterface(t, (void *) t->EvalCoord1f, (void *) original->EvalCoord1f);
	if (t->EvalCoord1fv != original->EvalCoord1fv)
		crSPUChangeInterface(t, (void *) t->EvalCoord1fv, (void *) original->EvalCoord1fv);
	if (t->EvalCoord2d != original->EvalCoord2d)
		crSPUChangeInterface(t, (void *) t->EvalCoord2d, (void *) original->EvalCoord2d);
	if (t->EvalCoord2dv != original->EvalCoord2dv)
		crSPUChangeInterface(t, (void *) t->EvalCoord2dv, (void *) original->EvalCoord2dv);
	if (t->EvalCoord2f != original->EvalCoord2f)
		crSPUChangeInterface(t, (void *) t->EvalCoord2f, (void *) original->EvalCoord2f);
	if (t->EvalCoord2fv != original->EvalCoord2fv)
		crSPUChangeInterface(t, (void *) t->EvalCoord2fv, (void *) original->EvalCoord2fv);
	if (t->EvalMesh1 != original->EvalMesh1)
		crSPUChangeInterface(t, (void *) t->EvalMesh1, (void *) original->EvalMesh1);
	if (t->EvalMesh2 != original->EvalMesh2)
		crSPUChangeInterface(t, (void *) t->EvalMesh2, (void *) original->EvalMesh2);
	if (t->EvalPoint1 != original->EvalPoint1)
		crSPUChangeInterface(t, (void *) t->EvalPoint1, (void *) original->EvalPoint1);
	if (t->EvalPoint2 != original->EvalPoint2)
		crSPUChangeInterface(t, (void *) t->EvalPoint2, (void *) original->EvalPoint2);
	if (t->ExecuteProgramNV != original->ExecuteProgramNV)
		crSPUChangeInterface(t, (void *) t->ExecuteProgramNV, (void *) original->ExecuteProgramNV);
	if (t->FeedbackBuffer != original->FeedbackBuffer)
		crSPUChangeInterface(t, (void *) t->FeedbackBuffer, (void *) original->FeedbackBuffer);
	if (t->FinalCombinerInputNV != original->FinalCombinerInputNV)
		crSPUChangeInterface(t, (void *) t->FinalCombinerInputNV, (void *) original->FinalCombinerInputNV);
	if (t->Finish != original->Finish)
		crSPUChangeInterface(t, (void *) t->Finish, (void *) original->Finish);
	if (t->FinishFenceNV != original->FinishFenceNV)
		crSPUChangeInterface(t, (void *) t->FinishFenceNV, (void *) original->FinishFenceNV);
	if (t->Flush != original->Flush)
		crSPUChangeInterface(t, (void *) t->Flush, (void *) original->Flush);
	if (t->FlushVertexArrayRangeNV != original->FlushVertexArrayRangeNV)
		crSPUChangeInterface(t, (void *) t->FlushVertexArrayRangeNV, (void *) original->FlushVertexArrayRangeNV);
	if (t->FogCoordPointerEXT != original->FogCoordPointerEXT)
		crSPUChangeInterface(t, (void *) t->FogCoordPointerEXT, (void *) original->FogCoordPointerEXT);
	if (t->FogCoorddEXT != original->FogCoorddEXT)
		crSPUChangeInterface(t, (void *) t->FogCoorddEXT, (void *) original->FogCoorddEXT);
	if (t->FogCoorddvEXT != original->FogCoorddvEXT)
		crSPUChangeInterface(t, (void *) t->FogCoorddvEXT, (void *) original->FogCoorddvEXT);
	if (t->FogCoordfEXT != original->FogCoordfEXT)
		crSPUChangeInterface(t, (void *) t->FogCoordfEXT, (void *) original->FogCoordfEXT);
	if (t->FogCoordfvEXT != original->FogCoordfvEXT)
		crSPUChangeInterface(t, (void *) t->FogCoordfvEXT, (void *) original->FogCoordfvEXT);
	if (t->Fogf != original->Fogf)
		crSPUChangeInterface(t, (void *) t->Fogf, (void *) original->Fogf);
	if (t->Fogfv != original->Fogfv)
		crSPUChangeInterface(t, (void *) t->Fogfv, (void *) original->Fogfv);
	if (t->Fogi != original->Fogi)
		crSPUChangeInterface(t, (void *) t->Fogi, (void *) original->Fogi);
	if (t->Fogiv != original->Fogiv)
		crSPUChangeInterface(t, (void *) t->Fogiv, (void *) original->Fogiv);
	if (t->FrontFace != original->FrontFace)
		crSPUChangeInterface(t, (void *) t->FrontFace, (void *) original->FrontFace);
	if (t->Frustum != original->Frustum)
		crSPUChangeInterface(t, (void *) t->Frustum, (void *) original->Frustum);
	if (t->GenBuffersARB != original->GenBuffersARB)
		crSPUChangeInterface(t, (void *) t->GenBuffersARB, (void *) original->GenBuffersARB);
	if (t->GenFencesNV != original->GenFencesNV)
		crSPUChangeInterface(t, (void *) t->GenFencesNV, (void *) original->GenFencesNV);
	if (t->GenLists != original->GenLists)
		crSPUChangeInterface(t, (void *) t->GenLists, (void *) original->GenLists);
	if (t->GenProgramsARB != original->GenProgramsARB)
		crSPUChangeInterface(t, (void *) t->GenProgramsARB, (void *) original->GenProgramsARB);
	if (t->GenProgramsNV != original->GenProgramsNV)
		crSPUChangeInterface(t, (void *) t->GenProgramsNV, (void *) original->GenProgramsNV);
	if (t->GenQueriesARB != original->GenQueriesARB)
		crSPUChangeInterface(t, (void *) t->GenQueriesARB, (void *) original->GenQueriesARB);
	if (t->GenTextures != original->GenTextures)
		crSPUChangeInterface(t, (void *) t->GenTextures, (void *) original->GenTextures);
	if (t->GetBooleanv != original->GetBooleanv)
		crSPUChangeInterface(t, (void *) t->GetBooleanv, (void *) original->GetBooleanv);
	if (t->GetBufferParameterivARB != original->GetBufferParameterivARB)
		crSPUChangeInterface(t, (void *) t->GetBufferParameterivARB, (void *) original->GetBufferParameterivARB);
	if (t->GetBufferPointervARB != original->GetBufferPointervARB)
		crSPUChangeInterface(t, (void *) t->GetBufferPointervARB, (void *) original->GetBufferPointervARB);
	if (t->GetBufferSubDataARB != original->GetBufferSubDataARB)
		crSPUChangeInterface(t, (void *) t->GetBufferSubDataARB, (void *) original->GetBufferSubDataARB);
	if (t->GetChromiumParametervCR != original->GetChromiumParametervCR)
		crSPUChangeInterface(t, (void *) t->GetChromiumParametervCR, (void *) original->GetChromiumParametervCR);
	if (t->GetClipPlane != original->GetClipPlane)
		crSPUChangeInterface(t, (void *) t->GetClipPlane, (void *) original->GetClipPlane);
	if (t->GetCombinerInputParameterfvNV != original->GetCombinerInputParameterfvNV)
		crSPUChangeInterface(t, (void *) t->GetCombinerInputParameterfvNV, (void *) original->GetCombinerInputParameterfvNV);
	if (t->GetCombinerInputParameterivNV != original->GetCombinerInputParameterivNV)
		crSPUChangeInterface(t, (void *) t->GetCombinerInputParameterivNV, (void *) original->GetCombinerInputParameterivNV);
	if (t->GetCombinerOutputParameterfvNV != original->GetCombinerOutputParameterfvNV)
		crSPUChangeInterface(t, (void *) t->GetCombinerOutputParameterfvNV, (void *) original->GetCombinerOutputParameterfvNV);
	if (t->GetCombinerOutputParameterivNV != original->GetCombinerOutputParameterivNV)
		crSPUChangeInterface(t, (void *) t->GetCombinerOutputParameterivNV, (void *) original->GetCombinerOutputParameterivNV);
	if (t->GetCombinerStageParameterfvNV != original->GetCombinerStageParameterfvNV)
		crSPUChangeInterface(t, (void *) t->GetCombinerStageParameterfvNV, (void *) original->GetCombinerStageParameterfvNV);
	if (t->GetCompressedTexImageARB != original->GetCompressedTexImageARB)
		crSPUChangeInterface(t, (void *) t->GetCompressedTexImageARB, (void *) original->GetCompressedTexImageARB);
	if (t->GetDoublev != original->GetDoublev)
		crSPUChangeInterface(t, (void *) t->GetDoublev, (void *) original->GetDoublev);
	if (t->GetError != original->GetError)
		crSPUChangeInterface(t, (void *) t->GetError, (void *) original->GetError);
	if (t->GetFenceivNV != original->GetFenceivNV)
		crSPUChangeInterface(t, (void *) t->GetFenceivNV, (void *) original->GetFenceivNV);
	if (t->GetFinalCombinerInputParameterfvNV != original->GetFinalCombinerInputParameterfvNV)
		crSPUChangeInterface(t, (void *) t->GetFinalCombinerInputParameterfvNV, (void *) original->GetFinalCombinerInputParameterfvNV);
	if (t->GetFinalCombinerInputParameterivNV != original->GetFinalCombinerInputParameterivNV)
		crSPUChangeInterface(t, (void *) t->GetFinalCombinerInputParameterivNV, (void *) original->GetFinalCombinerInputParameterivNV);
	if (t->GetFloatv != original->GetFloatv)
		crSPUChangeInterface(t, (void *) t->GetFloatv, (void *) original->GetFloatv);
	if (t->GetIntegerv != original->GetIntegerv)
		crSPUChangeInterface(t, (void *) t->GetIntegerv, (void *) original->GetIntegerv);
	if (t->GetLightfv != original->GetLightfv)
		crSPUChangeInterface(t, (void *) t->GetLightfv, (void *) original->GetLightfv);
	if (t->GetLightiv != original->GetLightiv)
		crSPUChangeInterface(t, (void *) t->GetLightiv, (void *) original->GetLightiv);
	if (t->GetMapdv != original->GetMapdv)
		crSPUChangeInterface(t, (void *) t->GetMapdv, (void *) original->GetMapdv);
	if (t->GetMapfv != original->GetMapfv)
		crSPUChangeInterface(t, (void *) t->GetMapfv, (void *) original->GetMapfv);
	if (t->GetMapiv != original->GetMapiv)
		crSPUChangeInterface(t, (void *) t->GetMapiv, (void *) original->GetMapiv);
	if (t->GetMaterialfv != original->GetMaterialfv)
		crSPUChangeInterface(t, (void *) t->GetMaterialfv, (void *) original->GetMaterialfv);
	if (t->GetMaterialiv != original->GetMaterialiv)
		crSPUChangeInterface(t, (void *) t->GetMaterialiv, (void *) original->GetMaterialiv);
	if (t->GetPixelMapfv != original->GetPixelMapfv)
		crSPUChangeInterface(t, (void *) t->GetPixelMapfv, (void *) original->GetPixelMapfv);
	if (t->GetPixelMapuiv != original->GetPixelMapuiv)
		crSPUChangeInterface(t, (void *) t->GetPixelMapuiv, (void *) original->GetPixelMapuiv);
	if (t->GetPixelMapusv != original->GetPixelMapusv)
		crSPUChangeInterface(t, (void *) t->GetPixelMapusv, (void *) original->GetPixelMapusv);
	if (t->GetPointerv != original->GetPointerv)
		crSPUChangeInterface(t, (void *) t->GetPointerv, (void *) original->GetPointerv);
	if (t->GetPolygonStipple != original->GetPolygonStipple)
		crSPUChangeInterface(t, (void *) t->GetPolygonStipple, (void *) original->GetPolygonStipple);
	if (t->GetProgramEnvParameterdvARB != original->GetProgramEnvParameterdvARB)
		crSPUChangeInterface(t, (void *) t->GetProgramEnvParameterdvARB, (void *) original->GetProgramEnvParameterdvARB);
	if (t->GetProgramEnvParameterfvARB != original->GetProgramEnvParameterfvARB)
		crSPUChangeInterface(t, (void *) t->GetProgramEnvParameterfvARB, (void *) original->GetProgramEnvParameterfvARB);
	if (t->GetProgramLocalParameterdvARB != original->GetProgramLocalParameterdvARB)
		crSPUChangeInterface(t, (void *) t->GetProgramLocalParameterdvARB, (void *) original->GetProgramLocalParameterdvARB);
	if (t->GetProgramLocalParameterfvARB != original->GetProgramLocalParameterfvARB)
		crSPUChangeInterface(t, (void *) t->GetProgramLocalParameterfvARB, (void *) original->GetProgramLocalParameterfvARB);
	if (t->GetProgramNamedParameterdvNV != original->GetProgramNamedParameterdvNV)
		crSPUChangeInterface(t, (void *) t->GetProgramNamedParameterdvNV, (void *) original->GetProgramNamedParameterdvNV);
	if (t->GetProgramNamedParameterfvNV != original->GetProgramNamedParameterfvNV)
		crSPUChangeInterface(t, (void *) t->GetProgramNamedParameterfvNV, (void *) original->GetProgramNamedParameterfvNV);
	if (t->GetProgramParameterdvNV != original->GetProgramParameterdvNV)
		crSPUChangeInterface(t, (void *) t->GetProgramParameterdvNV, (void *) original->GetProgramParameterdvNV);
	if (t->GetProgramParameterfvNV != original->GetProgramParameterfvNV)
		crSPUChangeInterface(t, (void *) t->GetProgramParameterfvNV, (void *) original->GetProgramParameterfvNV);
	if (t->GetProgramStringARB != original->GetProgramStringARB)
		crSPUChangeInterface(t, (void *) t->GetProgramStringARB, (void *) original->GetProgramStringARB);
	if (t->GetProgramStringNV != original->GetProgramStringNV)
		crSPUChangeInterface(t, (void *) t->GetProgramStringNV, (void *) original->GetProgramStringNV);
	if (t->GetProgramivARB != original->GetProgramivARB)
		crSPUChangeInterface(t, (void *) t->GetProgramivARB, (void *) original->GetProgramivARB);
	if (t->GetProgramivNV != original->GetProgramivNV)
		crSPUChangeInterface(t, (void *) t->GetProgramivNV, (void *) original->GetProgramivNV);
	if (t->GetQueryObjectivARB != original->GetQueryObjectivARB)
		crSPUChangeInterface(t, (void *) t->GetQueryObjectivARB, (void *) original->GetQueryObjectivARB);
	if (t->GetQueryObjectuivARB != original->GetQueryObjectuivARB)
		crSPUChangeInterface(t, (void *) t->GetQueryObjectuivARB, (void *) original->GetQueryObjectuivARB);
	if (t->GetQueryivARB != original->GetQueryivARB)
		crSPUChangeInterface(t, (void *) t->GetQueryivARB, (void *) original->GetQueryivARB);
	if (t->GetString != original->GetString)
		crSPUChangeInterface(t, (void *) t->GetString, (void *) original->GetString);
	if (t->GetTexEnvfv != original->GetTexEnvfv)
		crSPUChangeInterface(t, (void *) t->GetTexEnvfv, (void *) original->GetTexEnvfv);
	if (t->GetTexEnviv != original->GetTexEnviv)
		crSPUChangeInterface(t, (void *) t->GetTexEnviv, (void *) original->GetTexEnviv);
	if (t->GetTexGendv != original->GetTexGendv)
		crSPUChangeInterface(t, (void *) t->GetTexGendv, (void *) original->GetTexGendv);
	if (t->GetTexGenfv != original->GetTexGenfv)
		crSPUChangeInterface(t, (void *) t->GetTexGenfv, (void *) original->GetTexGenfv);
	if (t->GetTexGeniv != original->GetTexGeniv)
		crSPUChangeInterface(t, (void *) t->GetTexGeniv, (void *) original->GetTexGeniv);
	if (t->GetTexImage != original->GetTexImage)
		crSPUChangeInterface(t, (void *) t->GetTexImage, (void *) original->GetTexImage);
	if (t->GetTexLevelParameterfv != original->GetTexLevelParameterfv)
		crSPUChangeInterface(t, (void *) t->GetTexLevelParameterfv, (void *) original->GetTexLevelParameterfv);
	if (t->GetTexLevelParameteriv != original->GetTexLevelParameteriv)
		crSPUChangeInterface(t, (void *) t->GetTexLevelParameteriv, (void *) original->GetTexLevelParameteriv);
	if (t->GetTexParameterfv != original->GetTexParameterfv)
		crSPUChangeInterface(t, (void *) t->GetTexParameterfv, (void *) original->GetTexParameterfv);
	if (t->GetTexParameteriv != original->GetTexParameteriv)
		crSPUChangeInterface(t, (void *) t->GetTexParameteriv, (void *) original->GetTexParameteriv);
	if (t->GetTrackMatrixivNV != original->GetTrackMatrixivNV)
		crSPUChangeInterface(t, (void *) t->GetTrackMatrixivNV, (void *) original->GetTrackMatrixivNV);
	if (t->GetVertexAttribPointervARB != original->GetVertexAttribPointervARB)
		crSPUChangeInterface(t, (void *) t->GetVertexAttribPointervARB, (void *) original->GetVertexAttribPointervARB);
	if (t->GetVertexAttribPointervNV != original->GetVertexAttribPointervNV)
		crSPUChangeInterface(t, (void *) t->GetVertexAttribPointervNV, (void *) original->GetVertexAttribPointervNV);
	if (t->GetVertexAttribdvARB != original->GetVertexAttribdvARB)
		crSPUChangeInterface(t, (void *) t->GetVertexAttribdvARB, (void *) original->GetVertexAttribdvARB);
	if (t->GetVertexAttribdvNV != original->GetVertexAttribdvNV)
		crSPUChangeInterface(t, (void *) t->GetVertexAttribdvNV, (void *) original->GetVertexAttribdvNV);
	if (t->GetVertexAttribfvARB != original->GetVertexAttribfvARB)
		crSPUChangeInterface(t, (void *) t->GetVertexAttribfvARB, (void *) original->GetVertexAttribfvARB);
	if (t->GetVertexAttribfvNV != original->GetVertexAttribfvNV)
		crSPUChangeInterface(t, (void *) t->GetVertexAttribfvNV, (void *) original->GetVertexAttribfvNV);
	if (t->GetVertexAttribivARB != original->GetVertexAttribivARB)
		crSPUChangeInterface(t, (void *) t->GetVertexAttribivARB, (void *) original->GetVertexAttribivARB);
	if (t->GetVertexAttribivNV != original->GetVertexAttribivNV)
		crSPUChangeInterface(t, (void *) t->GetVertexAttribivNV, (void *) original->GetVertexAttribivNV);
	if (t->Hint != original->Hint)
		crSPUChangeInterface(t, (void *) t->Hint, (void *) original->Hint);
	if (t->IndexMask != original->IndexMask)
		crSPUChangeInterface(t, (void *) t->IndexMask, (void *) original->IndexMask);
	if (t->IndexPointer != original->IndexPointer)
		crSPUChangeInterface(t, (void *) t->IndexPointer, (void *) original->IndexPointer);
	if (t->Indexd != original->Indexd)
		crSPUChangeInterface(t, (void *) t->Indexd, (void *) original->Indexd);
	if (t->Indexdv != original->Indexdv)
		crSPUChangeInterface(t, (void *) t->Indexdv, (void *) original->Indexdv);
	if (t->Indexf != original->Indexf)
		crSPUChangeInterface(t, (void *) t->Indexf, (void *) original->Indexf);
	if (t->Indexfv != original->Indexfv)
		crSPUChangeInterface(t, (void *) t->Indexfv, (void *) original->Indexfv);
	if (t->Indexi != original->Indexi)
		crSPUChangeInterface(t, (void *) t->Indexi, (void *) original->Indexi);
	if (t->Indexiv != original->Indexiv)
		crSPUChangeInterface(t, (void *) t->Indexiv, (void *) original->Indexiv);
	if (t->Indexs != original->Indexs)
		crSPUChangeInterface(t, (void *) t->Indexs, (void *) original->Indexs);
	if (t->Indexsv != original->Indexsv)
		crSPUChangeInterface(t, (void *) t->Indexsv, (void *) original->Indexsv);
	if (t->Indexub != original->Indexub)
		crSPUChangeInterface(t, (void *) t->Indexub, (void *) original->Indexub);
	if (t->Indexubv != original->Indexubv)
		crSPUChangeInterface(t, (void *) t->Indexubv, (void *) original->Indexubv);
	if (t->InitNames != original->InitNames)
		crSPUChangeInterface(t, (void *) t->InitNames, (void *) original->InitNames);
	if (t->InterleavedArrays != original->InterleavedArrays)
		crSPUChangeInterface(t, (void *) t->InterleavedArrays, (void *) original->InterleavedArrays);
	if (t->IsBufferARB != original->IsBufferARB)
		crSPUChangeInterface(t, (void *) t->IsBufferARB, (void *) original->IsBufferARB);
	if (t->IsEnabled != original->IsEnabled)
		crSPUChangeInterface(t, (void *) t->IsEnabled, (void *) original->IsEnabled);
	if (t->IsFenceNV != original->IsFenceNV)
		crSPUChangeInterface(t, (void *) t->IsFenceNV, (void *) original->IsFenceNV);
	if (t->IsList != original->IsList)
		crSPUChangeInterface(t, (void *) t->IsList, (void *) original->IsList);
	if (t->IsProgramARB != original->IsProgramARB)
		crSPUChangeInterface(t, (void *) t->IsProgramARB, (void *) original->IsProgramARB);
	if (t->IsQueryARB != original->IsQueryARB)
		crSPUChangeInterface(t, (void *) t->IsQueryARB, (void *) original->IsQueryARB);
	if (t->IsTexture != original->IsTexture)
		crSPUChangeInterface(t, (void *) t->IsTexture, (void *) original->IsTexture);
	if (t->LightModelf != original->LightModelf)
		crSPUChangeInterface(t, (void *) t->LightModelf, (void *) original->LightModelf);
	if (t->LightModelfv != original->LightModelfv)
		crSPUChangeInterface(t, (void *) t->LightModelfv, (void *) original->LightModelfv);
	if (t->LightModeli != original->LightModeli)
		crSPUChangeInterface(t, (void *) t->LightModeli, (void *) original->LightModeli);
	if (t->LightModeliv != original->LightModeliv)
		crSPUChangeInterface(t, (void *) t->LightModeliv, (void *) original->LightModeliv);
	if (t->Lightf != original->Lightf)
		crSPUChangeInterface(t, (void *) t->Lightf, (void *) original->Lightf);
	if (t->Lightfv != original->Lightfv)
		crSPUChangeInterface(t, (void *) t->Lightfv, (void *) original->Lightfv);
	if (t->Lighti != original->Lighti)
		crSPUChangeInterface(t, (void *) t->Lighti, (void *) original->Lighti);
	if (t->Lightiv != original->Lightiv)
		crSPUChangeInterface(t, (void *) t->Lightiv, (void *) original->Lightiv);
	if (t->LineStipple != original->LineStipple)
		crSPUChangeInterface(t, (void *) t->LineStipple, (void *) original->LineStipple);
	if (t->LineWidth != original->LineWidth)
		crSPUChangeInterface(t, (void *) t->LineWidth, (void *) original->LineWidth);
	if (t->ListBase != original->ListBase)
		crSPUChangeInterface(t, (void *) t->ListBase, (void *) original->ListBase);
	if (t->LoadIdentity != original->LoadIdentity)
		crSPUChangeInterface(t, (void *) t->LoadIdentity, (void *) original->LoadIdentity);
	if (t->LoadMatrixd != original->LoadMatrixd)
		crSPUChangeInterface(t, (void *) t->LoadMatrixd, (void *) original->LoadMatrixd);
	if (t->LoadMatrixf != original->LoadMatrixf)
		crSPUChangeInterface(t, (void *) t->LoadMatrixf, (void *) original->LoadMatrixf);
	if (t->LoadName != original->LoadName)
		crSPUChangeInterface(t, (void *) t->LoadName, (void *) original->LoadName);
	if (t->LoadProgramNV != original->LoadProgramNV)
		crSPUChangeInterface(t, (void *) t->LoadProgramNV, (void *) original->LoadProgramNV);
	if (t->LoadTransposeMatrixdARB != original->LoadTransposeMatrixdARB)
		crSPUChangeInterface(t, (void *) t->LoadTransposeMatrixdARB, (void *) original->LoadTransposeMatrixdARB);
	if (t->LoadTransposeMatrixfARB != original->LoadTransposeMatrixfARB)
		crSPUChangeInterface(t, (void *) t->LoadTransposeMatrixfARB, (void *) original->LoadTransposeMatrixfARB);
	if (t->LogicOp != original->LogicOp)
		crSPUChangeInterface(t, (void *) t->LogicOp, (void *) original->LogicOp);
	if (t->MakeCurrent != original->MakeCurrent)
		crSPUChangeInterface(t, (void *) t->MakeCurrent, (void *) original->MakeCurrent);
	if (t->Map1d != original->Map1d)
		crSPUChangeInterface(t, (void *) t->Map1d, (void *) original->Map1d);
	if (t->Map1f != original->Map1f)
		crSPUChangeInterface(t, (void *) t->Map1f, (void *) original->Map1f);
	if (t->Map2d != original->Map2d)
		crSPUChangeInterface(t, (void *) t->Map2d, (void *) original->Map2d);
	if (t->Map2f != original->Map2f)
		crSPUChangeInterface(t, (void *) t->Map2f, (void *) original->Map2f);
	if (t->MapBufferARB != original->MapBufferARB)
		crSPUChangeInterface(t, (void *) t->MapBufferARB, (void *) original->MapBufferARB);
	if (t->MapGrid1d != original->MapGrid1d)
		crSPUChangeInterface(t, (void *) t->MapGrid1d, (void *) original->MapGrid1d);
	if (t->MapGrid1f != original->MapGrid1f)
		crSPUChangeInterface(t, (void *) t->MapGrid1f, (void *) original->MapGrid1f);
	if (t->MapGrid2d != original->MapGrid2d)
		crSPUChangeInterface(t, (void *) t->MapGrid2d, (void *) original->MapGrid2d);
	if (t->MapGrid2f != original->MapGrid2f)
		crSPUChangeInterface(t, (void *) t->MapGrid2f, (void *) original->MapGrid2f);
	if (t->Materialf != original->Materialf)
		crSPUChangeInterface(t, (void *) t->Materialf, (void *) original->Materialf);
	if (t->Materialfv != original->Materialfv)
		crSPUChangeInterface(t, (void *) t->Materialfv, (void *) original->Materialfv);
	if (t->Materiali != original->Materiali)
		crSPUChangeInterface(t, (void *) t->Materiali, (void *) original->Materiali);
	if (t->Materialiv != original->Materialiv)
		crSPUChangeInterface(t, (void *) t->Materialiv, (void *) original->Materialiv);
	if (t->MatrixMode != original->MatrixMode)
		crSPUChangeInterface(t, (void *) t->MatrixMode, (void *) original->MatrixMode);
	if (t->MultMatrixd != original->MultMatrixd)
		crSPUChangeInterface(t, (void *) t->MultMatrixd, (void *) original->MultMatrixd);
	if (t->MultMatrixf != original->MultMatrixf)
		crSPUChangeInterface(t, (void *) t->MultMatrixf, (void *) original->MultMatrixf);
	if (t->MultTransposeMatrixdARB != original->MultTransposeMatrixdARB)
		crSPUChangeInterface(t, (void *) t->MultTransposeMatrixdARB, (void *) original->MultTransposeMatrixdARB);
	if (t->MultTransposeMatrixfARB != original->MultTransposeMatrixfARB)
		crSPUChangeInterface(t, (void *) t->MultTransposeMatrixfARB, (void *) original->MultTransposeMatrixfARB);
	if (t->MultiDrawArraysEXT != original->MultiDrawArraysEXT)
		crSPUChangeInterface(t, (void *) t->MultiDrawArraysEXT, (void *) original->MultiDrawArraysEXT);
	if (t->MultiDrawElementsEXT != original->MultiDrawElementsEXT)
		crSPUChangeInterface(t, (void *) t->MultiDrawElementsEXT, (void *) original->MultiDrawElementsEXT);
	if (t->MultiTexCoord1dARB != original->MultiTexCoord1dARB)
		crSPUChangeInterface(t, (void *) t->MultiTexCoord1dARB, (void *) original->MultiTexCoord1dARB);
	if (t->MultiTexCoord1dvARB != original->MultiTexCoord1dvARB)
		crSPUChangeInterface(t, (void *) t->MultiTexCoord1dvARB, (void *) original->MultiTexCoord1dvARB);
	if (t->MultiTexCoord1fARB != original->MultiTexCoord1fARB)
		crSPUChangeInterface(t, (void *) t->MultiTexCoord1fARB, (void *) original->MultiTexCoord1fARB);
	if (t->MultiTexCoord1fvARB != original->MultiTexCoord1fvARB)
		crSPUChangeInterface(t, (void *) t->MultiTexCoord1fvARB, (void *) original->MultiTexCoord1fvARB);
	if (t->MultiTexCoord1iARB != original->MultiTexCoord1iARB)
		crSPUChangeInterface(t, (void *) t->MultiTexCoord1iARB, (void *) original->MultiTexCoord1iARB);
	if (t->MultiTexCoord1ivARB != original->MultiTexCoord1ivARB)
		crSPUChangeInterface(t, (void *) t->MultiTexCoord1ivARB, (void *) original->MultiTexCoord1ivARB);
	if (t->MultiTexCoord1sARB != original->MultiTexCoord1sARB)
		crSPUChangeInterface(t, (void *) t->MultiTexCoord1sARB, (void *) original->MultiTexCoord1sARB);
	if (t->MultiTexCoord1svARB != original->MultiTexCoord1svARB)
		crSPUChangeInterface(t, (void *) t->MultiTexCoord1svARB, (void *) original->MultiTexCoord1svARB);
	if (t->MultiTexCoord2dARB != original->MultiTexCoord2dARB)
		crSPUChangeInterface(t, (void *) t->MultiTexCoord2dARB, (void *) original->MultiTexCoord2dARB);
	if (t->MultiTexCoord2dvARB != original->MultiTexCoord2dvARB)
		crSPUChangeInterface(t, (void *) t->MultiTexCoord2dvARB, (void *) original->MultiTexCoord2dvARB);
	if (t->MultiTexCoord2fARB != original->MultiTexCoord2fARB)
		crSPUChangeInterface(t, (void *) t->MultiTexCoord2fARB, (void *) original->MultiTexCoord2fARB);
	if (t->MultiTexCoord2fvARB != original->MultiTexCoord2fvARB)
		crSPUChangeInterface(t, (void *) t->MultiTexCoord2fvARB, (void *) original->MultiTexCoord2fvARB);
	if (t->MultiTexCoord2iARB != original->MultiTexCoord2iARB)
		crSPUChangeInterface(t, (void *) t->MultiTexCoord2iARB, (void *) original->MultiTexCoord2iARB);
	if (t->MultiTexCoord2ivARB != original->MultiTexCoord2ivARB)
		crSPUChangeInterface(t, (void *) t->MultiTexCoord2ivARB, (void *) original->MultiTexCoord2ivARB);
	if (t->MultiTexCoord2sARB != original->MultiTexCoord2sARB)
		crSPUChangeInterface(t, (void *) t->MultiTexCoord2sARB, (void *) original->MultiTexCoord2sARB);
	if (t->MultiTexCoord2svARB != original->MultiTexCoord2svARB)
		crSPUChangeInterface(t, (void *) t->MultiTexCoord2svARB, (void *) original->MultiTexCoord2svARB);
	if (t->MultiTexCoord3dARB != original->MultiTexCoord3dARB)
		crSPUChangeInterface(t, (void *) t->MultiTexCoord3dARB, (void *) original->MultiTexCoord3dARB);
	if (t->MultiTexCoord3dvARB != original->MultiTexCoord3dvARB)
		crSPUChangeInterface(t, (void *) t->MultiTexCoord3dvARB, (void *) original->MultiTexCoord3dvARB);
	if (t->MultiTexCoord3fARB != original->MultiTexCoord3fARB)
		crSPUChangeInterface(t, (void *) t->MultiTexCoord3fARB, (void *) original->MultiTexCoord3fARB);
	if (t->MultiTexCoord3fvARB != original->MultiTexCoord3fvARB)
		crSPUChangeInterface(t, (void *) t->MultiTexCoord3fvARB, (void *) original->MultiTexCoord3fvARB);
	if (t->MultiTexCoord3iARB != original->MultiTexCoord3iARB)
		crSPUChangeInterface(t, (void *) t->MultiTexCoord3iARB, (void *) original->MultiTexCoord3iARB);
	if (t->MultiTexCoord3ivARB != original->MultiTexCoord3ivARB)
		crSPUChangeInterface(t, (void *) t->MultiTexCoord3ivARB, (void *) original->MultiTexCoord3ivARB);
	if (t->MultiTexCoord3sARB != original->MultiTexCoord3sARB)
		crSPUChangeInterface(t, (void *) t->MultiTexCoord3sARB, (void *) original->MultiTexCoord3sARB);
	if (t->MultiTexCoord3svARB != original->MultiTexCoord3svARB)
		crSPUChangeInterface(t, (void *) t->MultiTexCoord3svARB, (void *) original->MultiTexCoord3svARB);
	if (t->MultiTexCoord4dARB != original->MultiTexCoord4dARB)
		crSPUChangeInterface(t, (void *) t->MultiTexCoord4dARB, (void *) original->MultiTexCoord4dARB);
	if (t->MultiTexCoord4dvARB != original->MultiTexCoord4dvARB)
		crSPUChangeInterface(t, (void *) t->MultiTexCoord4dvARB, (void *) original->MultiTexCoord4dvARB);
	if (t->MultiTexCoord4fARB != original->MultiTexCoord4fARB)
		crSPUChangeInterface(t, (void *) t->MultiTexCoord4fARB, (void *) original->MultiTexCoord4fARB);
	if (t->MultiTexCoord4fvARB != original->MultiTexCoord4fvARB)
		crSPUChangeInterface(t, (void *) t->MultiTexCoord4fvARB, (void *) original->MultiTexCoord4fvARB);
	if (t->MultiTexCoord4iARB != original->MultiTexCoord4iARB)
		crSPUChangeInterface(t, (void *) t->MultiTexCoord4iARB, (void *) original->MultiTexCoord4iARB);
	if (t->MultiTexCoord4ivARB != original->MultiTexCoord4ivARB)
		crSPUChangeInterface(t, (void *) t->MultiTexCoord4ivARB, (void *) original->MultiTexCoord4ivARB);
	if (t->MultiTexCoord4sARB != original->MultiTexCoord4sARB)
		crSPUChangeInterface(t, (void *) t->MultiTexCoord4sARB, (void *) original->MultiTexCoord4sARB);
	if (t->MultiTexCoord4svARB != original->MultiTexCoord4svARB)
		crSPUChangeInterface(t, (void *) t->MultiTexCoord4svARB, (void *) original->MultiTexCoord4svARB);
	if (t->NewList != original->NewList)
		crSPUChangeInterface(t, (void *) t->NewList, (void *) original->NewList);
	if (t->Normal3b != original->Normal3b)
		crSPUChangeInterface(t, (void *) t->Normal3b, (void *) original->Normal3b);
	if (t->Normal3bv != original->Normal3bv)
		crSPUChangeInterface(t, (void *) t->Normal3bv, (void *) original->Normal3bv);
	if (t->Normal3d != original->Normal3d)
		crSPUChangeInterface(t, (void *) t->Normal3d, (void *) original->Normal3d);
	if (t->Normal3dv != original->Normal3dv)
		crSPUChangeInterface(t, (void *) t->Normal3dv, (void *) original->Normal3dv);
	if (t->Normal3f != original->Normal3f)
		crSPUChangeInterface(t, (void *) t->Normal3f, (void *) original->Normal3f);
	if (t->Normal3fv != original->Normal3fv)
		crSPUChangeInterface(t, (void *) t->Normal3fv, (void *) original->Normal3fv);
	if (t->Normal3i != original->Normal3i)
		crSPUChangeInterface(t, (void *) t->Normal3i, (void *) original->Normal3i);
	if (t->Normal3iv != original->Normal3iv)
		crSPUChangeInterface(t, (void *) t->Normal3iv, (void *) original->Normal3iv);
	if (t->Normal3s != original->Normal3s)
		crSPUChangeInterface(t, (void *) t->Normal3s, (void *) original->Normal3s);
	if (t->Normal3sv != original->Normal3sv)
		crSPUChangeInterface(t, (void *) t->Normal3sv, (void *) original->Normal3sv);
	if (t->NormalPointer != original->NormalPointer)
		crSPUChangeInterface(t, (void *) t->NormalPointer, (void *) original->NormalPointer);
	if (t->Ortho != original->Ortho)
		crSPUChangeInterface(t, (void *) t->Ortho, (void *) original->Ortho);
	if (t->PassThrough != original->PassThrough)
		crSPUChangeInterface(t, (void *) t->PassThrough, (void *) original->PassThrough);
	if (t->PixelMapfv != original->PixelMapfv)
		crSPUChangeInterface(t, (void *) t->PixelMapfv, (void *) original->PixelMapfv);
	if (t->PixelMapuiv != original->PixelMapuiv)
		crSPUChangeInterface(t, (void *) t->PixelMapuiv, (void *) original->PixelMapuiv);
	if (t->PixelMapusv != original->PixelMapusv)
		crSPUChangeInterface(t, (void *) t->PixelMapusv, (void *) original->PixelMapusv);
	if (t->PixelStoref != original->PixelStoref)
		crSPUChangeInterface(t, (void *) t->PixelStoref, (void *) original->PixelStoref);
	if (t->PixelStorei != original->PixelStorei)
		crSPUChangeInterface(t, (void *) t->PixelStorei, (void *) original->PixelStorei);
	if (t->PixelTransferf != original->PixelTransferf)
		crSPUChangeInterface(t, (void *) t->PixelTransferf, (void *) original->PixelTransferf);
	if (t->PixelTransferi != original->PixelTransferi)
		crSPUChangeInterface(t, (void *) t->PixelTransferi, (void *) original->PixelTransferi);
	if (t->PixelZoom != original->PixelZoom)
		crSPUChangeInterface(t, (void *) t->PixelZoom, (void *) original->PixelZoom);
	if (t->PointParameterfARB != original->PointParameterfARB)
		crSPUChangeInterface(t, (void *) t->PointParameterfARB, (void *) original->PointParameterfARB);
	if (t->PointParameterfvARB != original->PointParameterfvARB)
		crSPUChangeInterface(t, (void *) t->PointParameterfvARB, (void *) original->PointParameterfvARB);
	if (t->PointParameteri != original->PointParameteri)
		crSPUChangeInterface(t, (void *) t->PointParameteri, (void *) original->PointParameteri);
	if (t->PointParameteriv != original->PointParameteriv)
		crSPUChangeInterface(t, (void *) t->PointParameteriv, (void *) original->PointParameteriv);
	if (t->PointSize != original->PointSize)
		crSPUChangeInterface(t, (void *) t->PointSize, (void *) original->PointSize);
	if (t->PolygonMode != original->PolygonMode)
		crSPUChangeInterface(t, (void *) t->PolygonMode, (void *) original->PolygonMode);
	if (t->PolygonOffset != original->PolygonOffset)
		crSPUChangeInterface(t, (void *) t->PolygonOffset, (void *) original->PolygonOffset);
	if (t->PolygonStipple != original->PolygonStipple)
		crSPUChangeInterface(t, (void *) t->PolygonStipple, (void *) original->PolygonStipple);
	if (t->PopAttrib != original->PopAttrib)
		crSPUChangeInterface(t, (void *) t->PopAttrib, (void *) original->PopAttrib);
	if (t->PopClientAttrib != original->PopClientAttrib)
		crSPUChangeInterface(t, (void *) t->PopClientAttrib, (void *) original->PopClientAttrib);
	if (t->PopMatrix != original->PopMatrix)
		crSPUChangeInterface(t, (void *) t->PopMatrix, (void *) original->PopMatrix);
	if (t->PopName != original->PopName)
		crSPUChangeInterface(t, (void *) t->PopName, (void *) original->PopName);
	if (t->PrioritizeTextures != original->PrioritizeTextures)
		crSPUChangeInterface(t, (void *) t->PrioritizeTextures, (void *) original->PrioritizeTextures);
	if (t->ProgramEnvParameter4dARB != original->ProgramEnvParameter4dARB)
		crSPUChangeInterface(t, (void *) t->ProgramEnvParameter4dARB, (void *) original->ProgramEnvParameter4dARB);
	if (t->ProgramEnvParameter4dvARB != original->ProgramEnvParameter4dvARB)
		crSPUChangeInterface(t, (void *) t->ProgramEnvParameter4dvARB, (void *) original->ProgramEnvParameter4dvARB);
	if (t->ProgramEnvParameter4fARB != original->ProgramEnvParameter4fARB)
		crSPUChangeInterface(t, (void *) t->ProgramEnvParameter4fARB, (void *) original->ProgramEnvParameter4fARB);
	if (t->ProgramEnvParameter4fvARB != original->ProgramEnvParameter4fvARB)
		crSPUChangeInterface(t, (void *) t->ProgramEnvParameter4fvARB, (void *) original->ProgramEnvParameter4fvARB);
	if (t->ProgramLocalParameter4dARB != original->ProgramLocalParameter4dARB)
		crSPUChangeInterface(t, (void *) t->ProgramLocalParameter4dARB, (void *) original->ProgramLocalParameter4dARB);
	if (t->ProgramLocalParameter4dvARB != original->ProgramLocalParameter4dvARB)
		crSPUChangeInterface(t, (void *) t->ProgramLocalParameter4dvARB, (void *) original->ProgramLocalParameter4dvARB);
	if (t->ProgramLocalParameter4fARB != original->ProgramLocalParameter4fARB)
		crSPUChangeInterface(t, (void *) t->ProgramLocalParameter4fARB, (void *) original->ProgramLocalParameter4fARB);
	if (t->ProgramLocalParameter4fvARB != original->ProgramLocalParameter4fvARB)
		crSPUChangeInterface(t, (void *) t->ProgramLocalParameter4fvARB, (void *) original->ProgramLocalParameter4fvARB);
	if (t->ProgramNamedParameter4dNV != original->ProgramNamedParameter4dNV)
		crSPUChangeInterface(t, (void *) t->ProgramNamedParameter4dNV, (void *) original->ProgramNamedParameter4dNV);
	if (t->ProgramNamedParameter4dvNV != original->ProgramNamedParameter4dvNV)
		crSPUChangeInterface(t, (void *) t->ProgramNamedParameter4dvNV, (void *) original->ProgramNamedParameter4dvNV);
	if (t->ProgramNamedParameter4fNV != original->ProgramNamedParameter4fNV)
		crSPUChangeInterface(t, (void *) t->ProgramNamedParameter4fNV, (void *) original->ProgramNamedParameter4fNV);
	if (t->ProgramNamedParameter4fvNV != original->ProgramNamedParameter4fvNV)
		crSPUChangeInterface(t, (void *) t->ProgramNamedParameter4fvNV, (void *) original->ProgramNamedParameter4fvNV);
	if (t->ProgramParameter4dNV != original->ProgramParameter4dNV)
		crSPUChangeInterface(t, (void *) t->ProgramParameter4dNV, (void *) original->ProgramParameter4dNV);
	if (t->ProgramParameter4dvNV != original->ProgramParameter4dvNV)
		crSPUChangeInterface(t, (void *) t->ProgramParameter4dvNV, (void *) original->ProgramParameter4dvNV);
	if (t->ProgramParameter4fNV != original->ProgramParameter4fNV)
		crSPUChangeInterface(t, (void *) t->ProgramParameter4fNV, (void *) original->ProgramParameter4fNV);
	if (t->ProgramParameter4fvNV != original->ProgramParameter4fvNV)
		crSPUChangeInterface(t, (void *) t->ProgramParameter4fvNV, (void *) original->ProgramParameter4fvNV);
	if (t->ProgramParameters4dvNV != original->ProgramParameters4dvNV)
		crSPUChangeInterface(t, (void *) t->ProgramParameters4dvNV, (void *) original->ProgramParameters4dvNV);
	if (t->ProgramParameters4fvNV != original->ProgramParameters4fvNV)
		crSPUChangeInterface(t, (void *) t->ProgramParameters4fvNV, (void *) original->ProgramParameters4fvNV);
	if (t->ProgramStringARB != original->ProgramStringARB)
		crSPUChangeInterface(t, (void *) t->ProgramStringARB, (void *) original->ProgramStringARB);
	if (t->PushAttrib != original->PushAttrib)
		crSPUChangeInterface(t, (void *) t->PushAttrib, (void *) original->PushAttrib);
	if (t->PushClientAttrib != original->PushClientAttrib)
		crSPUChangeInterface(t, (void *) t->PushClientAttrib, (void *) original->PushClientAttrib);
	if (t->PushMatrix != original->PushMatrix)
		crSPUChangeInterface(t, (void *) t->PushMatrix, (void *) original->PushMatrix);
	if (t->PushName != original->PushName)
		crSPUChangeInterface(t, (void *) t->PushName, (void *) original->PushName);
	if (t->RasterPos2d != original->RasterPos2d)
		crSPUChangeInterface(t, (void *) t->RasterPos2d, (void *) original->RasterPos2d);
	if (t->RasterPos2dv != original->RasterPos2dv)
		crSPUChangeInterface(t, (void *) t->RasterPos2dv, (void *) original->RasterPos2dv);
	if (t->RasterPos2f != original->RasterPos2f)
		crSPUChangeInterface(t, (void *) t->RasterPos2f, (void *) original->RasterPos2f);
	if (t->RasterPos2fv != original->RasterPos2fv)
		crSPUChangeInterface(t, (void *) t->RasterPos2fv, (void *) original->RasterPos2fv);
	if (t->RasterPos2i != original->RasterPos2i)
		crSPUChangeInterface(t, (void *) t->RasterPos2i, (void *) original->RasterPos2i);
	if (t->RasterPos2iv != original->RasterPos2iv)
		crSPUChangeInterface(t, (void *) t->RasterPos2iv, (void *) original->RasterPos2iv);
	if (t->RasterPos2s != original->RasterPos2s)
		crSPUChangeInterface(t, (void *) t->RasterPos2s, (void *) original->RasterPos2s);
	if (t->RasterPos2sv != original->RasterPos2sv)
		crSPUChangeInterface(t, (void *) t->RasterPos2sv, (void *) original->RasterPos2sv);
	if (t->RasterPos3d != original->RasterPos3d)
		crSPUChangeInterface(t, (void *) t->RasterPos3d, (void *) original->RasterPos3d);
	if (t->RasterPos3dv != original->RasterPos3dv)
		crSPUChangeInterface(t, (void *) t->RasterPos3dv, (void *) original->RasterPos3dv);
	if (t->RasterPos3f != original->RasterPos3f)
		crSPUChangeInterface(t, (void *) t->RasterPos3f, (void *) original->RasterPos3f);
	if (t->RasterPos3fv != original->RasterPos3fv)
		crSPUChangeInterface(t, (void *) t->RasterPos3fv, (void *) original->RasterPos3fv);
	if (t->RasterPos3i != original->RasterPos3i)
		crSPUChangeInterface(t, (void *) t->RasterPos3i, (void *) original->RasterPos3i);
	if (t->RasterPos3iv != original->RasterPos3iv)
		crSPUChangeInterface(t, (void *) t->RasterPos3iv, (void *) original->RasterPos3iv);
	if (t->RasterPos3s != original->RasterPos3s)
		crSPUChangeInterface(t, (void *) t->RasterPos3s, (void *) original->RasterPos3s);
	if (t->RasterPos3sv != original->RasterPos3sv)
		crSPUChangeInterface(t, (void *) t->RasterPos3sv, (void *) original->RasterPos3sv);
	if (t->RasterPos4d != original->RasterPos4d)
		crSPUChangeInterface(t, (void *) t->RasterPos4d, (void *) original->RasterPos4d);
	if (t->RasterPos4dv != original->RasterPos4dv)
		crSPUChangeInterface(t, (void *) t->RasterPos4dv, (void *) original->RasterPos4dv);
	if (t->RasterPos4f != original->RasterPos4f)
		crSPUChangeInterface(t, (void *) t->RasterPos4f, (void *) original->RasterPos4f);
	if (t->RasterPos4fv != original->RasterPos4fv)
		crSPUChangeInterface(t, (void *) t->RasterPos4fv, (void *) original->RasterPos4fv);
	if (t->RasterPos4i != original->RasterPos4i)
		crSPUChangeInterface(t, (void *) t->RasterPos4i, (void *) original->RasterPos4i);
	if (t->RasterPos4iv != original->RasterPos4iv)
		crSPUChangeInterface(t, (void *) t->RasterPos4iv, (void *) original->RasterPos4iv);
	if (t->RasterPos4s != original->RasterPos4s)
		crSPUChangeInterface(t, (void *) t->RasterPos4s, (void *) original->RasterPos4s);
	if (t->RasterPos4sv != original->RasterPos4sv)
		crSPUChangeInterface(t, (void *) t->RasterPos4sv, (void *) original->RasterPos4sv);
	if (t->ReadBuffer != original->ReadBuffer)
		crSPUChangeInterface(t, (void *) t->ReadBuffer, (void *) original->ReadBuffer);
	if (t->ReadPixels != original->ReadPixels)
		crSPUChangeInterface(t, (void *) t->ReadPixels, (void *) original->ReadPixels);
	if (t->Rectd != original->Rectd)
		crSPUChangeInterface(t, (void *) t->Rectd, (void *) original->Rectd);
	if (t->Rectdv != original->Rectdv)
		crSPUChangeInterface(t, (void *) t->Rectdv, (void *) original->Rectdv);
	if (t->Rectf != original->Rectf)
		crSPUChangeInterface(t, (void *) t->Rectf, (void *) original->Rectf);
	if (t->Rectfv != original->Rectfv)
		crSPUChangeInterface(t, (void *) t->Rectfv, (void *) original->Rectfv);
	if (t->Recti != original->Recti)
		crSPUChangeInterface(t, (void *) t->Recti, (void *) original->Recti);
	if (t->Rectiv != original->Rectiv)
		crSPUChangeInterface(t, (void *) t->Rectiv, (void *) original->Rectiv);
	if (t->Rects != original->Rects)
		crSPUChangeInterface(t, (void *) t->Rects, (void *) original->Rects);
	if (t->Rectsv != original->Rectsv)
		crSPUChangeInterface(t, (void *) t->Rectsv, (void *) original->Rectsv);
	if (t->RenderMode != original->RenderMode)
		crSPUChangeInterface(t, (void *) t->RenderMode, (void *) original->RenderMode);
	if (t->RequestResidentProgramsNV != original->RequestResidentProgramsNV)
		crSPUChangeInterface(t, (void *) t->RequestResidentProgramsNV, (void *) original->RequestResidentProgramsNV);
	if (t->Rotated != original->Rotated)
		crSPUChangeInterface(t, (void *) t->Rotated, (void *) original->Rotated);
	if (t->Rotatef != original->Rotatef)
		crSPUChangeInterface(t, (void *) t->Rotatef, (void *) original->Rotatef);
	if (t->SampleCoverageARB != original->SampleCoverageARB)
		crSPUChangeInterface(t, (void *) t->SampleCoverageARB, (void *) original->SampleCoverageARB);
	if (t->Scaled != original->Scaled)
		crSPUChangeInterface(t, (void *) t->Scaled, (void *) original->Scaled);
	if (t->Scalef != original->Scalef)
		crSPUChangeInterface(t, (void *) t->Scalef, (void *) original->Scalef);
	if (t->Scissor != original->Scissor)
		crSPUChangeInterface(t, (void *) t->Scissor, (void *) original->Scissor);
	if (t->SecondaryColor3bEXT != original->SecondaryColor3bEXT)
		crSPUChangeInterface(t, (void *) t->SecondaryColor3bEXT, (void *) original->SecondaryColor3bEXT);
	if (t->SecondaryColor3bvEXT != original->SecondaryColor3bvEXT)
		crSPUChangeInterface(t, (void *) t->SecondaryColor3bvEXT, (void *) original->SecondaryColor3bvEXT);
	if (t->SecondaryColor3dEXT != original->SecondaryColor3dEXT)
		crSPUChangeInterface(t, (void *) t->SecondaryColor3dEXT, (void *) original->SecondaryColor3dEXT);
	if (t->SecondaryColor3dvEXT != original->SecondaryColor3dvEXT)
		crSPUChangeInterface(t, (void *) t->SecondaryColor3dvEXT, (void *) original->SecondaryColor3dvEXT);
	if (t->SecondaryColor3fEXT != original->SecondaryColor3fEXT)
		crSPUChangeInterface(t, (void *) t->SecondaryColor3fEXT, (void *) original->SecondaryColor3fEXT);
	if (t->SecondaryColor3fvEXT != original->SecondaryColor3fvEXT)
		crSPUChangeInterface(t, (void *) t->SecondaryColor3fvEXT, (void *) original->SecondaryColor3fvEXT);
	if (t->SecondaryColor3iEXT != original->SecondaryColor3iEXT)
		crSPUChangeInterface(t, (void *) t->SecondaryColor3iEXT, (void *) original->SecondaryColor3iEXT);
	if (t->SecondaryColor3ivEXT != original->SecondaryColor3ivEXT)
		crSPUChangeInterface(t, (void *) t->SecondaryColor3ivEXT, (void *) original->SecondaryColor3ivEXT);
	if (t->SecondaryColor3sEXT != original->SecondaryColor3sEXT)
		crSPUChangeInterface(t, (void *) t->SecondaryColor3sEXT, (void *) original->SecondaryColor3sEXT);
	if (t->SecondaryColor3svEXT != original->SecondaryColor3svEXT)
		crSPUChangeInterface(t, (void *) t->SecondaryColor3svEXT, (void *) original->SecondaryColor3svEXT);
	if (t->SecondaryColor3ubEXT != original->SecondaryColor3ubEXT)
		crSPUChangeInterface(t, (void *) t->SecondaryColor3ubEXT, (void *) original->SecondaryColor3ubEXT);
	if (t->SecondaryColor3ubvEXT != original->SecondaryColor3ubvEXT)
		crSPUChangeInterface(t, (void *) t->SecondaryColor3ubvEXT, (void *) original->SecondaryColor3ubvEXT);
	if (t->SecondaryColor3uiEXT != original->SecondaryColor3uiEXT)
		crSPUChangeInterface(t, (void *) t->SecondaryColor3uiEXT, (void *) original->SecondaryColor3uiEXT);
	if (t->SecondaryColor3uivEXT != original->SecondaryColor3uivEXT)
		crSPUChangeInterface(t, (void *) t->SecondaryColor3uivEXT, (void *) original->SecondaryColor3uivEXT);
	if (t->SecondaryColor3usEXT != original->SecondaryColor3usEXT)
		crSPUChangeInterface(t, (void *) t->SecondaryColor3usEXT, (void *) original->SecondaryColor3usEXT);
	if (t->SecondaryColor3usvEXT != original->SecondaryColor3usvEXT)
		crSPUChangeInterface(t, (void *) t->SecondaryColor3usvEXT, (void *) original->SecondaryColor3usvEXT);
	if (t->SecondaryColorPointerEXT != original->SecondaryColorPointerEXT)
		crSPUChangeInterface(t, (void *) t->SecondaryColorPointerEXT, (void *) original->SecondaryColorPointerEXT);
	if (t->SelectBuffer != original->SelectBuffer)
		crSPUChangeInterface(t, (void *) t->SelectBuffer, (void *) original->SelectBuffer);
	if (t->SemaphoreCreateCR != original->SemaphoreCreateCR)
		crSPUChangeInterface(t, (void *) t->SemaphoreCreateCR, (void *) original->SemaphoreCreateCR);
	if (t->SemaphoreDestroyCR != original->SemaphoreDestroyCR)
		crSPUChangeInterface(t, (void *) t->SemaphoreDestroyCR, (void *) original->SemaphoreDestroyCR);
	if (t->SemaphorePCR != original->SemaphorePCR)
		crSPUChangeInterface(t, (void *) t->SemaphorePCR, (void *) original->SemaphorePCR);
	if (t->SemaphoreVCR != original->SemaphoreVCR)
		crSPUChangeInterface(t, (void *) t->SemaphoreVCR, (void *) original->SemaphoreVCR);
	if (t->SetFenceNV != original->SetFenceNV)
		crSPUChangeInterface(t, (void *) t->SetFenceNV, (void *) original->SetFenceNV);
	if (t->ShadeModel != original->ShadeModel)
		crSPUChangeInterface(t, (void *) t->ShadeModel, (void *) original->ShadeModel);
	if (t->StencilFunc != original->StencilFunc)
		crSPUChangeInterface(t, (void *) t->StencilFunc, (void *) original->StencilFunc);
	if (t->StencilMask != original->StencilMask)
		crSPUChangeInterface(t, (void *) t->StencilMask, (void *) original->StencilMask);
	if (t->StencilOp != original->StencilOp)
		crSPUChangeInterface(t, (void *) t->StencilOp, (void *) original->StencilOp);
	if (t->SwapBuffers != original->SwapBuffers)
		crSPUChangeInterface(t, (void *) t->SwapBuffers, (void *) original->SwapBuffers);
	if (t->TestFenceNV != original->TestFenceNV)
		crSPUChangeInterface(t, (void *) t->TestFenceNV, (void *) original->TestFenceNV);
	if (t->TexCoord1d != original->TexCoord1d)
		crSPUChangeInterface(t, (void *) t->TexCoord1d, (void *) original->TexCoord1d);
	if (t->TexCoord1dv != original->TexCoord1dv)
		crSPUChangeInterface(t, (void *) t->TexCoord1dv, (void *) original->TexCoord1dv);
	if (t->TexCoord1f != original->TexCoord1f)
		crSPUChangeInterface(t, (void *) t->TexCoord1f, (void *) original->TexCoord1f);
	if (t->TexCoord1fv != original->TexCoord1fv)
		crSPUChangeInterface(t, (void *) t->TexCoord1fv, (void *) original->TexCoord1fv);
	if (t->TexCoord1i != original->TexCoord1i)
		crSPUChangeInterface(t, (void *) t->TexCoord1i, (void *) original->TexCoord1i);
	if (t->TexCoord1iv != original->TexCoord1iv)
		crSPUChangeInterface(t, (void *) t->TexCoord1iv, (void *) original->TexCoord1iv);
	if (t->TexCoord1s != original->TexCoord1s)
		crSPUChangeInterface(t, (void *) t->TexCoord1s, (void *) original->TexCoord1s);
	if (t->TexCoord1sv != original->TexCoord1sv)
		crSPUChangeInterface(t, (void *) t->TexCoord1sv, (void *) original->TexCoord1sv);
	if (t->TexCoord2d != original->TexCoord2d)
		crSPUChangeInterface(t, (void *) t->TexCoord2d, (void *) original->TexCoord2d);
	if (t->TexCoord2dv != original->TexCoord2dv)
		crSPUChangeInterface(t, (void *) t->TexCoord2dv, (void *) original->TexCoord2dv);
	if (t->TexCoord2f != original->TexCoord2f)
		crSPUChangeInterface(t, (void *) t->TexCoord2f, (void *) original->TexCoord2f);
	if (t->TexCoord2fv != original->TexCoord2fv)
		crSPUChangeInterface(t, (void *) t->TexCoord2fv, (void *) original->TexCoord2fv);
	if (t->TexCoord2i != original->TexCoord2i)
		crSPUChangeInterface(t, (void *) t->TexCoord2i, (void *) original->TexCoord2i);
	if (t->TexCoord2iv != original->TexCoord2iv)
		crSPUChangeInterface(t, (void *) t->TexCoord2iv, (void *) original->TexCoord2iv);
	if (t->TexCoord2s != original->TexCoord2s)
		crSPUChangeInterface(t, (void *) t->TexCoord2s, (void *) original->TexCoord2s);
	if (t->TexCoord2sv != original->TexCoord2sv)
		crSPUChangeInterface(t, (void *) t->TexCoord2sv, (void *) original->TexCoord2sv);
	if (t->TexCoord3d != original->TexCoord3d)
		crSPUChangeInterface(t, (void *) t->TexCoord3d, (void *) original->TexCoord3d);
	if (t->TexCoord3dv != original->TexCoord3dv)
		crSPUChangeInterface(t, (void *) t->TexCoord3dv, (void *) original->TexCoord3dv);
	if (t->TexCoord3f != original->TexCoord3f)
		crSPUChangeInterface(t, (void *) t->TexCoord3f, (void *) original->TexCoord3f);
	if (t->TexCoord3fv != original->TexCoord3fv)
		crSPUChangeInterface(t, (void *) t->TexCoord3fv, (void *) original->TexCoord3fv);
	if (t->TexCoord3i != original->TexCoord3i)
		crSPUChangeInterface(t, (void *) t->TexCoord3i, (void *) original->TexCoord3i);
	if (t->TexCoord3iv != original->TexCoord3iv)
		crSPUChangeInterface(t, (void *) t->TexCoord3iv, (void *) original->TexCoord3iv);
	if (t->TexCoord3s != original->TexCoord3s)
		crSPUChangeInterface(t, (void *) t->TexCoord3s, (void *) original->TexCoord3s);
	if (t->TexCoord3sv != original->TexCoord3sv)
		crSPUChangeInterface(t, (void *) t->TexCoord3sv, (void *) original->TexCoord3sv);
	if (t->TexCoord4d != original->TexCoord4d)
		crSPUChangeInterface(t, (void *) t->TexCoord4d, (void *) original->TexCoord4d);
	if (t->TexCoord4dv != original->TexCoord4dv)
		crSPUChangeInterface(t, (void *) t->TexCoord4dv, (void *) original->TexCoord4dv);
	if (t->TexCoord4f != original->TexCoord4f)
		crSPUChangeInterface(t, (void *) t->TexCoord4f, (void *) original->TexCoord4f);
	if (t->TexCoord4fv != original->TexCoord4fv)
		crSPUChangeInterface(t, (void *) t->TexCoord4fv, (void *) original->TexCoord4fv);
	if (t->TexCoord4i != original->TexCoord4i)
		crSPUChangeInterface(t, (void *) t->TexCoord4i, (void *) original->TexCoord4i);
	if (t->TexCoord4iv != original->TexCoord4iv)
		crSPUChangeInterface(t, (void *) t->TexCoord4iv, (void *) original->TexCoord4iv);
	if (t->TexCoord4s != original->TexCoord4s)
		crSPUChangeInterface(t, (void *) t->TexCoord4s, (void *) original->TexCoord4s);
	if (t->TexCoord4sv != original->TexCoord4sv)
		crSPUChangeInterface(t, (void *) t->TexCoord4sv, (void *) original->TexCoord4sv);
	if (t->TexCoordPointer != original->TexCoordPointer)
		crSPUChangeInterface(t, (void *) t->TexCoordPointer, (void *) original->TexCoordPointer);
	if (t->TexEnvf != original->TexEnvf)
		crSPUChangeInterface(t, (void *) t->TexEnvf, (void *) original->TexEnvf);
	if (t->TexEnvfv != original->TexEnvfv)
		crSPUChangeInterface(t, (void *) t->TexEnvfv, (void *) original->TexEnvfv);
	if (t->TexEnvi != original->TexEnvi)
		crSPUChangeInterface(t, (void *) t->TexEnvi, (void *) original->TexEnvi);
	if (t->TexEnviv != original->TexEnviv)
		crSPUChangeInterface(t, (void *) t->TexEnviv, (void *) original->TexEnviv);
	if (t->TexGend != original->TexGend)
		crSPUChangeInterface(t, (void *) t->TexGend, (void *) original->TexGend);
	if (t->TexGendv != original->TexGendv)
		crSPUChangeInterface(t, (void *) t->TexGendv, (void *) original->TexGendv);
	if (t->TexGenf != original->TexGenf)
		crSPUChangeInterface(t, (void *) t->TexGenf, (void *) original->TexGenf);
	if (t->TexGenfv != original->TexGenfv)
		crSPUChangeInterface(t, (void *) t->TexGenfv, (void *) original->TexGenfv);
	if (t->TexGeni != original->TexGeni)
		crSPUChangeInterface(t, (void *) t->TexGeni, (void *) original->TexGeni);
	if (t->TexGeniv != original->TexGeniv)
		crSPUChangeInterface(t, (void *) t->TexGeniv, (void *) original->TexGeniv);
	if (t->TexImage1D != original->TexImage1D)
		crSPUChangeInterface(t, (void *) t->TexImage1D, (void *) original->TexImage1D);
	if (t->TexImage2D != original->TexImage2D)
		crSPUChangeInterface(t, (void *) t->TexImage2D, (void *) original->TexImage2D);
	if (t->TexImage3D != original->TexImage3D)
		crSPUChangeInterface(t, (void *) t->TexImage3D, (void *) original->TexImage3D);
	if (t->TexImage3DEXT != original->TexImage3DEXT)
		crSPUChangeInterface(t, (void *) t->TexImage3DEXT, (void *) original->TexImage3DEXT);
	if (t->TexParameterf != original->TexParameterf)
		crSPUChangeInterface(t, (void *) t->TexParameterf, (void *) original->TexParameterf);
	if (t->TexParameterfv != original->TexParameterfv)
		crSPUChangeInterface(t, (void *) t->TexParameterfv, (void *) original->TexParameterfv);
	if (t->TexParameteri != original->TexParameteri)
		crSPUChangeInterface(t, (void *) t->TexParameteri, (void *) original->TexParameteri);
	if (t->TexParameteriv != original->TexParameteriv)
		crSPUChangeInterface(t, (void *) t->TexParameteriv, (void *) original->TexParameteriv);
	if (t->TexSubImage1D != original->TexSubImage1D)
		crSPUChangeInterface(t, (void *) t->TexSubImage1D, (void *) original->TexSubImage1D);
	if (t->TexSubImage2D != original->TexSubImage2D)
		crSPUChangeInterface(t, (void *) t->TexSubImage2D, (void *) original->TexSubImage2D);
	if (t->TexSubImage3D != original->TexSubImage3D)
		crSPUChangeInterface(t, (void *) t->TexSubImage3D, (void *) original->TexSubImage3D);
	if (t->TrackMatrixNV != original->TrackMatrixNV)
		crSPUChangeInterface(t, (void *) t->TrackMatrixNV, (void *) original->TrackMatrixNV);
	if (t->Translated != original->Translated)
		crSPUChangeInterface(t, (void *) t->Translated, (void *) original->Translated);
	if (t->Translatef != original->Translatef)
		crSPUChangeInterface(t, (void *) t->Translatef, (void *) original->Translatef);
	if (t->UnmapBufferARB != original->UnmapBufferARB)
		crSPUChangeInterface(t, (void *) t->UnmapBufferARB, (void *) original->UnmapBufferARB);
	if (t->Vertex2d != original->Vertex2d)
		crSPUChangeInterface(t, (void *) t->Vertex2d, (void *) original->Vertex2d);
	if (t->Vertex2dv != original->Vertex2dv)
		crSPUChangeInterface(t, (void *) t->Vertex2dv, (void *) original->Vertex2dv);
	if (t->Vertex2f != original->Vertex2f)
		crSPUChangeInterface(t, (void *) t->Vertex2f, (void *) original->Vertex2f);
	if (t->Vertex2fv != original->Vertex2fv)
		crSPUChangeInterface(t, (void *) t->Vertex2fv, (void *) original->Vertex2fv);
	if (t->Vertex2i != original->Vertex2i)
		crSPUChangeInterface(t, (void *) t->Vertex2i, (void *) original->Vertex2i);
	if (t->Vertex2iv != original->Vertex2iv)
		crSPUChangeInterface(t, (void *) t->Vertex2iv, (void *) original->Vertex2iv);
	if (t->Vertex2s != original->Vertex2s)
		crSPUChangeInterface(t, (void *) t->Vertex2s, (void *) original->Vertex2s);
	if (t->Vertex2sv != original->Vertex2sv)
		crSPUChangeInterface(t, (void *) t->Vertex2sv, (void *) original->Vertex2sv);
	if (t->Vertex3d != original->Vertex3d)
		crSPUChangeInterface(t, (void *) t->Vertex3d, (void *) original->Vertex3d);
	if (t->Vertex3dv != original->Vertex3dv)
		crSPUChangeInterface(t, (void *) t->Vertex3dv, (void *) original->Vertex3dv);
	if (t->Vertex3f != original->Vertex3f)
		crSPUChangeInterface(t, (void *) t->Vertex3f, (void *) original->Vertex3f);
	if (t->Vertex3fv != original->Vertex3fv)
		crSPUChangeInterface(t, (void *) t->Vertex3fv, (void *) original->Vertex3fv);
	if (t->Vertex3i != original->Vertex3i)
		crSPUChangeInterface(t, (void *) t->Vertex3i, (void *) original->Vertex3i);
	if (t->Vertex3iv != original->Vertex3iv)
		crSPUChangeInterface(t, (void *) t->Vertex3iv, (void *) original->Vertex3iv);
	if (t->Vertex3s != original->Vertex3s)
		crSPUChangeInterface(t, (void *) t->Vertex3s, (void *) original->Vertex3s);
	if (t->Vertex3sv != original->Vertex3sv)
		crSPUChangeInterface(t, (void *) t->Vertex3sv, (void *) original->Vertex3sv);
	if (t->Vertex4d != original->Vertex4d)
		crSPUChangeInterface(t, (void *) t->Vertex4d, (void *) original->Vertex4d);
	if (t->Vertex4dv != original->Vertex4dv)
		crSPUChangeInterface(t, (void *) t->Vertex4dv, (void *) original->Vertex4dv);
	if (t->Vertex4f != original->Vertex4f)
		crSPUChangeInterface(t, (void *) t->Vertex4f, (void *) original->Vertex4f);
	if (t->Vertex4fv != original->Vertex4fv)
		crSPUChangeInterface(t, (void *) t->Vertex4fv, (void *) original->Vertex4fv);
	if (t->Vertex4i != original->Vertex4i)
		crSPUChangeInterface(t, (void *) t->Vertex4i, (void *) original->Vertex4i);
	if (t->Vertex4iv != original->Vertex4iv)
		crSPUChangeInterface(t, (void *) t->Vertex4iv, (void *) original->Vertex4iv);
	if (t->Vertex4s != original->Vertex4s)
		crSPUChangeInterface(t, (void *) t->Vertex4s, (void *) original->Vertex4s);
	if (t->Vertex4sv != original->Vertex4sv)
		crSPUChangeInterface(t, (void *) t->Vertex4sv, (void *) original->Vertex4sv);
	if (t->VertexArrayRangeNV != original->VertexArrayRangeNV)
		crSPUChangeInterface(t, (void *) t->VertexArrayRangeNV, (void *) original->VertexArrayRangeNV);
	if (t->VertexAttrib1dARB != original->VertexAttrib1dARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib1dARB, (void *) original->VertexAttrib1dARB);
	if (t->VertexAttrib1dvARB != original->VertexAttrib1dvARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib1dvARB, (void *) original->VertexAttrib1dvARB);
	if (t->VertexAttrib1fARB != original->VertexAttrib1fARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib1fARB, (void *) original->VertexAttrib1fARB);
	if (t->VertexAttrib1fvARB != original->VertexAttrib1fvARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib1fvARB, (void *) original->VertexAttrib1fvARB);
	if (t->VertexAttrib1sARB != original->VertexAttrib1sARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib1sARB, (void *) original->VertexAttrib1sARB);
	if (t->VertexAttrib1svARB != original->VertexAttrib1svARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib1svARB, (void *) original->VertexAttrib1svARB);
	if (t->VertexAttrib2dARB != original->VertexAttrib2dARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib2dARB, (void *) original->VertexAttrib2dARB);
	if (t->VertexAttrib2dvARB != original->VertexAttrib2dvARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib2dvARB, (void *) original->VertexAttrib2dvARB);
	if (t->VertexAttrib2fARB != original->VertexAttrib2fARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib2fARB, (void *) original->VertexAttrib2fARB);
	if (t->VertexAttrib2fvARB != original->VertexAttrib2fvARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib2fvARB, (void *) original->VertexAttrib2fvARB);
	if (t->VertexAttrib2sARB != original->VertexAttrib2sARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib2sARB, (void *) original->VertexAttrib2sARB);
	if (t->VertexAttrib2svARB != original->VertexAttrib2svARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib2svARB, (void *) original->VertexAttrib2svARB);
	if (t->VertexAttrib3dARB != original->VertexAttrib3dARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib3dARB, (void *) original->VertexAttrib3dARB);
	if (t->VertexAttrib3dvARB != original->VertexAttrib3dvARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib3dvARB, (void *) original->VertexAttrib3dvARB);
	if (t->VertexAttrib3fARB != original->VertexAttrib3fARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib3fARB, (void *) original->VertexAttrib3fARB);
	if (t->VertexAttrib3fvARB != original->VertexAttrib3fvARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib3fvARB, (void *) original->VertexAttrib3fvARB);
	if (t->VertexAttrib3sARB != original->VertexAttrib3sARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib3sARB, (void *) original->VertexAttrib3sARB);
	if (t->VertexAttrib3svARB != original->VertexAttrib3svARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib3svARB, (void *) original->VertexAttrib3svARB);
	if (t->VertexAttrib4NbvARB != original->VertexAttrib4NbvARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib4NbvARB, (void *) original->VertexAttrib4NbvARB);
	if (t->VertexAttrib4NivARB != original->VertexAttrib4NivARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib4NivARB, (void *) original->VertexAttrib4NivARB);
	if (t->VertexAttrib4NsvARB != original->VertexAttrib4NsvARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib4NsvARB, (void *) original->VertexAttrib4NsvARB);
	if (t->VertexAttrib4NubARB != original->VertexAttrib4NubARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib4NubARB, (void *) original->VertexAttrib4NubARB);
	if (t->VertexAttrib4NubvARB != original->VertexAttrib4NubvARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib4NubvARB, (void *) original->VertexAttrib4NubvARB);
	if (t->VertexAttrib4NuivARB != original->VertexAttrib4NuivARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib4NuivARB, (void *) original->VertexAttrib4NuivARB);
	if (t->VertexAttrib4NusvARB != original->VertexAttrib4NusvARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib4NusvARB, (void *) original->VertexAttrib4NusvARB);
	if (t->VertexAttrib4bvARB != original->VertexAttrib4bvARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib4bvARB, (void *) original->VertexAttrib4bvARB);
	if (t->VertexAttrib4dARB != original->VertexAttrib4dARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib4dARB, (void *) original->VertexAttrib4dARB);
	if (t->VertexAttrib4dvARB != original->VertexAttrib4dvARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib4dvARB, (void *) original->VertexAttrib4dvARB);
	if (t->VertexAttrib4fARB != original->VertexAttrib4fARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib4fARB, (void *) original->VertexAttrib4fARB);
	if (t->VertexAttrib4fvARB != original->VertexAttrib4fvARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib4fvARB, (void *) original->VertexAttrib4fvARB);
	if (t->VertexAttrib4ivARB != original->VertexAttrib4ivARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib4ivARB, (void *) original->VertexAttrib4ivARB);
	if (t->VertexAttrib4sARB != original->VertexAttrib4sARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib4sARB, (void *) original->VertexAttrib4sARB);
	if (t->VertexAttrib4svARB != original->VertexAttrib4svARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib4svARB, (void *) original->VertexAttrib4svARB);
	if (t->VertexAttrib4ubvARB != original->VertexAttrib4ubvARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib4ubvARB, (void *) original->VertexAttrib4ubvARB);
	if (t->VertexAttrib4uivARB != original->VertexAttrib4uivARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib4uivARB, (void *) original->VertexAttrib4uivARB);
	if (t->VertexAttrib4usvARB != original->VertexAttrib4usvARB)
		crSPUChangeInterface(t, (void *) t->VertexAttrib4usvARB, (void *) original->VertexAttrib4usvARB);
	if (t->VertexAttribPointerARB != original->VertexAttribPointerARB)
		crSPUChangeInterface(t, (void *) t->VertexAttribPointerARB, (void *) original->VertexAttribPointerARB);
	if (t->VertexAttribPointerNV != original->VertexAttribPointerNV)
		crSPUChangeInterface(t, (void *) t->VertexAttribPointerNV, (void *) original->VertexAttribPointerNV);
	if (t->VertexAttribs1dvNV != original->VertexAttribs1dvNV)
		crSPUChangeInterface(t, (void *) t->VertexAttribs1dvNV, (void *) original->VertexAttribs1dvNV);
	if (t->VertexAttribs1fvNV != original->VertexAttribs1fvNV)
		crSPUChangeInterface(t, (void *) t->VertexAttribs1fvNV, (void *) original->VertexAttribs1fvNV);
	if (t->VertexAttribs1svNV != original->VertexAttribs1svNV)
		crSPUChangeInterface(t, (void *) t->VertexAttribs1svNV, (void *) original->VertexAttribs1svNV);
	if (t->VertexAttribs2dvNV != original->VertexAttribs2dvNV)
		crSPUChangeInterface(t, (void *) t->VertexAttribs2dvNV, (void *) original->VertexAttribs2dvNV);
	if (t->VertexAttribs2fvNV != original->VertexAttribs2fvNV)
		crSPUChangeInterface(t, (void *) t->VertexAttribs2fvNV, (void *) original->VertexAttribs2fvNV);
	if (t->VertexAttribs2svNV != original->VertexAttribs2svNV)
		crSPUChangeInterface(t, (void *) t->VertexAttribs2svNV, (void *) original->VertexAttribs2svNV);
	if (t->VertexAttribs3dvNV != original->VertexAttribs3dvNV)
		crSPUChangeInterface(t, (void *) t->VertexAttribs3dvNV, (void *) original->VertexAttribs3dvNV);
	if (t->VertexAttribs3fvNV != original->VertexAttribs3fvNV)
		crSPUChangeInterface(t, (void *) t->VertexAttribs3fvNV, (void *) original->VertexAttribs3fvNV);
	if (t->VertexAttribs3svNV != original->VertexAttribs3svNV)
		crSPUChangeInterface(t, (void *) t->VertexAttribs3svNV, (void *) original->VertexAttribs3svNV);
	if (t->VertexAttribs4dvNV != original->VertexAttribs4dvNV)
		crSPUChangeInterface(t, (void *) t->VertexAttribs4dvNV, (void *) original->VertexAttribs4dvNV);
	if (t->VertexAttribs4fvNV != original->VertexAttribs4fvNV)
		crSPUChangeInterface(t, (void *) t->VertexAttribs4fvNV, (void *) original->VertexAttribs4fvNV);
	if (t->VertexAttribs4svNV != original->VertexAttribs4svNV)
		crSPUChangeInterface(t, (void *) t->VertexAttribs4svNV, (void *) original->VertexAttribs4svNV);
	if (t->VertexAttribs4ubvNV != original->VertexAttribs4ubvNV)
		crSPUChangeInterface(t, (void *) t->VertexAttribs4ubvNV, (void *) original->VertexAttribs4ubvNV);
	if (t->VertexPointer != original->VertexPointer)
		crSPUChangeInterface(t, (void *) t->VertexPointer, (void *) original->VertexPointer);
	if (t->Viewport != original->Viewport)
		crSPUChangeInterface(t, (void *) t->Viewport, (void *) original->Viewport);
	if (t->WindowCreate != original->WindowCreate)
		crSPUChangeInterface(t, (void *) t->WindowCreate, (void *) original->WindowCreate);
	if (t->WindowDestroy != original->WindowDestroy)
		crSPUChangeInterface(t, (void *) t->WindowDestroy, (void *) original->WindowDestroy);
	if (t->WindowPos2dARB != original->WindowPos2dARB)
		crSPUChangeInterface(t, (void *) t->WindowPos2dARB, (void *) original->WindowPos2dARB);
	if (t->WindowPos2dvARB != original->WindowPos2dvARB)
		crSPUChangeInterface(t, (void *) t->WindowPos2dvARB, (void *) original->WindowPos2dvARB);
	if (t->WindowPos2fARB != original->WindowPos2fARB)
		crSPUChangeInterface(t, (void *) t->WindowPos2fARB, (void *) original->WindowPos2fARB);
	if (t->WindowPos2fvARB != original->WindowPos2fvARB)
		crSPUChangeInterface(t, (void *) t->WindowPos2fvARB, (void *) original->WindowPos2fvARB);
	if (t->WindowPos2iARB != original->WindowPos2iARB)
		crSPUChangeInterface(t, (void *) t->WindowPos2iARB, (void *) original->WindowPos2iARB);
	if (t->WindowPos2ivARB != original->WindowPos2ivARB)
		crSPUChangeInterface(t, (void *) t->WindowPos2ivARB, (void *) original->WindowPos2ivARB);
	if (t->WindowPos2sARB != original->WindowPos2sARB)
		crSPUChangeInterface(t, (void *) t->WindowPos2sARB, (void *) original->WindowPos2sARB);
	if (t->WindowPos2svARB != original->WindowPos2svARB)
		crSPUChangeInterface(t, (void *) t->WindowPos2svARB, (void *) original->WindowPos2svARB);
	if (t->WindowPos3dARB != original->WindowPos3dARB)
		crSPUChangeInterface(t, (void *) t->WindowPos3dARB, (void *) original->WindowPos3dARB);
	if (t->WindowPos3dvARB != original->WindowPos3dvARB)
		crSPUChangeInterface(t, (void *) t->WindowPos3dvARB, (void *) original->WindowPos3dvARB);
	if (t->WindowPos3fARB != original->WindowPos3fARB)
		crSPUChangeInterface(t, (void *) t->WindowPos3fARB, (void *) original->WindowPos3fARB);
	if (t->WindowPos3fvARB != original->WindowPos3fvARB)
		crSPUChangeInterface(t, (void *) t->WindowPos3fvARB, (void *) original->WindowPos3fvARB);
	if (t->WindowPos3iARB != original->WindowPos3iARB)
		crSPUChangeInterface(t, (void *) t->WindowPos3iARB, (void *) original->WindowPos3iARB);
	if (t->WindowPos3ivARB != original->WindowPos3ivARB)
		crSPUChangeInterface(t, (void *) t->WindowPos3ivARB, (void *) original->WindowPos3ivARB);
	if (t->WindowPos3sARB != original->WindowPos3sARB)
		crSPUChangeInterface(t, (void *) t->WindowPos3sARB, (void *) original->WindowPos3sARB);
	if (t->WindowPos3svARB != original->WindowPos3svARB)
		crSPUChangeInterface(t, (void *) t->WindowPos3svARB, (void *) original->WindowPos3svARB);
	if (t->WindowPosition != original->WindowPosition)
		crSPUChangeInterface(t, (void *) t->WindowPosition, (void *) original->WindowPosition);
	if (t->WindowShow != original->WindowShow)
		crSPUChangeInterface(t, (void *) t->WindowShow, (void *) original->WindowShow);
	if (t->WindowSize != original->WindowSize)
		crSPUChangeInterface(t, (void *) t->WindowSize, (void *) original->WindowSize);
	if (t->Writeback != original->Writeback)
		crSPUChangeInterface(t, (void *) t->Writeback, (void *) original->Writeback);
	if (t->ZPixCR != original->ZPixCR)
		crSPUChangeInterface(t, (void *) t->ZPixCR, (void *) original->ZPixCR);
}


void *crdlm_silence_warnings[] = {
	(void *) passAccum,
	(void *) passActiveTextureARB,
	(void *) passAlphaFunc,
	(void *) passAreProgramsResidentNV,
	(void *) passAreTexturesResident,
	(void *) passArrayElement,
	(void *) passBarrierCreateCR,
	(void *) passBarrierDestroyCR,
	(void *) passBarrierExecCR,
	(void *) passBegin,
	(void *) passBeginQueryARB,
	(void *) passBindBufferARB,
	(void *) passBindProgramARB,
	(void *) passBindProgramNV,
	(void *) passBindTexture,
	(void *) passBitmap,
	(void *) passBlendColorEXT,
	(void *) passBlendEquationEXT,
	(void *) passBlendFunc,
	(void *) passBlendFuncSeparateEXT,
	(void *) passBoundsInfoCR,
	(void *) passBufferDataARB,
	(void *) passBufferSubDataARB,
	(void *) passCallList,
	(void *) passCallLists,
	(void *) passChromiumParameterfCR,
	(void *) passChromiumParameteriCR,
	(void *) passChromiumParametervCR,
	(void *) passClear,
	(void *) passClearAccum,
	(void *) passClearColor,
	(void *) passClearDepth,
	(void *) passClearIndex,
	(void *) passClearStencil,
	(void *) passClientActiveTextureARB,
	(void *) passClipPlane,
	(void *) passColor3b,
	(void *) passColor3bv,
	(void *) passColor3d,
	(void *) passColor3dv,
	(void *) passColor3f,
	(void *) passColor3fv,
	(void *) passColor3i,
	(void *) passColor3iv,
	(void *) passColor3s,
	(void *) passColor3sv,
	(void *) passColor3ub,
	(void *) passColor3ubv,
	(void *) passColor3ui,
	(void *) passColor3uiv,
	(void *) passColor3us,
	(void *) passColor3usv,
	(void *) passColor4b,
	(void *) passColor4bv,
	(void *) passColor4d,
	(void *) passColor4dv,
	(void *) passColor4f,
	(void *) passColor4fv,
	(void *) passColor4i,
	(void *) passColor4iv,
	(void *) passColor4s,
	(void *) passColor4sv,
	(void *) passColor4ub,
	(void *) passColor4ubv,
	(void *) passColor4ui,
	(void *) passColor4uiv,
	(void *) passColor4us,
	(void *) passColor4usv,
	(void *) passColorMask,
	(void *) passColorMaterial,
	(void *) passColorPointer,
	(void *) passCombinerInputNV,
	(void *) passCombinerOutputNV,
	(void *) passCombinerParameterfNV,
	(void *) passCombinerParameterfvNV,
	(void *) passCombinerParameteriNV,
	(void *) passCombinerParameterivNV,
	(void *) passCombinerStageParameterfvNV,
	(void *) passCompressedTexImage1DARB,
	(void *) passCompressedTexImage2DARB,
	(void *) passCompressedTexImage3DARB,
	(void *) passCompressedTexSubImage1DARB,
	(void *) passCompressedTexSubImage2DARB,
	(void *) passCompressedTexSubImage3DARB,
	(void *) passCopyPixels,
	(void *) passCopyTexImage1D,
	(void *) passCopyTexImage2D,
	(void *) passCopyTexSubImage1D,
	(void *) passCopyTexSubImage2D,
	(void *) passCopyTexSubImage3D,
	(void *) passCreateContext,
	(void *) passCullFace,
	(void *) passDeleteBuffersARB,
	(void *) passDeleteFencesNV,
	(void *) passDeleteLists,
	(void *) passDeleteProgramsARB,
	(void *) passDeleteQueriesARB,
	(void *) passDeleteTextures,
	(void *) passDepthFunc,
	(void *) passDepthMask,
	(void *) passDepthRange,
	(void *) passDestroyContext,
	(void *) passDisable,
	(void *) passDisableClientState,
	(void *) passDisableVertexAttribArrayARB,
	(void *) passDrawArrays,
	(void *) passDrawBuffer,
	(void *) passDrawElements,
	(void *) passDrawPixels,
	(void *) passDrawRangeElements,
	(void *) passEdgeFlag,
	(void *) passEdgeFlagPointer,
	(void *) passEdgeFlagv,
	(void *) passEnable,
	(void *) passEnableClientState,
	(void *) passEnableVertexAttribArrayARB,
	(void *) passEnd,
	(void *) passEndList,
	(void *) passEndQueryARB,
	(void *) passEvalCoord1d,
	(void *) passEvalCoord1dv,
	(void *) passEvalCoord1f,
	(void *) passEvalCoord1fv,
	(void *) passEvalCoord2d,
	(void *) passEvalCoord2dv,
	(void *) passEvalCoord2f,
	(void *) passEvalCoord2fv,
	(void *) passEvalMesh1,
	(void *) passEvalMesh2,
	(void *) passEvalPoint1,
	(void *) passEvalPoint2,
	(void *) passExecuteProgramNV,
	(void *) passFeedbackBuffer,
	(void *) passFinalCombinerInputNV,
	(void *) passFinish,
	(void *) passFinishFenceNV,
	(void *) passFlush,
	(void *) passFlushVertexArrayRangeNV,
	(void *) passFogCoordPointerEXT,
	(void *) passFogCoorddEXT,
	(void *) passFogCoorddvEXT,
	(void *) passFogCoordfEXT,
	(void *) passFogCoordfvEXT,
	(void *) passFogf,
	(void *) passFogfv,
	(void *) passFogi,
	(void *) passFogiv,
	(void *) passFrontFace,
	(void *) passFrustum,
	(void *) passGenBuffersARB,
	(void *) passGenFencesNV,
	(void *) passGenLists,
	(void *) passGenProgramsARB,
	(void *) passGenProgramsNV,
	(void *) passGenQueriesARB,
	(void *) passGenTextures,
	(void *) passGetBooleanv,
	(void *) passGetBufferParameterivARB,
	(void *) passGetBufferPointervARB,
	(void *) passGetBufferSubDataARB,
	(void *) passGetChromiumParametervCR,
	(void *) passGetClipPlane,
	(void *) passGetCombinerInputParameterfvNV,
	(void *) passGetCombinerInputParameterivNV,
	(void *) passGetCombinerOutputParameterfvNV,
	(void *) passGetCombinerOutputParameterivNV,
	(void *) passGetCombinerStageParameterfvNV,
	(void *) passGetCompressedTexImageARB,
	(void *) passGetDoublev,
	(void *) passGetError,
	(void *) passGetFenceivNV,
	(void *) passGetFinalCombinerInputParameterfvNV,
	(void *) passGetFinalCombinerInputParameterivNV,
	(void *) passGetFloatv,
	(void *) passGetIntegerv,
	(void *) passGetLightfv,
	(void *) passGetLightiv,
	(void *) passGetMapdv,
	(void *) passGetMapfv,
	(void *) passGetMapiv,
	(void *) passGetMaterialfv,
	(void *) passGetMaterialiv,
	(void *) passGetPixelMapfv,
	(void *) passGetPixelMapuiv,
	(void *) passGetPixelMapusv,
	(void *) passGetPointerv,
	(void *) passGetPolygonStipple,
	(void *) passGetProgramEnvParameterdvARB,
	(void *) passGetProgramEnvParameterfvARB,
	(void *) passGetProgramLocalParameterdvARB,
	(void *) passGetProgramLocalParameterfvARB,
	(void *) passGetProgramNamedParameterdvNV,
	(void *) passGetProgramNamedParameterfvNV,
	(void *) passGetProgramParameterdvNV,
	(void *) passGetProgramParameterfvNV,
	(void *) passGetProgramStringARB,
	(void *) passGetProgramStringNV,
	(void *) passGetProgramivARB,
	(void *) passGetProgramivNV,
	(void *) passGetQueryObjectivARB,
	(void *) passGetQueryObjectuivARB,
	(void *) passGetQueryivARB,
	(void *) passGetString,
	(void *) passGetTexEnvfv,
	(void *) passGetTexEnviv,
	(void *) passGetTexGendv,
	(void *) passGetTexGenfv,
	(void *) passGetTexGeniv,
	(void *) passGetTexImage,
	(void *) passGetTexLevelParameterfv,
	(void *) passGetTexLevelParameteriv,
	(void *) passGetTexParameterfv,
	(void *) passGetTexParameteriv,
	(void *) passGetTrackMatrixivNV,
	(void *) passGetVertexAttribPointervARB,
	(void *) passGetVertexAttribPointervNV,
	(void *) passGetVertexAttribdvARB,
	(void *) passGetVertexAttribdvNV,
	(void *) passGetVertexAttribfvARB,
	(void *) passGetVertexAttribfvNV,
	(void *) passGetVertexAttribivARB,
	(void *) passGetVertexAttribivNV,
	(void *) passHint,
	(void *) passIndexMask,
	(void *) passIndexPointer,
	(void *) passIndexd,
	(void *) passIndexdv,
	(void *) passIndexf,
	(void *) passIndexfv,
	(void *) passIndexi,
	(void *) passIndexiv,
	(void *) passIndexs,
	(void *) passIndexsv,
	(void *) passIndexub,
	(void *) passIndexubv,
	(void *) passInitNames,
	(void *) passInterleavedArrays,
	(void *) passIsBufferARB,
	(void *) passIsEnabled,
	(void *) passIsFenceNV,
	(void *) passIsList,
	(void *) passIsProgramARB,
	(void *) passIsQueryARB,
	(void *) passIsTexture,
	(void *) passLightModelf,
	(void *) passLightModelfv,
	(void *) passLightModeli,
	(void *) passLightModeliv,
	(void *) passLightf,
	(void *) passLightfv,
	(void *) passLighti,
	(void *) passLightiv,
	(void *) passLineStipple,
	(void *) passLineWidth,
	(void *) passListBase,
	(void *) passLoadIdentity,
	(void *) passLoadMatrixd,
	(void *) passLoadMatrixf,
	(void *) passLoadName,
	(void *) passLoadProgramNV,
	(void *) passLoadTransposeMatrixdARB,
	(void *) passLoadTransposeMatrixfARB,
	(void *) passLogicOp,
	(void *) passMakeCurrent,
	(void *) passMap1d,
	(void *) passMap1f,
	(void *) passMap2d,
	(void *) passMap2f,
	(void *) passMapBufferARB,
	(void *) passMapGrid1d,
	(void *) passMapGrid1f,
	(void *) passMapGrid2d,
	(void *) passMapGrid2f,
	(void *) passMaterialf,
	(void *) passMaterialfv,
	(void *) passMateriali,
	(void *) passMaterialiv,
	(void *) passMatrixMode,
	(void *) passMultMatrixd,
	(void *) passMultMatrixf,
	(void *) passMultTransposeMatrixdARB,
	(void *) passMultTransposeMatrixfARB,
	(void *) passMultiDrawArraysEXT,
	(void *) passMultiDrawElementsEXT,
	(void *) passMultiTexCoord1dARB,
	(void *) passMultiTexCoord1dvARB,
	(void *) passMultiTexCoord1fARB,
	(void *) passMultiTexCoord1fvARB,
	(void *) passMultiTexCoord1iARB,
	(void *) passMultiTexCoord1ivARB,
	(void *) passMultiTexCoord1sARB,
	(void *) passMultiTexCoord1svARB,
	(void *) passMultiTexCoord2dARB,
	(void *) passMultiTexCoord2dvARB,
	(void *) passMultiTexCoord2fARB,
	(void *) passMultiTexCoord2fvARB,
	(void *) passMultiTexCoord2iARB,
	(void *) passMultiTexCoord2ivARB,
	(void *) passMultiTexCoord2sARB,
	(void *) passMultiTexCoord2svARB,
	(void *) passMultiTexCoord3dARB,
	(void *) passMultiTexCoord3dvARB,
	(void *) passMultiTexCoord3fARB,
	(void *) passMultiTexCoord3fvARB,
	(void *) passMultiTexCoord3iARB,
	(void *) passMultiTexCoord3ivARB,
	(void *) passMultiTexCoord3sARB,
	(void *) passMultiTexCoord3svARB,
	(void *) passMultiTexCoord4dARB,
	(void *) passMultiTexCoord4dvARB,
	(void *) passMultiTexCoord4fARB,
	(void *) passMultiTexCoord4fvARB,
	(void *) passMultiTexCoord4iARB,
	(void *) passMultiTexCoord4ivARB,
	(void *) passMultiTexCoord4sARB,
	(void *) passMultiTexCoord4svARB,
	(void *) passNewList,
	(void *) passNormal3b,
	(void *) passNormal3bv,
	(void *) passNormal3d,
	(void *) passNormal3dv,
	(void *) passNormal3f,
	(void *) passNormal3fv,
	(void *) passNormal3i,
	(void *) passNormal3iv,
	(void *) passNormal3s,
	(void *) passNormal3sv,
	(void *) passNormalPointer,
	(void *) passOrtho,
	(void *) passPassThrough,
	(void *) passPixelMapfv,
	(void *) passPixelMapuiv,
	(void *) passPixelMapusv,
	(void *) passPixelStoref,
	(void *) passPixelStorei,
	(void *) passPixelTransferf,
	(void *) passPixelTransferi,
	(void *) passPixelZoom,
	(void *) passPointParameterfARB,
	(void *) passPointParameterfvARB,
	(void *) passPointParameteri,
	(void *) passPointParameteriv,
	(void *) passPointSize,
	(void *) passPolygonMode,
	(void *) passPolygonOffset,
	(void *) passPolygonStipple,
	(void *) passPopAttrib,
	(void *) passPopClientAttrib,
	(void *) passPopMatrix,
	(void *) passPopName,
	(void *) passPrioritizeTextures,
	(void *) passProgramEnvParameter4dARB,
	(void *) passProgramEnvParameter4dvARB,
	(void *) passProgramEnvParameter4fARB,
	(void *) passProgramEnvParameter4fvARB,
	(void *) passProgramLocalParameter4dARB,
	(void *) passProgramLocalParameter4dvARB,
	(void *) passProgramLocalParameter4fARB,
	(void *) passProgramLocalParameter4fvARB,
	(void *) passProgramNamedParameter4dNV,
	(void *) passProgramNamedParameter4dvNV,
	(void *) passProgramNamedParameter4fNV,
	(void *) passProgramNamedParameter4fvNV,
	(void *) passProgramParameter4dNV,
	(void *) passProgramParameter4dvNV,
	(void *) passProgramParameter4fNV,
	(void *) passProgramParameter4fvNV,
	(void *) passProgramParameters4dvNV,
	(void *) passProgramParameters4fvNV,
	(void *) passProgramStringARB,
	(void *) passPushAttrib,
	(void *) passPushClientAttrib,
	(void *) passPushMatrix,
	(void *) passPushName,
	(void *) passRasterPos2d,
	(void *) passRasterPos2dv,
	(void *) passRasterPos2f,
	(void *) passRasterPos2fv,
	(void *) passRasterPos2i,
	(void *) passRasterPos2iv,
	(void *) passRasterPos2s,
	(void *) passRasterPos2sv,
	(void *) passRasterPos3d,
	(void *) passRasterPos3dv,
	(void *) passRasterPos3f,
	(void *) passRasterPos3fv,
	(void *) passRasterPos3i,
	(void *) passRasterPos3iv,
	(void *) passRasterPos3s,
	(void *) passRasterPos3sv,
	(void *) passRasterPos4d,
	(void *) passRasterPos4dv,
	(void *) passRasterPos4f,
	(void *) passRasterPos4fv,
	(void *) passRasterPos4i,
	(void *) passRasterPos4iv,
	(void *) passRasterPos4s,
	(void *) passRasterPos4sv,
	(void *) passReadBuffer,
	(void *) passReadPixels,
	(void *) passRectd,
	(void *) passRectdv,
	(void *) passRectf,
	(void *) passRectfv,
	(void *) passRecti,
	(void *) passRectiv,
	(void *) passRects,
	(void *) passRectsv,
	(void *) passRenderMode,
	(void *) passRequestResidentProgramsNV,
	(void *) passRotated,
	(void *) passRotatef,
	(void *) passSampleCoverageARB,
	(void *) passScaled,
	(void *) passScalef,
	(void *) passScissor,
	(void *) passSecondaryColor3bEXT,
	(void *) passSecondaryColor3bvEXT,
	(void *) passSecondaryColor3dEXT,
	(void *) passSecondaryColor3dvEXT,
	(void *) passSecondaryColor3fEXT,
	(void *) passSecondaryColor3fvEXT,
	(void *) passSecondaryColor3iEXT,
	(void *) passSecondaryColor3ivEXT,
	(void *) passSecondaryColor3sEXT,
	(void *) passSecondaryColor3svEXT,
	(void *) passSecondaryColor3ubEXT,
	(void *) passSecondaryColor3ubvEXT,
	(void *) passSecondaryColor3uiEXT,
	(void *) passSecondaryColor3uivEXT,
	(void *) passSecondaryColor3usEXT,
	(void *) passSecondaryColor3usvEXT,
	(void *) passSecondaryColorPointerEXT,
	(void *) passSelectBuffer,
	(void *) passSemaphoreCreateCR,
	(void *) passSemaphoreDestroyCR,
	(void *) passSemaphorePCR,
	(void *) passSemaphoreVCR,
	(void *) passSetFenceNV,
	(void *) passShadeModel,
	(void *) passStencilFunc,
	(void *) passStencilMask,
	(void *) passStencilOp,
	(void *) passSwapBuffers,
	(void *) passTestFenceNV,
	(void *) passTexCoord1d,
	(void *) passTexCoord1dv,
	(void *) passTexCoord1f,
	(void *) passTexCoord1fv,
	(void *) passTexCoord1i,
	(void *) passTexCoord1iv,
	(void *) passTexCoord1s,
	(void *) passTexCoord1sv,
	(void *) passTexCoord2d,
	(void *) passTexCoord2dv,
	(void *) passTexCoord2f,
	(void *) passTexCoord2fv,
	(void *) passTexCoord2i,
	(void *) passTexCoord2iv,
	(void *) passTexCoord2s,
	(void *) passTexCoord2sv,
	(void *) passTexCoord3d,
	(void *) passTexCoord3dv,
	(void *) passTexCoord3f,
	(void *) passTexCoord3fv,
	(void *) passTexCoord3i,
	(void *) passTexCoord3iv,
	(void *) passTexCoord3s,
	(void *) passTexCoord3sv,
	(void *) passTexCoord4d,
	(void *) passTexCoord4dv,
	(void *) passTexCoord4f,
	(void *) passTexCoord4fv,
	(void *) passTexCoord4i,
	(void *) passTexCoord4iv,
	(void *) passTexCoord4s,
	(void *) passTexCoord4sv,
	(void *) passTexCoordPointer,
	(void *) passTexEnvf,
	(void *) passTexEnvfv,
	(void *) passTexEnvi,
	(void *) passTexEnviv,
	(void *) passTexGend,
	(void *) passTexGendv,
	(void *) passTexGenf,
	(void *) passTexGenfv,
	(void *) passTexGeni,
	(void *) passTexGeniv,
	(void *) passTexImage1D,
	(void *) passTexImage2D,
	(void *) passTexImage3D,
	(void *) passTexImage3DEXT,
	(void *) passTexParameterf,
	(void *) passTexParameterfv,
	(void *) passTexParameteri,
	(void *) passTexParameteriv,
	(void *) passTexSubImage1D,
	(void *) passTexSubImage2D,
	(void *) passTexSubImage3D,
	(void *) passTrackMatrixNV,
	(void *) passTranslated,
	(void *) passTranslatef,
	(void *) passUnmapBufferARB,
	(void *) passVertex2d,
	(void *) passVertex2dv,
	(void *) passVertex2f,
	(void *) passVertex2fv,
	(void *) passVertex2i,
	(void *) passVertex2iv,
	(void *) passVertex2s,
	(void *) passVertex2sv,
	(void *) passVertex3d,
	(void *) passVertex3dv,
	(void *) passVertex3f,
	(void *) passVertex3fv,
	(void *) passVertex3i,
	(void *) passVertex3iv,
	(void *) passVertex3s,
	(void *) passVertex3sv,
	(void *) passVertex4d,
	(void *) passVertex4dv,
	(void *) passVertex4f,
	(void *) passVertex4fv,
	(void *) passVertex4i,
	(void *) passVertex4iv,
	(void *) passVertex4s,
	(void *) passVertex4sv,
	(void *) passVertexArrayRangeNV,
	(void *) passVertexAttrib1dARB,
	(void *) passVertexAttrib1dvARB,
	(void *) passVertexAttrib1fARB,
	(void *) passVertexAttrib1fvARB,
	(void *) passVertexAttrib1sARB,
	(void *) passVertexAttrib1svARB,
	(void *) passVertexAttrib2dARB,
	(void *) passVertexAttrib2dvARB,
	(void *) passVertexAttrib2fARB,
	(void *) passVertexAttrib2fvARB,
	(void *) passVertexAttrib2sARB,
	(void *) passVertexAttrib2svARB,
	(void *) passVertexAttrib3dARB,
	(void *) passVertexAttrib3dvARB,
	(void *) passVertexAttrib3fARB,
	(void *) passVertexAttrib3fvARB,
	(void *) passVertexAttrib3sARB,
	(void *) passVertexAttrib3svARB,
	(void *) passVertexAttrib4NbvARB,
	(void *) passVertexAttrib4NivARB,
	(void *) passVertexAttrib4NsvARB,
	(void *) passVertexAttrib4NubARB,
	(void *) passVertexAttrib4NubvARB,
	(void *) passVertexAttrib4NuivARB,
	(void *) passVertexAttrib4NusvARB,
	(void *) passVertexAttrib4bvARB,
	(void *) passVertexAttrib4dARB,
	(void *) passVertexAttrib4dvARB,
	(void *) passVertexAttrib4fARB,
	(void *) passVertexAttrib4fvARB,
	(void *) passVertexAttrib4ivARB,
	(void *) passVertexAttrib4sARB,
	(void *) passVertexAttrib4svARB,
	(void *) passVertexAttrib4ubvARB,
	(void *) passVertexAttrib4uivARB,
	(void *) passVertexAttrib4usvARB,
	(void *) passVertexAttribPointerARB,
	(void *) passVertexAttribPointerNV,
	(void *) passVertexAttribs1dvNV,
	(void *) passVertexAttribs1fvNV,
	(void *) passVertexAttribs1svNV,
	(void *) passVertexAttribs2dvNV,
	(void *) passVertexAttribs2fvNV,
	(void *) passVertexAttribs2svNV,
	(void *) passVertexAttribs3dvNV,
	(void *) passVertexAttribs3fvNV,
	(void *) passVertexAttribs3svNV,
	(void *) passVertexAttribs4dvNV,
	(void *) passVertexAttribs4fvNV,
	(void *) passVertexAttribs4svNV,
	(void *) passVertexAttribs4ubvNV,
	(void *) passVertexPointer,
	(void *) passViewport,
	(void *) passWindowCreate,
	(void *) passWindowDestroy,
	(void *) passWindowPos2dARB,
	(void *) passWindowPos2dvARB,
	(void *) passWindowPos2fARB,
	(void *) passWindowPos2fvARB,
	(void *) passWindowPos2iARB,
	(void *) passWindowPos2ivARB,
	(void *) passWindowPos2sARB,
	(void *) passWindowPos2svARB,
	(void *) passWindowPos3dARB,
	(void *) passWindowPos3dvARB,
	(void *) passWindowPos3fARB,
	(void *) passWindowPos3fvARB,
	(void *) passWindowPos3iARB,
	(void *) passWindowPos3ivARB,
	(void *) passWindowPos3sARB,
	(void *) passWindowPos3svARB,
	(void *) passWindowPosition,
	(void *) passWindowShow,
	(void *) passWindowSize,
	(void *) passWriteback,
	(void *) passZPixCR,
	NULL
};
